{
    "articles": [
        {
            "id": "1",
            "title": "Глава I: Базовые концепции",
            "content": "<p>Чтобы начать изучение бизнесс-анализа, нам нужно сначала договориться о некоторых общих терминах, чтобы мы могли понимать друг друга.</p><h3>Стейкхолдеры</h3><p><b>Стейкхолдеры</b> — это любые люди или организации, которые могут оказать влияние на ваш продукт или проект или могут подвергнуться влиянию вашего продукта или проекта. Прежде всего, давайте их классифицируем.</p><p><i>Платящий стейкхолдер</i> — представитель компании, которая платит за ваш проект, например, владелец продукта или менеджер продукта (Product Owner, Product Manager), возможно менеджер проекта (Project Manager), который отвечает за бюджет и принимает решение о продолжении финансирования, он заинтересован в реальном бизнес-результате, потому что он платит деньги, и если результатов не будет — вас уволят. К этому же типу стейкхолдеров можно отнести акционеров компании, поскольку они могут покупать, держать или продавать акции и голосовать за решения в совете директоров в зависимости от финансовых результатов компании. Вероятно, они также могут позволить себе купить стейк (steak), но на английском стейкхолдер пишется по-другому (stakeholders).</p><p><i>SME (Subject Matter Expert)</i> — эксперт предметной области, сотрудник, который много знает о бизнесе или системе, может помочь в ней разобраться, он может более не быть связан с продуктом напрямую, но он много знает о продукте и может дать ответы на вопросы о том, как система сторилась и каковы были ожидания от той или иной функциональности.</p><p><i>Команда разработки</i> — они выполняют работу, очень важно информировать их о том, что на самом деле нужно и почему, это ваша работа как бизнес-аналитика.</p><p><i>Команда поддержки</i> — если она есть, люди, которые помогают пользователям использовать систему, исправляют конфигурацию. Им нужно знать, как функционирует продукт, чтобы они могли помогать пользователям.</p><p><i>Конечные пользователи</i> — это люди, которые, в конечном счете, принимают решение об использовании вашего продукта. Именно пользователи генерируют прибыль, и на основе их поведения <b>платящий стейкхолдер</b> определяет ваше будущее.</p><p><i>Правительство</i> — правительство не только требуют от вас платить налоги, но и постоянно придумывают новые правила, о которых вы должны знать, и они не будут вас об этом информировать, поэтому вам лучше следить за заголовками новостей, чтобы не оказаться в тюрьме или не заплатить большой штраф.</p><p><i>Активисты и лоббисты</i> — попробуйте подумать обо всех НКО, которые пытаются подать на вас в суд.</p><p><i>Конкуренты</i> — другие компании, разрабатывающие аналогичный продукт или работающие в том же направлении, которые могут переманить ваших клиентов.</p><p><i>Поставщики и продавцы</i> — другие компании, помогающие бизнесу, могут быть фактическими поставщиками товаров или услуг, например, таким поставщиком услуг можно назвать клининговую компанию, аудитора, других поставщиков ПО.</p><h3>Типы требований</h3><h4>Функциональные и нефункциональные</h4><p><i>Функциональные требования (Functional Requirements - FR)</i> — описание ожиданий того, как должна повести себя система, в основном, в тех случая, когда пользователь совершает какое-то действие. Если при обсуждении требований кто-то говорит вам, что пользователь вообще не вовлечен в процесс, то этот кто-то, скорее всего, не знает о чем он говорит.  Даже если есть автоматическое задание, которое запускается по графику, причиной существования этого задания является использование результатов этого задания пользователем. <i>Пример:</i> допустим, есть цены,  которые наша система извлекает из стороннего API и сохраняет их в базе данных раз в день — эти цены будут использоваться при расчете стоимости заказа, когда пользователь его сформирует.</p><p><i>Нефункциональные требования (Non-Functional Requirements - NFR)</i> — описание ожиданий относительно того, как система должна работать в програмной среде — это требования к производительности (страница должна открываться в течение 3 секунд,  эндпойнт должен быть способен обрабатывать  100 000 записей одновременно), требования к  програмному обеспечению  (приложение должно быть доступно на iOS и Android,  сайт должен работать в IE11  (пожалуйста, скажите мне, что таких требований больше нет)),  требования к переводу (сайт должен быть доступен на испанском языке  — это требование все еще считается нефункциональным, но возможность переключения между языками  уже является функциональным требованием,  поскольку требует внешнего воздействия — действия пользователя),  требования к UX — например, соответствие HIPPA (Health Insurance Portability and Accountability Act - скажем 'привет', типу стейкхолдеров <i>правительство</i>),  когда от вас требуется предоставить аудиочитаемую версию сайта.</p><h4>Бизнес-требования и Системные требования</h4><p><i>Требования стейкхолдеров</i> — плохо сформулированные (возможно даже неправильно сформулированные) фрагменты предложений и мыслей, которые должен обработать бизнес-аналитик. В основном это проблемы бизнеса (например, «Я не знаю, пользователи будто игнорируют нашу новую страницу с прогнозом погоды, можем ли мы сделать большую красную кнопку, которая вела бы их туда прямо с лендинга?»)</p><p><i>Бизнес-требования</i> — ваш домен, эти требования должны быть хорошо структурированы, должны описывать, как работает система. («добавьте кнопку в центр главной страницы, следуйте дизайну, описанному в Figma (ссылка на источник); только пользователи, подписанные на план B, могут видеть эту кнопку и эту страницу; когда пользователь нажимает на кнопку, он перенаправляется на страницу с прогнозом погоды и видит ...»; и т. д.).</p><p>Кстати, приведенные выше требрвания - это не шаблон, мы поговорим о лучших способах написания требований в будущих главах этого курса. Я хотел бы подчеркнуть, что создание прототипа определенно является частью бизнес-требований, это подготовка к выявлению требований, такая же как и написание критериев приемки и поиск пропущенных сценариев.</p><p><i>Системные требования</i> — описание взаимодействия компонентов системы в результате действий пользователя. В спецификации системных требований (System Requirements Specification - SRS) такие требования называют требованиями к внешнему интерфейсу и системным функциям. Это в основном описание того, как система должна работать с другими системами или как компоненты одной системы взаимодействуют друг с другом, например,если у вас есть API эндпойнт, работу которого нужно задокументировать, вам нужно определить тело запроса и ответа, для каждого поля в теле запроса и ответа вам нужно определить тип данных, длинну, если это применимо (например для строчного типа данных, для десятичного типа данных), является ли поле обязательным или нет, какие валидации существуют для поля. Если информация хранится в базе данных, необходимо определить сопоставление полей базы данных с полями в запросе. Если информация передается в другую систему или извлекается другой системой, вам нужно определить сопоставление ваших полей с полями сторонего приложения (например, если информация передается между двумя микросервисами). Если информация периодически должна обновляться, как часто это должно происходить? Если возвращается много данных, должен ли эндпойнт поддерживать пагинацию? Должно ли быть ограничение по частоте запросов (rate limit). Если есть несколько вызовов между несколькими системами, используйте нотации UML или BPMN для визуализации последовательности выполненных вызовов и ожидаемых ответов. Если в бизнес-требованиях указано несколько состояний бизнес-объектов, сделайте себе одолжение и создайте диаграмму переходов состояний (state transition diagram), чтобы найти отсутствующие состояния и триггеры, которые приводят к переходу из одного состояния в другое.<p><p>Существует множество других классификаций, которые можно взять из IEEE/ISO, BABOK или книги Карла Вигерса.</p><h3>Выявление требований</h3><p><i>Выявление или cбор требований</i> — это этап в процессе бизнесс-анализа, когда аналитик собирает требования и пытается понять, какие требования вообще существуют, прежде чем записывать их. Существует множество методов:<ul><li>Интервью со стейкхолдерами</li><li>Мозговой штурм со стейкхолдерами</li><li>Интервью с пользователями</li><li>Наблюдение за поведением пользователей</li><li>Создание прототипов</li><li>Обзор и анализ документации и законодательства</li></ul></p><h3>Персоны и роли пользователей</h3><p>Существуют различные группы пользователей, в UX их также называют персонами — чтобы обозначить социальные различия в группах пользователей, обычно в одном приложении выделяются разные роли пользователей — Обычный пользователь, Администратор, Пользователь с подпиской А, Пользователь с подпиской Б. Если мы говорим о персонах — мы говорим о демографическом описании — вот пользователь Тим, ему около 25 лет, у него хорошее здоровье и он зарабатывает меньше денег, Джиму 45–50, он регулярно ходит к врачу и у него больше сбережений, чем у Тима, и т. д.</p><h3>Глоссарий</h3><p>Это буквально то, что вы читаете сейчас, и он должен быть в каждом хорошем проекте — глоссарий общих терминов по проекту, чтобы все говорили на одном языке, это особенно полезно,когда стейкхолдеры используют разные термины для одного и того же бизнес-объекта.</p><h3>User Story (Пользовательская история)</h3><p>Это шаблон для написания требований, в котором обязательно должны присутствовать роль пользователя, требуемая функция и ценность, которую пользователь получит от этой функции. <i>Пример:</i> Как <b><i>администратор приложения</i></b>, я хочу иметь возможность <b><i>добавлять статьи на главную страницу приложения</b></i>, чтобы <b><i>пользователь мог их прочитать</b></i>.</p><h3>Use Case</h3><p>Вариант использования системы — сценарий с пользовательским вводом и последовательностью действий системы, которые происходят из-за этого ввода.    <ol>        <li>Пользователь открывает главную страницу</li>        <li>Пользователь видит большую красную кнопку</li>        <li>Пользователь нажимает большую красную кнопку</li>        <li>Пользователь перенаправляется на такую-то страницу</li>    </ol></p><h3>Приемочное тестирование (Acceptance Testing)</h3><p>Тестирование, проводимое аналитиком перед развертыванием функционала в среде (environment), доступной заказчику или пользователю (PROD, UAT, Stage — существует множество названий для таких сред)</p><h3>Приемочное тестирование пользователем (User Acceptance Testing)</h3><p>Тестирование, проводимое пользователями в специально предназначенной для этого среде. Такая среда как раз может называться UAT или Stage.</p><h3>Release Notes</h3><p>Вместе с релизом в PROD стейкхолдерам отправляют документ, в котором перечислены все изменения, внесенные в релиз.</p><h3>Базовая документация</h3><p>Это статьи на wiki, Confluence, Sharepoint или любом другом инструменте, который может хранить общую информацию о функциональности продукта. Такая документация обязательно должна существовать, если ее нет, задача бизнесс аналитика будет заключаться в том, чтобы ее создать и поддерживать, она должна включать обзор проекта, диаграммы и схемы архитектуры.</p>"
        },
        {
            "id": "2",
            "title": "Глава II: Что такое хорошие требования?",
            "content": "<section><p>Требования — это фундамент любого проекта разработки. От их качества напрямую зависит успех реализации: сроки, бюджет и соответствие конечного продукта ожиданиям заказчика. В эпоху ИИ требования становятся еще важнее - теперь этот текст зачастую воспринимает не разработчик, а большая языковая модель, чем лучше будут тербования, тем лучше будет результат, инженеру останется больше времени для проектирования системы. В этой главе мы разберём, что делает требования «хорошими», опираясь на авторитетные источники: книгу Карла Вигерса «Разработка требований к ПО», стандарты IEEE/ISO, а также методики INVEST и SMART.</p></section><section>    <h2>Определение требования</h2> <p>В стандарте <strong>ISO/IEC/IEEE 29148:2011 4.1.17</strong> требования определяются как утверждение, которое толкует или выражает потребность, а также связанные с ней ограничения и условия (\"statement which translates or expresses a need and its associated constraints and conditions\").</p></section><section> <h2>Критерии хороших требований (по Карлу Вигерсу, глава 5)</h2>    <p>Карл Вигерс в книге «Разработка требований к программному обеспечению» выделяет следующие ключевые характеристики        качественных требований:</p>    <ul>        <li><strong>Единичность</strong> — требование описывает одну и только одну вещь.</li>        <li><strong>Завершённость</strong> — содержит всю необходимую информацию для понимания и реализации.</li>        <li><strong>Последовательность</strong> — не противоречит другим требованиям и документации.</li>        <li><strong>Атомарность</strong> — неделимо на более мелкие требования без потери смысла.</li>        <li><strong>Отслеживаемость</strong> — можно проследить связь с бизнес-целями и другими артефактами проекта.        </li>        <li><strong>Актуальность</strong> — остаётся релевантным на протяжении жизненного цикла проекта.</li>        <li><strong>Выполнимость</strong> — технически реализуемо в рамках заданных ограничений.</li>        <li><strong>Недвусмысленность</strong> — формулировка не допускает разночтений.</li>        <li><strong>Проверяемость</strong> — существует способ проверить выполнение требования.</li>    </ul></section><section>    <h2>Методика INVEST: критерии пользовательских историй</h2>    <p>Для Agile-подходов популярна методика <strong>INVEST</strong>, предложенная Биллом Уэйком. Она задаёт критерии        качества пользовательских историй:</p>    <ul>        <li><strong>I (Independent)</strong> — независимость: история не должна зависеть от других историй.</li>        <li><strong>N (Negotiable)</strong> — обсуждаемость: описание — не контракт, а повод для обсуждения.</li>        <li><strong>V (Valuable)</strong> — ценность: приносит пользу пользователю или бизнесу.</li>        <li><strong>E (Estimable)</strong> — оцениваемость: можно оценить трудозатраты.</li>        <li><strong>S (Small)</strong> — компактность: достаточно мала для реализации в одном спринте.</li>        <li><strong>T (Testable)</strong> — проверяемость: есть критерии приёмки.</li>    </ul></section><section>    <h2>Метод SMART: критерии формулировки требований</h2>    <p>Принцип <strong>SMART</strong> помогает сформулировать требования так, чтобы они были пригодны для реализации:    </p>    <ul>        <li><strong>S (Specific)</strong> — конкретность: чёткое описание, что нужно сделать.</li>        <li><strong>M (Measurable)</strong> — измеримость: есть критерии проверки выполнения.</li>        <li><strong>A (Achievable)</strong> — достижимость: технически реализуемо.</li>        <li><strong>R (Relevant)</strong> — актуальность: соответствует бизнес-целям.</li>        <li><strong>T (Time-bound)</strong> — ограниченность по времени: понятны сроки реализации.</li>    </ul></section><section>    <h2>Как понять, что требования готовы к передаче в разработку</h2>    <p>Перед передачей требований команде разработки проведите чек-лист проверки:</p>    <ol>        <li><strong>Полнота</strong>: все ли сценарии и граничные случаи учтены?</li>        <li><strong>Ясность</strong>: поймёт ли разработчик требование без дополнительных вопросов?</li>        <li><strong>Согласованность</strong>: нет ли противоречий с другими требованиями?</li>        <li><strong>Приоритеты</strong>: определены ли приоритеты (например, можно использовать технику MoSCoW: Must have, Should have, Could            have, Won't have, или просто High, Medium, Low)?</li>        <li><strong>Критерии приёмки</strong>: есть ли чёткие условия, по которым можно проверить выполнение?</li>        <li><strong>Зависимости</strong>: учтены ли внешние системы или компоненты?</li>        <li><strong>Риски</strong>: идентифицированы ли потенциальные проблемы реализации?</li>    </ol></section><section>    <h2>Типичные ошибки в требованиях</h2>    <ul>        <li>Неоднозначные формулировки. <i>Пример: </i> «пользователь должен легко найти…» - здесь не ясно что значит легко, каков критерий легкости?.</li><li>Требования-решения вместо требований-целей. <i>Пример: </i> «В новом поле в базе данных в таблице Orders конкатенируйте поля Id и ShortCode через дефис…» - зачем нужно это поле в базе, может нужно просто отдавать его в ответе API? Или даже просто показывать в пользовательском интерфейсе?</li>        <li>Отсутствие критериев проверки. <i>Пример: </i>«система должна быть быстрой» - про что это требование? Может быть про открытие страницы, насколько быстро в таком случае она должна открываться - 3 минуты, 3 секунды? При каком количестве одновременных пользователей? </li>        <li>Избыточная детализация на раннем этапе.</li>        <li>Несогласованность с бизнес-целями.</li>    </ul></section><section>    <p>Хорошие требования — это баланс между детализацией и гибкостью, точностью и понятностью. Опираясь на стандарты        IEEE/ISO, подходы Вигерса, INVEST и SMART, можно создать основу для успешной разработки:</p>    <ul>        <li>Проверяйте требования по критериям качества.</li>        <li>Вовлекайте команду в обсуждение для устранения неясностей.</li>        <li>Документируйте критерии приёмки.</li>        <li>Поддерживайте актуальность требований в процессе разработки.</li>    </ul>    <p>Только качественно сформулированные требования позволяют минимизировать риски, сократить затраты и создать        продукт, который действительно решает задачи пользователей.</p></section>"
        },
        {
            "id": "3",
            "title": "Глава III: Что делать на новом проекте?",
            "content": "<section><p>Начало работы над новым проектом — критический этап для бизнес‑аналитика. Перед вами — чёткий план действий на старте.</p></section><section><h3>Шаг 1. Анализ стейкхолдеров</h3>    <p>Aнализ стейкхолдеров позволяет:</p>    <ul><li>определить ключевые источники требований;</li>        <li>выстроить коммуникацию;</li>        <li>предвосхитить конфликты интересов;</li>        <li>распределить ответственность.</li>    </ul>    <h4>Как провести анализ</h4>    <ol>        <li><strong>Идентификация.</strong> Составьте список всех возможных стейкхолдеров: заказчики, пользователи, регуляторы, команда, смежные подразделения. Простого списка будет вполне достаточно. С именами и позициями вам может помочь ваше контакое лицо по проекту, лучше всех будет знать SME, но для этого его нужно идентифицировать.</li>        <li><strong>Классификация.</strong> Разделите стейкхолдеров на группы:            <ul>                <li>внутренние / внешние;</li>                <li>первичные (прямое влияние) / вторичные;</li>                <li>поддерживающие / сопротивляющиеся.</li>            </ul>    <p>Для классификации первичных и вторичных стейкхолдеров очень хорошо подойдет Onion-диаграмма</p><img width=\"500px\" height=\"500px\" alt=\"Example of onion diagram\" src=\"onion.png\"><p><i>Пример Onion-диаграммы</i></p>    </li>        <li><strong>Оценка интересов и влияния.</strong> Используйте Power Interest Grid для того, чтобы выбрать стартегию поведения со стейкхолдером: <table border=\"1rem\" cellpadding=\"5\">                <tr><th>Stakeholder</th><th>Power</th><th>Interest</th><th>Strategy</th></tr><tr><th>Buying customer</th><th>High Power</th><th>High interest</th><th>Manage closely</th></tr><tr><th>Platform holder</th><th>Low Power</th><th>Low interest</th><th>Monitor</th></tr><tr><th>Enduser</th><th>High Power</th><th>Low interest</th><th>Keep satisfied</th></tr><tr><th>Development team</th><th>Low Power</th><th>High interest</th><th>Keep informed</th></tr></table><p><img width=\"500px\" height=\"500px\" alt=\"Example of Power Interest Grid\" src=\"powerinterest.png\"></p><p><i>Пример Power Interst Grid</i></p> </li>        <li><strong>Планирование взаимодействия.</strong> Выделите для себя ключевых стейкхолдеров и определите как часто и каким образом вы будете с ними общаться, будет ли это на регулярных общих встречах, 2 раза в неделю на рефайнментах бэклога, или каждую неделю на 1-1, нужно ли приглашать менеджера заказчика на ежедневные встречи, нужно ли отправлять отчеты и если да, то в какой форме их принято отправлять. Все это можно выявить на личных встречах. </section><section>    <h3>Шаг 2. Создание глоссария</h3><p>Глоссарий — словарь терминов проекта. Он устраняет разночтения и ускоряет коммуникацию. Первая глава наглядно иллюстрирует такого рода глоссарий.</p>    <h3>Что включать</h3>    <ul>        <li>отраслевые термины (например, «лид», «конверсия» в маркетинге);</li>        <li>названия систем и модулей;</li>        <li>аббревиатуры и сокращения;</li>        <li>специфические для компании понятия.</li>    </ul>    <h3>Как составлять</h3>    <ol>        <li>Выделите термины из первых интервью и документов.</li>        <li>Согласуйте определения со стейкхолдерами.</li>        <li>Укажите синонимы и примеры использования.</li>        <li>Обновляйте по мере появления новых понятий.</li>    </ol>  </section><section>    <h3>Шаг 3. Базовая документация</h3>    <p>На старте сформируйте минимальный набор документов. Он станет фундаментом для дальнейшей работы.</p><h3>Обязательные документы</h3><ol><li><strong>Устав проекта</strong> <p>Кратко отвечает на вопросы:</p><ul><li>Зачем проект нужен? (цели, бизнес‑ценность)</li><li>Что будет сделано? (границы, результаты)</li><li>Кто участвует? (в принципе, работа по анализу стейкхолдеров закрывает этот пункт)</li><li>Когда? (сроки, этапы, примерный roadmap, если есть, если нет, его нужно выяснить у стейкхолдеров)</li><li>Какие есть ограничения? (бюджет, ресурсы)</li></ul>  <p>Eсли у вас в команде есть архиткетор, или опытный тех лид, возможно SME с техническим бэкграундом, свяжитесь с ним и нарисуйте диаграмму продукта и его взаимосвязи с другими продуктами, например, можно использовать нотацию С4 для описания архитектуры системы.</p>      </li>        <li>            <strong>Список требований (Baseline Requirements)</strong>            <p>Таблица с требованиями. Колонки:</p>            <ul>                <li>ID требования;</li><li>Заголовок;</li><li>Описание</li><li>Критерии приемки</li></ul><p>Таблица с требованиями должна копировать все требования из тикетов в вашей системе управления проектом, которые уже были задеплоены в прод. Вы можете организовать ее в wiki, Conflunce, Sharepoint, Word, Git - репозитории, главное чтобы они были в едином месте, так удобнее понимать текущее состояние проекта, еще лучше было бы отслеживать в этом же документе, как одни требования отменяют или расширяют другие. Конечно, не обязательно копировать требования дословно, можно суммаризировать их и делать более короткими.</p> </li>        <li>            <strong>Протокол встреч (Meeting Minutes)</strong>            <p>После каждой встречи всегда фиксируйте:</p>            <ul>                <li>дату и участников;</li>                <li>ключевые решения;</li>                <li>действия и ответственных;</li>                <li>открытые вопросы.</li>            </ul><p>Теперь ИИ ассистенты могу делать большую часть такой работы за вас, так что не теряйте шанс использовать их.</p></li>        <li>            <strong>Риски и проблемы (Risk Log)</strong>            <p>Таблица с колонками:</p>            <ul>                <li>Описание риска;</li>                <li>Вероятность наступления - выскоая, средняя, низкая;</li>                <li>Степень влияния на проект - высокая, средняя,низкая;</li>                <li>Меры - описание мероприятий для предотвращения или снижения риска;</li>                <li>Ответственный;</li>            </ul>        </li>    </ol>    <div >        <strong>Совет:</strong> Не стремитесь к идеальности на старте. Документы должны быть «живыми» — обновляйте их по мере поступления информации, показывайте их другим участникам команды для обсуждения.    </div></section><section>    <h2>Чек-лист первых 2 недель</h2>    <p>Чтобы не упустить важное, следуйте плану:</p>    <ol>        <li>Проведите вводные встречи с ключевыми стейкхолдерами.</li>        <li>Составьте первичный список стейкхолдеров и матрицу влияния.</li>        <li>Начните заполнять глоссарий на основе первых обсуждений.</li>        <li>Оформите устав проекта (даже в черновике).</li>        <li>Заведите список требований — внесите первые 5–10 пунктов.</li>        <li>Фиксируйте все встречи и решения в протоколах.</li>        <li>Идентифицируйте ключевые риски.</li>    </ol></section>"
        },
        {
            "id": "4",
            "title": "Глава IV: Выявление требований",
            "content": "<p>Выявление требований - это прежде всего набор техник и приемов для получения требований, часто аналитик противопостоавляют этот термин термину сбор, так как требования не растут из земли и их иногда приходится добывать с трудом. В этой главе мы подробнее остановимся на четырех основных методах выявления требований и дадим практические рекомендации по их применению.</p><section><h3>1. Интервью</h3>    <div>        <p><strong>Суть:</strong> персональное общение с заинтересованными сторонами для получения информации о            потребностях, проблемах и ожиданиях.</p>        <p><strong>Когда применять:</strong> при работе с ключевыми стейкхолдерами. Это самый простой и в то же время самый надежный способ, который можно применить почти всегда. </p>    </div>    <h3>Как проводить эффективно</h3>    <ol>        <li>Подготовьтесь: изучите контекст, составьте список вопросов.</li><li>Начните с открытых вопросов («Расскажите, как вы сейчас решаете эту задачу?»).</li>        <li>Используйте уточняющие вопросы («Почему это важно?», «Что произойдёт, если…»).</li>   <li>Лучше иметь предмет разговора перед глазами, если есть готовое приложение, сайт, прототип, референс конкурента, документ или график, обязательно покажите его на своем экране или попросите стейкхолдера показать свой экран с примером.</li>     <li>Фиксируйте не только ответы, но и вашу оценку ответов, вам может показаться, что человек не уверeн в своем суждении, тогда этот момент стоит верифицировать с другими стейкхолдерами.</li>   <li>Обязательно спрашивайте о приоритетах и сроках - это не обязательно расплывчатые High, Medium, Low, приоритеты это скорее даты, которые ваши стейкхолдеры уже пообщеали своим стейкхолдерам, например, их новый клиент начнет работу с приложением в мае этого года, так что, если сейчас апрель все остальные фичи будут менее приоритетными</li>     <li>В конце резюмируйте ключевые тезисы, после встречи составьте протокол и разошлите его участникам, обязательно проговорите нужна ли последующая встреча.</li>    </ol>    <div>        <strong>Совет:</strong> избегайте наводящих вопросов. Вместо «Вам ведь нужен экспорт в Excel?» спросите: «В        каких форматах вам приходится обмениваться данными?»    </div></section><section>    <h3>2. Воркшопы</h3>  <div><p><strong>Суть:</strong> групповые сессии с участием нескольких стейкхолдеров для совместного выявления и обсуждения требований.</p><p><strong>Когда применять:</strong> при сложных проектах, необходимости согласования позиций, генерации идей.</p>    </div>    <h4>Преимущества</h4>    <ul>        <li>Экономия времени (одновременный сбор мнений от нескольких участников).</li>        <li>Возможность сразу разрешить противоречия.</li>        <li>Генерация новых идей благодаря участию стейкхолдеров из разных потоков бизнеса.</li>    </ul>  <p>По большом счету это просто массовое интервью, но так как участников много, нужна четкая агенда перед глазами.</p>   <div>        <strong>Совет:</strong> подготовьте виртуальную доску и отмечайте прогресс агенды на ней.</div></section><section>    <h3>3. Прототипы</h3>    <div> <p><strong>Суть:</strong> создание упрощённых моделей продукта (интерфейсов, процессов) для визуализации идей и получения обратной связи. Кроме того, когда вы создаете прототип и начинает продумывать состояния и переходы между ними, можно найти недостоющие и непродуманные состояния и выявить требования таким образом</p>        <p><strong>Когда применять:</strong> для уточнения требований к интерфейсам, проверки гипотез, демонстрации концепций.</p>    </div>    <h4>Виды прототипов</h4>    <ul>        <li><strong>Бумажные</strong> — быстрые наброски от руки.</li>        <li><strong>Интерактивные</strong> — кликабельные макеты (например, в Figma).</li>        <li><strong>Функциональные</strong> — рабочие версии с базовым функционалом.</li>    </ul>    <h3>Как использовать</h3>    <ol>        <li>Создайте прототип на основе первичных требований.</li>        <li>Проведите демонстрацию стейкхолдерам.</li>        <li>Соберите обратную связь: что непонятно, что нужно изменить.</li>        <li>Итерируйте: улучшайте прототип до согласования.</li>    </ol>    <div>        <strong>Совет:</strong> не вкладывайте слишком много времени в детализацию раннего прототипа — его цель: быстро        получить обратную связь.    </div><p><a href=\"https://www.youtube.com/watch?v=kbZejnPXyLM&pp=ygUMZmlnbWEgY291cnNl\" target=\"blank\">Ссылка на курс по Figma</a></p><p>Конечно, никто не запрещает делать прототип в Cursor App в эпоху ИИ.</p></section><section>    <h3>4. Анализ документации</h3>    <div>        <p><strong>Суть:</strong> изучение существующих документов для выявления требований и контекста.</p>        <p><strong>Когда применять:</strong> в начале проекта, при модернизации систем, для понимания текущих процессов.        </p>    </div>    <h3>Какие документы анализировать</h3>    <ul>        <li>Бизнес‑планы и стратегии.</li>        <li>Описания текущих процессов (BPMN, текстовые регламенты).</li>        <li>Техническая документация систем.</li>        <li>Отчёты и аналитика (KPI, метрики).</li>        <li>Предыдущие требования и ТЗ.</li>        <li>Пользовательское руководство и FAQ.</li>    </ul>    <h3>Алгоритм анализа</h3>    <ol>        <li>Составьте список источников.</li>        <li>Выделите ключевые термины и процессы.</li>        <li>Найдите противоречия и пробелы.</li>        <li>Сформулируйте вопросы для уточнения.</li>        <li>Зафиксируйте выявленные требования.</li>    </ol>    <div>        <strong>Совет:</strong> создайте глоссарий на основе терминологии из документов — это снизит риск разночтений.    </div></section>    <h3>Частые ошибки и как их избежать</h3>    <ul>        <li>            <strong>Запись пожеланий, а не потребностей:</strong>            <p>Стейкхолдеры часто формулируют решения («хочу кнопку красного цвета»), а не проблему. </p>            <p><em>Как избежать:</em> задавайте уточняющие вопросы: «Зачем это нужно?», «Какую задачу это решает?», «Что                будет, если этого не сделать?»</p>        </li>        <li>            <strong>Отсутствие валидации:</strong>            <p>Требования зафиксированы, но не проверены на реалистичность и согласованность.</p>            <p><em>Как избежать:</em> после сбора требований проведите ревью со стейкхолдерами, смоделируйте сценарии                использования.</p>        </li>        <li>            <strong>Игнорирование нефункциональных требований:</strong>            <p>Фокус только на функционале, без учёта производительности, безопасности, удобства использования.</p>            <p><em>Как избежать:</em> Составьте список вопросов по нефункциональным требованиям (Сколько запросов может случиться за день/час/минуту? Какое максимальное колличество строк в запросе? Ожидает ли партнерская система синхронный или асинхронный ответ? Должна ли быть логика повтороной отправки? Сколько раз пробовать переотправлять упавший запрос? Как быстро должна загружаться страница? и так далее).</p>        </li>        <li>            <strong>Слишком общие формулировки:</strong>            <p>«Система должна работать быстро», «Интерфейс должен быть удобным» — невозможно проверить.</p>            <p><em>Как избежать:</em> конкретизируйте: «Время отклика системы — не более 2 сек при нагрузке до 1000                пользователей».</p>        </li>        <li>            <strong>Недооценка влияния изменений:</strong>            <p>Новые требования не анализируются на совместимость с существующими процессами и системами.</p>            <p><em>Как избежать:</em> создайте диаграмму процесса учитывая нижестоящие системы (например используя BPMN, или UML диаграмму последовательности).</p>        </li>        <li>            <strong>Отсутствие приоритизации:</strong>            <p>Все требования считаются одинаково важными, что ведёт к перегрузке разработки.</p>            <p><em>Как избежать:</em> спрашивайте о сроках поставки, если же вышло так что все фичи стали срочными и приоритетными, а команда разработки перегружена, нужно приоретизировать уже применяя специализированные техники -  (например, MoSCoW, Cost Of Delay).</p>        </li>        <li>            <strong>Недокументирование источников:</strong>            <p>Неясно, кто и почему выдвинул требование, что затрудняет дальнейшие уточнения.</p>            <p><em>Как избежать:</em> фиксируйте в списке требований: стейкхолдера, дату, контекст.</p>        </li>        <li>            <strong>Пропуск граничных случаев:</strong>            <p>Учитываются только «идеальные» сценарии, игнорируются ошибки, исключительные ситуации.</p>            <p><em>Как избежать:</em> моделируйте негативные сценарии («Что, если пользователь введёт некорректные                данные?»).</p>        </li>        <li>            <strong>Чрезмерная детализация на раннем этапе:</strong>            <p>Попытка описать все нюансы до утверждения концепции ведёт к потере времени.</p>            <p><em>Как избежать:</em> сначала зафиксируйте высокоуровневые требования, затем углубляйтесь в детали.</p>        </li>        <li>            <strong>Отсутствие обратной связи:</strong>            <p>Требования переданы команде без планирования.</p>            <p><em>Как избежать:</em> команда разработки должна планировать истории вместе с вами, помните, что вы не можете знать всего, их вклад в требования очень ценен. Если вы не хотите отрывать всю команду можно попросить провести предварительный разговор с тех лидом и одним из наиболее опытных тестировщиков.</p>        </li>    </ul></section><section>    <h2>Заключение</h2>    <p>Выявление требований — это не разовое действие, а итеративный процесс. Чтобы минимизировать ошибки:</p>    <ol>        <li>Комбинируйте методы (интервью + прототипы + анализ документов).</li>        <li>Фиксируйте всё письменно.</li>        <li>Регулярно валидируйте требования со стейкхолдерами.</li>        <li>Будьте гибкими: допускайте корректировку по мере поступления новой информации.</li>        <li>Используйте шаблоны и чек‑листы для систематизации работы.</li>    </ol>  </section>"
        },
        {
            "id": "5",
            "title": "Глава V: Приоретизация требований",
            "content": "<section><h3>Зачем нужна приоритизация требований?</h3><p>В любом проекте ресурсы ограничены: время, бюджет, команда. Приоритизация помогает определить, какие задачи принесут наибольшую пользу и должны быть реализованы в первую очередь. Конечно, классическим способом приоретизации является установление сроков, если какая-то задача должна быть выпущена к определенному сроку приоретизировать ее гораздо проще. Баги из прода с большим потенциальным или реальным воздействием всегда приоритетнее новых задач. Методы приоретизации, предложенные ниже, скорее подойдут для разработки MVP, когда приоритеты конкурируют друг с другом и скоуп нужно сокращать. </p></section><section><h3>Метод MosCoW</h3><p>MosCoW — это метод категоризации требований на четыре группы:</p><ul><li><strong>MUST have</strong> — обязательные требования, без которых проект не будет успешным</li><li><strong>SHOULD have</strong> — важные требования, но не критичные</li><li><strong>COULD have</strong> — желательные требования, которые можно отложить</li><li><strong>WON'T have</strong> — требования, которые не будут реализованы в текущей версии</li></ul><h4>Когда использовать?</h4><p>Идеально подходит для проектов с фиксированными сроками и бюджетом, где нужно четко определить минимальныйжизнеспособный продукт (MVP).</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> простота, понятность, быстрое внедрение</p><p><strong>Минусы:</strong> субъективность, отсутствие количественных метрик</p></section><section><h3>Cost of Delay (Цена простоя)</h3><p>Cost of Delay оценивает финансовые потери от задержки реализации фичи.</p><p>Cost of Delay можно посчитать как доход от фичи за едницу времени умноженный на колличество единиц времени, необходимых на имплементацию. <i>Например: </i> у вас есть баг, который ломает отправку заказов, в день на заказах компания зарабатывает $10 000. Команда разработки говорит, что сможет пофиксить баг за 2 дня, <b>Cost of Delay = $10 000 x 2 = $20 000</b>.</p><p>Есть также другая метрика на основе Cost of Delay - CD3. CD3 считается как доход от фичи в еденицу времени деленный на колличество едниц времени, необходимых на имплементацию. CD3 позволяет определить, какой из багов приоритетнее. <i>Пример: </i> Есть баг в проде , который ломает отправку заказов, в день на заказах компания зарабатывает $10 000. Команда разработки говорит, что сможет пофиксить баг за 2 дня. Назовем его Баг А. Есть Баг Б, который не позволяет показывать рекламу на сайте, в день сайт теряет $4 000 из-за этого. Команда разработки говорит, что может пофиксить этот баг за четверь дня (2 часа). <b>Cost of delay Бага А = $20000</b>. <b>Cost of delay Бага Б = $1000</b>. <b>СD3 Бага А = $10 000/ 2 = 5 000.</b> <b>СD3 Бага Б = $4 000 / 0.25 = 16 000</b>. Получается, что если выбирать по этому показателю, первым нужно фиксить Баг Б, его фикс быстрее вернет выручку.</p><h4>Когда использовать?</h4><p>Особенно полезен в коммерческих проектах, где важны финансовые показатели и ROI, и, что самое главное, там, где эти данные есть.</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> объективные численные данные, фокус на бизнес-ценности.</p><p><strong>Минусы:</strong> сложность расчетов, требует точных данных.</p></section><section><h3>Метод RICE</h3><p>RICE — система оценки, учитывающая четыре фактора:</p><ul><li><strong>Reach (Охват)</strong> — сколько пользователей затронет функция</li><li><strong>Impact (Влияние)</strong> — насколько сильно функция повлияет на каждого пользователя</li><li><strong>Confidence (Уверенность)</strong> — насколько точны наши оценки</li><li><strong>Effort (Усилия)</strong> — сколько времени/ресурсов потребуется</li></ul><p>Формула: <em>RICE Score = (Reach × Impact × Confidence) / Effort</em></p><h4>Когда использовать?</h4><p>Для продуктов с большим количеством пользователей, где важны метрики вовлеченности.</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> комплексный подход, учитывает несколько факторов</p><p><strong>Минусы:</strong> требует сбора данных, может быть переусложнен</p></section><section><h3>Story Mapping</h3><p>Визуальный метод организации пользовательских историй вдоль оси пользовательского пути.</p><img width=\"1000px\" height=\"500px\" src=\"storymap.png\"><p><i>Пример Story Map в Figma</i></p></section><section><h2>Как выбрать подходящий метод?</h2><table border='1' cellpadding='8' cellspacing='0'><tr><th>Метод</th><th>Лучше всего подходит для</th><th>Сложность внедрения</th></tr><tr><td>MosCoW</td><td>Проектов с фиксированными сроками, MVP</td><td>Низкая</td></tr><tr><td>Cost of Delay</td><td>Коммерческих проектов, где важен ROI</td><td>Высокая</td></tr><tr><td>RICE</td><td>Продуктов с метриками пользователей</td><td>Средняя</td></tr></table></section><section><h2>Практические советы по приоритизации</h2><ol><li>Начинайте с простых методов и переходите к сложным по мере необходимости</li><li>Вовлекайте ключевых стейкхолдеров в процесс приоритизации</li><li>Регулярно пересматривайте приоритеты — они могут меняться</li><li>Не забывайте о техническом долге и нефункциональных требованиях</li></ol></section><section><p>Не существует универсального 'лучшего' метода приоритизации. Выбор зависит от контекста проекта и доступных данных. Ключ к успеху — системный подход и регулярный пересмотр приоритетов по мере поступленияновой информации. Экспементируйте с разными методами, адаптируйте их под свои нужды.</p></section>"
        },
        {
            "id": "6",
            "title": "Глава VI: Документация требований",
            "content": "<section>    <h3>1. User Stories (пользовательские истории)</h3>    <p>Краткие описания функциональности с точки зрения пользователя. Основной формат в Agile‑разработке.</p>    <h4>Структура</h4>    <p>«Как <em>[роль пользователя]</em>, я хочу <em>[функционал]</em>, чтобы <em>[получать выгоду]</em>». («As a <em>[role]</em>, I want to <em>[feature]</em>, so that <em>[value]</em>. »)</p>    <p><strong>Пример:</strong> «Как покупатель, я хочу фильтровать товары по цене, чтобы быстрее находить подходящие        варианты».</p>    <h4>Когда применять</h4>    <ul>        <li>В итеративной разработке (Scrum, Kanban).</li>        <li>При необходимости быстрой приоритизации требований.</li>        <li>Для коммуникации с нетехническими стейкхолдерами.</li>    </ul>    <h4>Плюсы и минусы</h4>    <p><strong>Плюсы:</strong> простота, фокус на ценности для пользователя, гибкость.</p>    <p><strong>Минусы:</strong> недостаточная детализация для сложных сценариев, риск неоднозначности.</p></section><section> <h4>Основные ошибки</h4><ul><li>Невалидная роль - я часто вижу как аналитики пишут «Как менеджер продукта, я хочу». Менеджер продукта это не роль в приложении, роль в приложении, это какой-то пользователь. Даже если кажется, что пользователя нет, а потребителем является сторонняя система, в сторонней системе есть это пользователь, который чего-то от системы ожидает. Так же стоит сказать, что в истории можно перечиcлить нескольких пользователей.</li><li>Отсутствие ценности - аналитики часто пропускают часть с описанием ценности, чем абсолютно дискредитируют концепт. Прописываение ценности - это тоже элемент анализа - он заставляет вас задуматься еще раз, этой ли фичи хочет пользователь. Ценность также придает работе программистов какой-то смысл, а так же позволяет предложить альтернативные решения. Давайте сравним историю с ценностью и без ценносьти. «Как администратор каталога, я хочу иметь возможность изменять доступное колличество товаров на складе». У меня сразу возникают вопросы - зачем давать такую возможность, нету интеграции со складской системой? Откуда администратору знать сколько продуктов на складе? Тепрь давайте добавим ценность. «Как администратор каталога, я хочу иметь возможность изменять доступное колличество товаров на складе, чтобы исправлять ошибки интеграции со складом». А, тут все понятно, то есть интеграция со складом есть, но, видимо, есть ошибки, просчеты или периодические даунтаймы на стороне складской системы, поэтому нужно иметь возможность поправить колличество вручную. </li></ul> <p>Я хочу отметить, что одной только истории будет недостаточно для того, чтобы передать требования в разработку. Обычно я включаю так же тезисное описание функциональных требований и критерии приемки в формате пошаговых тестовых сценариев.</p> <p><i>Пример моих требований:</i></p><p>Как <b><i>пользователь каталога</i></b>, я хочу <b><i>получать сообщения о поступлении товара на склад</i></b>, чтобы я мог <b><i>начать заказывать товар со склада</i></b>.</p> <p><b><i>Требования:</i></b></p> <p><ol><li>Для получения информации о поступлении товара каталог будет используется существующий API `GET api/receipt`, необходимо расширить ответ этого API, чтобы каталог мог сохранить информацию о приеме товара к себе.</li><li>Недостающие поля: <ul><li>expectedQuantity - источник в базе `DatabaseName.PurchaseOrder.Quantity`</li><li>productName - источник в базе `DatabaseName.Item.ProductName`</li><li>purchaseOrderNumber - источник в базе `DatabaseName.PurchaseOrder.OrderNumber`</li></ul></li><li>Пример ответа на запрос c новыми полями: <pre><code>{<br>\"recordsFound\":10,<br>\"recordsOnPage\":10,<br>\"pageNumber\":0,<br>\"totalPages\":1,<br>\"receipts\":<br>[<div style=\"margin-left: 50px;\">{<br>\"id\":1,<br>\"receivedQuantity\":10,<br>\"expectedQuantity\":10,<br>\"productName\":\"T-Shirt\",<br>\"purchaseOrderNumber\":\"PO123456\",<br>\"purchaseOrderLine\":1<br>}</div>]}</code></pre></li></ol><p></p></p><p><b><i>Критерии приемки</i></b><ol><li>Ответ на запрос новых поступлений товара содержит новые поля<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = 'T-Shirt', на 10 штук, номер заказа 'PO123456', строка заказа номер 1 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123456', номер строки 1, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = 'T-Shirt', для заказа 'PO123456', строки 1, с expectedQuantity = 10, receivedQuantity=10</p></li><li>Поступление на товар без названия<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = null, на 12 штук, номер заказа 'PO123457', строка заказа номер 2 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123457', номер строки 2, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = null, для заказа 'PO123457', строки 2, с expectedQuantity = 12, receivedQuantity=10</p></li></ol></p><p>Я бы хотел отметить что эти требования пример того, как работает аналитик внутри гибких методолгий, эндпойнт уже есть, он описан в предыдущих требованиях, есть валидации для эндпойнта `POST api/receipt`, все это не касается этого тербования, здесь мы расширяем существующий ответ запроса, так как к нам пришел новый клиент, и ему нужны новые поля, чтобы интегрироваться с нами. Ну и конечно, в требованиях могут быть ошибки и неточности, пропущенные сценарии, но у аналитика есть мощный инструмент для работы с ними - планирование с командой разработки.</p>  <h2>2. Use Case (сценарии использования)</h2>    <p>Высокоуровневое описание взаимодействия пользователя с системой. Включает предусловия, шаги и        постусловия.</p><p><i>Пример</i></p> <p><strong>ID:</strong> UC-001</p><table>    <tbody>        <!-- Строка: Название -->        <tr>            <th width=\"20%\">Поле</th>            <td width=\"80%\">Оформление заказа в интернет-магазине</td>        </tr>        <!-- Строка: Акторы -->        <tr>            <th>Акторы</th>            <td>                <ul>                    <li>Пользователь (покупатель)</li>                    <li>Система (интернет-магазин)</li>                </ul>            </td>        </tr>        <!-- Строка: Предусловия -->        <tr>            <th>Предусловия</th>            <td>                <ol>                    <li>Пользователь зарегистрирован в системе.</li>                    <li>Пользователь авторизован.</li>                    <li>В корзине есть хотя бы один товар.</li>                </ol>            </td>        </tr>        <!-- Строка: Основной сценарий -->        <tr>            <th>Основной сценарий</th>            <td>                <ol>                    <li>Пользователь переходит в корзину.</li>                    <li>Система отображает список товаров в корзине.</li>                    <li>Пользователь нажимает кнопку «Оформить заказ».</li>                    <li>Система открывает форму заполнения данных для доставки.</li>                    <li>Пользователь заполняет необходимые поля (адрес, способ оплаты).</li>                    <li>Пользователь подтверждает заказ.</li>                    <li>Система формирует заказ и отправляет уведомление на email.</li>                    <li>Система отображает номер заказа и итоговую сумму.</li>                </ol>            </td>        </tr>        <!-- Строка: Альтернативные сценарии -->        <tr>            <th>Альтернативные сценарии</th>            <td>                <div>                    <strong>А1. Пользователь отменяет заказ:</strong>                    <ol>                        <li>На любом шаге пользователь нажимает «Отменить».</li>                        <li>Система возвращает пользователя на главную страницу.</li>                    </ol>                </div>                <div>                    <strong>А2. Ошибка при заполнении данных:</strong>                    <ol>                        <li>Пользователь вводит некорректные данные (например, неверный email).</li>                        <li>Система выделяет ошибочные поля и выводит подсказки.</li>                        <li>Пользователь исправляет данные и повторяет отправку.</li>                    </ol>                </div>            </td>        </tr>        <!-- Строка: Постусловия -->        <tr>            <th>Постусловия</th>            <td>                <ul>                    <li>Заказ создан в системе.</li>                    <li>Пользователь получил уведомление о заказе.</li>                    <li>Товары из корзины удалены (если заказ успешно оформлен).</li>                </ul>            </td>        </tr>        <!-- Строка: Примечания -->        <tr>            <th>Примечания</th>            <td>                <ul>                    <li>Срок хранения корзины — 30 дней.</li>                    <li>При отсутствии товаров в наличии система предупреждает пользователя до оформления заказа.</li>                </ul>            </td>        </tr>    </tbody></table><h3>Когда применять</h3>    <ul>        <li>Для вотерфольных проектов, где бизнес привык видеть описание сценариев.</li><li>В начале проекта, когда нужно зафиксировать базовое поведение системы и согласовать его со стейкхолдерами.</li><li>В проектах с жёсткими требованиями к спецификации.</li>    </ul><p>У этого подхода есть визуальный формат - Use Case Diagram.</p><img src=\"usecase.png\"><p><i>Пример Use Case Diagram</i></p><p>Эти диаграммы относятся к нотации UML, о которой мы еще поговорим в ниже в этой же главе. Акторы здесь обозначены как люди, они находятся вне прямоугольника, который обозначате нашу систему. Этот прямоугольник называют границами системы. Акторы могут быть как реальными пользователями, так и внешними системами. Сами по себе варианты использования (Use Case) обозначены овалами внутри системы. Так же между акторами и вариантами использования обозначены связи нескольких типов. Ассоциация (Association) обозначается сплошной линией и служит для обозначения связи между актором и вариантом. Актор должен быть связан хотя бы с одним вариантом использования, при этом один актор может быть связан с несколькими вариантами, а один вариант использования - с несколькими акторами. Обобщение (Generalization) — отношение, при котором один актор или вариант использования наследует характеристики другого. Обозначается сплошной линией с незакрашенным треугольником на конце. Например, акторы «Клиент» и «Администратор» могут быть представлены более общим актором «Пользователь». Включение (Include) — обязательное отношение, при котором один вариант использования включает функциональность другого. Это означает, что базовый вариант использования неполноценен без включённого. Обозначается пунктирной линией со стрелкой и подписью «include». Например, вариант использования «Оформить заказ» может включать «Оплатить товар». Расширение (Extend) — необязательное отношение, при котором один вариант использования расширяет другой при определённых условиях. Обозначается пунктирной линией со стрелкой и подписью «extend». Например, вариант использования «Оформить заказ» может расширяться на «Применить промокод» при выполнении определённых условий. </p></section><section><h2>3. UML (Unified Modeling Language)</h2>    <p>Стандартный язык графического описания для моделирования систем. Включает десятки диаграмм.</p>    <h4>Ключевые диаграммы для требований</h4>    <ul>        <li><strong>Диаграмма классов</strong> — структура данных и связи между объектами.</li>        <li><strong>Диаграмма последовательностей</strong> — взаимодействие компонентов во времени.</li>        <li><strong>Диаграмма состояний</strong> — возможные состояния объекта и переходы между ними.</li>        <li><strong>Диаграмма активности</strong> — поток работ или процессов.</li>    </ul>    <h4>Когда применять</h4>    <ul>        <li>Для визуализации архитектуры системы.</li>        <li>При описании сложных алгоритмов.</li>        <li>Для коммуникации с разработчиками и архитекторами.</li>    </ul>    <p>Самой главной диаграммой я считаю <b>диаграмму последовательности</b>, так как она позволяет визуализировать общение между системами без лишних визуальных артефактов, как это происходит с BPMN.</p><p><b>Основные элементы UML sequence diagram</b></p><ul><li>Объекты (акторы) — сущности, которые взаимодействуют друг с другом. Это могут быть пользователи, системы, микросервисы, классы и т. д. Каждый объект представлен прямоугольником с именем в верхней части.</li><li>Линии жизни (lifelines) — вертикальные пунктирные линии, которые показывают существование объекта во времени. Они тянутся вниз от объекта и обозначают период его активности в процессе взаимодействия.</li><li>Сообщения (messages) — обмен информацией между объектами. Отображаются в виде стрелок, направленных от одной линии жизни к другой. Стрелки могут быть разных типов в зависимости от типа сообщения.</li><li>Активационные блоки (activation boxes) — прямоугольники на линии жизни, которые показывают период активности объекта при обработке сообщения. Начинаются в момент получения сообщения и заканчиваются после завершения обработки.</li><li>Примечания (notes) — дополнительные пояснения к диаграмме. Размещаются рядом с соответствующими элементами.</li></ul><p>Хочу посоветовать вам стараться создавать все диаграммы с помощью текстовых движков для создания диаграм вместо обычных визуальных редакторов, таких как Draw.io и Lucidchart. Попробуйте использовать Mermaid в VS code. Он поддерживается в Confluence, Azure DevOps, в простом маркдауне , и так же будет корректно отображаться в гитхабе. Причина этого совета в том, что текст для LLM воспринимается куда легче чем картинка, таким образом вы дадите нейросети больше контекста для помощи в составлении требований.</p><p><i>Пример sequence diagram в Mermaid: </i></p><pre><code><div>sequenceDiagram</div> <div style=\"margin-left:30px\">participant User <br>participant System <br>User->>System: Login request <br>activate System <br>System-->>User: Login success <br>deactivate System</div></code></pre><img width=\"400px\" length=\"400px\"  src=\"sequence.png\"><p><i>Пример визуализации sequence diagram сгенерированной в Mermaid</i></p><table><thead><tr><th>Тип сообщения</th><th>Описание</th><th>Пример в Mermaid</th></tr></thead><tbody><tr><td>Обычное сообщение</td><td>Стрелка с треугольником на конце, показывает вызов метода или передачу данных</td><td><code>A-&gt;&gt;B: Hello</code></td></tr><tr><td>Ответное сообщение</td><td>Пунктирная стрелка, показывает возврат значения</td><td><code>B--&gt;&gt;A: OK</code></td></tr><tr><td>Самосообщение (self&nbsp;message)</td><td>Стрелка в форме буквы&nbsp;U, объект отправляет сообщение самому себе</td><td><code>A-)A: Process data</code></td></tr><tr><td>Создание объекта</td><td>Сообщение с пометкой <code>create</code>, создаёт новый объект</td><td><code>A-&gt;&gt;create B: New object</code></td></tr><tr><td>Удаление объекта</td><td>Стрелка с крестиком на конце, уничтожает объект</td><td><code>A-&gt;-x B: Delete</code></td></tr></tbody></table></section><section><h2>4. BPMN (Business Process Model and Notation)</h2>    <p>Нотация для моделирования бизнес‑процессов. Показывает последовательность действий, роли и потоки данных.</p>    <h3>Основные элементы</h3>    <ul>        <li><strong>События</strong> (старт, завершение, промежуточные).</li>        <li><strong>Действия</strong> (задачи, подпроцессы).</li>        <li><strong>Шлюзы</strong> (условия ветвления).</li>        <li><strong>Потоки</strong> (последовательность, данные).</li>        <li><strong>Пулы и дорожки</strong> (роли/подразделения).</li>    </ul>    <h3>Когда применять</h3>    <ul>        <li>Для анализа и оптимизации бизнес‑процессов.</li>        <li>При автоматизации рабочих процедур.</li>        <li>Для согласования процессов между подразделениями.</li>    </ul>    <p>Я предлагаю использовать для моделирования приложение Camunda.</p><a href=\"https://camunda.com/download/modeler/\"><b><i>Ccылка на скачивание</i></b><p></a><img width=\"1000px\" height=\"400px\" src=\"bpmn.png\"></p><p><i>Пример бизнес процесса созданного с помощью Camunda</i></p>В этой нотации довольно много правил, есть много специализированных видео о том, как правильно создавать процессы в этой нотации, например <a href=\"https://www.youtube.com/watch?v=Eutdbh03W5k\" target=\"blank\"><i>The Only BPMN Tutorial You Will Ever Need To Watch</i></a>. К тому же есть отличная шпрагалска которой я всегда пользуюсь - <a href=\"https://bpm-conference.org/assets/docs/bpmn-poster/BPMN2_0_Poster_EN.pdf\" target=\"blank\"><i>BPMN Poster</i></a>.</section><section>    <h2>5. ERD (Entity-Relationship Diagram)</h2>    <p>Диаграмма «сущность‑связь» для моделирования структуры данных. Основа для проектирования баз данных.</p>    <h3>Ключевые компоненты</h3>    <ul>        <li><strong>Сущности</strong> (объекты предметной области, например «Клиент», «Заказ»).</li>        <li><strong>Атрибуты</strong> (свойства сущностей: «ID клиента», «Дата заказа»).</li>        <li><strong>Связи</strong> (отношения между сущностями: «Клиент делает Заказ»).</li>  <li><strong>Ключи</strong> (PK (Primary Key) уникальный идентификатор записи, FK (Foreign Key) обычно ссылка на PK другой сущности).</li>  </ul> <p><i>Пример в Mermaid</i></p><pre><div>erDiagram</div><div style=\"margin-left:30px\">CUSTOMER ||--o{ ORDER : \"размещает\"<br>ORDER ||--|{ LINE_ITEM : \"содержит\"<br>PRODUCT ||--o{ LINE_ITEM : \"используется в\"<br>CUSTOMER }|..|{ DELIVERY_ADDRESS : \"имеет\"<br><p>%% Описание сущностей и их атрибутов</p><br>CUSTOMER {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>STRING name<br>STRING email<br>DATE created_at</div>}<br>ORDER  {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER customer_id FK<br>DATE order_date<br>STRING status</div>}<br>LINE_ITEM  {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER order_id FK<br>INTEGER product_id FK<br>INTEGER quantity<br>DECIMAL unit_price</div>}<br>PRODUCT {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>STRING title<br>DECIMAL price<br>BOOLEAN is_available</div>}<br>DELIVERY_ADDRESS {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER customer_id FK<br>STRING address<br>STRING city<br> STRING postal_code</div>}</div></pre> <div><p>Как читать обозначения связей в Mermaid</p><ul><li>||--o{ — «один ко многим» (1:N), левая сторона обязательна, правая — нет;</li><li>||--|{ — «один ко многим» (1:N), обе стороны обязательны;</li><li>}|..|{ — «один ко многим» (1:N), обе стороны необязательны;</li><li>||--|| — «один к одному» (1:1);</li><li>o{--o{ — «многие ко многим» (M:N).</li></ul></div><img width=\"800px\" height=\"1000px\" src=\"erd.png\"><p><i>Пример ERD сгенерированного в Mermaid</i></p>   <h3>Когда применять</h3>    <ul>        <li>На этапе проектирования базы данных.</li>        <li>Для уточнения требований к хранению данных.</li></li></ul></section>"
        },
        {
            "id": "7",
            "title": "title7",
            "content": "<p>content7</p>"
        },
        {
            "id": "8",
            "title": "title8",
            "content": "<p>content8</p>"
        },
        {
            "id": "9",
            "title": "title9",
            "content": "<p>content9</p>"
        },
        {
            "id": "10",
            "title": "title10",
            "content": "<p>content10</p>"
        },
        {
            "id": "11",
            "title": "title11",
            "content": "<p>content11</p>"
        },
        {
            "id": "12",
            "title": "title12",
            "content": "<p>content12</p>"
        }
    ]
}