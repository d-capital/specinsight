{
    "articles": [
        {
            "id": "1",
            "title": "Глава I: Базовые концепции",
            "content": "<p>Чтобы начать изучение бизнесс-анализа, нам нужно сначала договориться о некоторых общих терминах, чтобы мы могли понимать друг друга.</p><h3>Стейкхолдеры</h3><p><b>Стейкхолдеры</b> — это любые люди или организации, которые могут оказать влияние на ваш продукт или проект или могут подвергнуться влиянию вашего продукта или проекта. Прежде всего, давайте их классифицируем.</p><p><i>Платящий стейкхолдер</i> — представитель компании, которая платит за ваш проект, например, владелец продукта или менеджер продукта (Product Owner, Product Manager), возможно менеджер проекта (Project Manager), который отвечает за бюджет и принимает решение о продолжении финансирования, он заинтересован в реальном бизнес-результате, потому что он платит деньги, и если результатов не будет — вас уволят. К этому же типу стейкхолдеров можно отнести акционеров компании, поскольку они могут покупать, держать или продавать акции и голосовать за решения в совете директоров в зависимости от финансовых результатов компании. Вероятно, они также могут позволить себе купить стейк (steak), но на английском стейкхолдер пишется по-другому (stakeholders).</p><p><i>SME (Subject Matter Expert)</i> — эксперт предметной области, сотрудник, который много знает о бизнесе или системе, может помочь в ней разобраться, он может более не быть связан с продуктом напрямую, но он много знает о продукте и может дать ответы на вопросы о том, как система сторилась и каковы были ожидания от той или иной функциональности.</p><p><i>Команда разработки</i> — они выполняют работу, очень важно информировать их о том, что на самом деле нужно и почему, это ваша работа как бизнес-аналитика.</p><p><i>Команда поддержки</i> — если она есть, люди, которые помогают пользователям использовать систему, исправляют конфигурацию. Им нужно знать, как функционирует продукт, чтобы они могли помогать пользователям.</p><p><i>Конечные пользователи</i> — это люди, которые, в конечном счете, принимают решение об использовании вашего продукта. Именно пользователи генерируют прибыль, и на основе их поведения <b>платящий стейкхолдер</b> определяет ваше будущее.</p><p><i>Правительство</i> — правительство не только требуют от вас платить налоги, но и постоянно придумывают новые правила, о которых вы должны знать, и они не будут вас об этом информировать, поэтому вам лучше следить за заголовками новостей, чтобы не оказаться в тюрьме или не заплатить большой штраф.</p><p><i>Активисты и лоббисты</i> — попробуйте подумать обо всех НКО, которые пытаются подать на вас в суд.</p><p><i>Конкуренты</i> — другие компании, разрабатывающие аналогичный продукт или работающие в том же направлении, которые могут переманить ваших клиентов.</p><p><i>Поставщики и продавцы</i> — другие компании, помогающие бизнесу, могут быть фактическими поставщиками товаров или услуг, например, таким поставщиком услуг можно назвать клининговую компанию, аудитора, других поставщиков ПО.</p><h3>Типы требований</h3><h4>Функциональные и нефункциональные</h4><p><i>Функциональные требования (Functional Requirements - FR)</i> — описание ожиданий того, как должна повести себя система, в основном, в тех случая, когда пользователь совершает какое-то действие. Если при обсуждении требований кто-то говорит вам, что пользователь вообще не вовлечен в процесс, то этот кто-то, скорее всего, не знает о чем он говорит.  Даже если есть автоматическое задание, которое запускается по графику, причиной существования этого задания является использование результатов этого задания пользователем. <i>Пример:</i> допустим, есть цены,  которые наша система извлекает из стороннего API и сохраняет их в базе данных раз в день — эти цены будут использоваться при расчете стоимости заказа, когда пользователь его сформирует.</p><p><i>Нефункциональные требования (Non-Functional Requirements - NFR)</i> — описание ожиданий относительно того, как система должна работать в програмной среде — это требования к производительности (страница должна открываться в течение 3 секунд,  эндпойнт должен быть способен обрабатывать  100 000 записей одновременно), требования к  програмному обеспечению  (приложение должно быть доступно на iOS и Android,  сайт должен работать в IE11  (пожалуйста, скажите мне, что таких требований больше нет)),  требования к переводу (сайт должен быть доступен на испанском языке  — это требование все еще считается нефункциональным, но возможность переключения между языками  уже является функциональным требованием,  поскольку требует внешнего воздействия — действия пользователя),  требования к UX — например, соответствие HIPPA (Health Insurance Portability and Accountability Act - скажем 'привет', типу стейкхолдеров <i>правительство</i>),  когда от вас требуется предоставить аудиочитаемую версию сайта.</p><h4>Бизнес-требования и Системные требования</h4><p><i>Требования стейкхолдеров</i> — плохо сформулированные (возможно даже неправильно сформулированные) фрагменты предложений и мыслей, которые должен обработать бизнес-аналитик. В основном это проблемы бизнеса (например, «Я не знаю, пользователи будто игнорируют нашу новую страницу с прогнозом погоды, можем ли мы сделать большую красную кнопку, которая вела бы их туда прямо с лендинга?»)</p><p><i>Бизнес-требования</i> — ваш домен, эти требования должны быть хорошо структурированы, должны описывать, как работает система. («добавьте кнопку в центр главной страницы, следуйте дизайну, описанному в Figma (ссылка на источник); только пользователи, подписанные на план B, могут видеть эту кнопку и эту страницу; когда пользователь нажимает на кнопку, он перенаправляется на страницу с прогнозом погоды и видит ...»; и т. д.).</p><p>Кстати, приведенные выше требрвания - это не шаблон, мы поговорим о лучших способах написания требований в будущих главах этого курса. Я хотел бы подчеркнуть, что создание прототипа определенно является частью бизнес-требований, это подготовка к выявлению требований, такая же как и написание критериев приемки и поиск пропущенных сценариев.</p><p><i>Системные требования</i> — описание взаимодействия компонентов системы в результате действий пользователя. В спецификации системных требований (System Requirements Specification - SRS) такие требования называют требованиями к внешнему интерфейсу и системным функциям. Это в основном описание того, как система должна работать с другими системами или как компоненты одной системы взаимодействуют друг с другом, например,если у вас есть API эндпойнт, работу которого нужно задокументировать, вам нужно определить тело запроса и ответа, для каждого поля в теле запроса и ответа вам нужно определить тип данных, длинну, если это применимо (например для строчного типа данных, для десятичного типа данных), является ли поле обязательным или нет, какие валидации существуют для поля. Если информация хранится в базе данных, необходимо определить сопоставление полей базы данных с полями в запросе. Если информация передается в другую систему или извлекается другой системой, вам нужно определить сопоставление ваших полей с полями сторонего приложения (например, если информация передается между двумя микросервисами). Если информация периодически должна обновляться, как часто это должно происходить? Если возвращается много данных, должен ли эндпойнт поддерживать пагинацию? Должно ли быть ограничение по частоте запросов (rate limit). Если есть несколько вызовов между несколькими системами, используйте нотации UML или BPMN для визуализации последовательности выполненных вызовов и ожидаемых ответов. Если в бизнес-требованиях указано несколько состояний бизнес-объектов, сделайте себе одолжение и создайте диаграмму переходов состояний (state transition diagram), чтобы найти отсутствующие состояния и триггеры, которые приводят к переходу из одного состояния в другое.<p><p>Существует множество других классификаций, которые можно взять из IEEE/ISO, BABOK или книги Карла Вигерса.</p><h3>Выявление требований</h3><p><i>Выявление или cбор требований</i> — это этап в процессе бизнесс-анализа, когда аналитик собирает требования и пытается понять, какие требования вообще существуют, прежде чем записывать их. Существует множество методов:<ul><li>Интервью со стейкхолдерами</li><li>Мозговой штурм со стейкхолдерами</li><li>Интервью с пользователями</li><li>Наблюдение за поведением пользователей</li><li>Создание прототипов</li><li>Обзор и анализ документации и законодательства</li></ul></p><h3>Персоны и роли пользователей</h3><p>Существуют различные группы пользователей, в UX их также называют персонами — чтобы обозначить социальные различия в группах пользователей, обычно в одном приложении выделяются разные роли пользователей — Обычный пользователь, Администратор, Пользователь с подпиской А, Пользователь с подпиской Б. Если мы говорим о персонах — мы говорим о демографическом описании — вот пользователь Тим, ему около 25 лет, у него хорошее здоровье и он зарабатывает меньше денег, Джиму 45–50, он регулярно ходит к врачу и у него больше сбережений, чем у Тима, и т. д.</p><h3>Глоссарий</h3><p>Это буквально то, что вы читаете сейчас, и он должен быть в каждом хорошем проекте — глоссарий общих терминов по проекту, чтобы все говорили на одном языке, это особенно полезно,когда стейкхолдеры используют разные термины для одного и того же бизнес-объекта.</p><h3>User Story (Пользовательская история)</h3><p>Это шаблон для написания требований, в котором обязательно должны присутствовать роль пользователя, требуемая функция и ценность, которую пользователь получит от этой функции. <i>Пример:</i> Как <b><i>администратор приложения</i></b>, я хочу иметь возможность <b><i>добавлять статьи на главную страницу приложения</b></i>, чтобы <b><i>пользователь мог их прочитать</b></i>.</p><h3>Use Case</h3><p>Вариант использования системы — сценарий с пользовательским вводом и последовательностью действий системы, которые происходят из-за этого ввода.    <ol>        <li>Пользователь открывает главную страницу</li>        <li>Пользователь видит большую красную кнопку</li>        <li>Пользователь нажимает большую красную кнопку</li>        <li>Пользователь перенаправляется на такую-то страницу</li>    </ol></p><h3>Приемочное тестирование (Acceptance Testing)</h3><p>Тестирование, проводимое аналитиком перед развертыванием функционала в среде (environment), доступной заказчику или пользователю (PROD, UAT, Stage — существует множество названий для таких сред)</p><h3>Приемочное тестирование пользователем (User Acceptance Testing)</h3><p>Тестирование, проводимое пользователями в специально предназначенной для этого среде. Такая среда как раз может называться UAT или Stage.</p><h3>Release Notes</h3><p>Вместе с релизом в PROD стейкхолдерам отправляют документ, в котором перечислены все изменения, внесенные в релиз.</p><h3>Базовая документация</h3><p>Это статьи на wiki, Confluence, Sharepoint или любом другом инструменте, который может хранить общую информацию о функциональности продукта. Такая документация обязательно должна существовать, если ее нет, задача бизнесс аналитика будет заключаться в том, чтобы ее создать и поддерживать, она должна включать обзор проекта, диаграммы и схемы архитектуры.</p>"
        },
        {
            "id": "2",
            "title": "Глава II: Что такое хорошие требования?",
            "content": "<section><p>Требования — это фундамент любого проекта разработки. От их качества напрямую зависит успех реализации: сроки, бюджет и соответствие конечного продукта ожиданиям заказчика. В эпоху ИИ требования становятся еще важнее - теперь этот текст зачастую воспринимает не разработчик, а большая языковая модель, чем лучше будут тербования, тем лучше будет результат, инженеру останется больше времени для проектирования системы. В этой главе мы разберём, что делает требования «хорошими», опираясь на авторитетные источники: книгу Карла Вигерса «Разработка требований к ПО», стандарты IEEE/ISO, а также методики INVEST и SMART.</p></section><section>    <h2>Определение требования</h2> <p>В стандарте <strong>ISO/IEC/IEEE 29148:2011 4.1.17</strong> требования определяются как утверждение, которое толкует или выражает потребность, а также связанные с ней ограничения и условия (\"statement which translates or expresses a need and its associated constraints and conditions\").</p></section><section> <h2>Критерии хороших требований (по Карлу Вигерсу, глава 5)</h2>    <p>Карл Вигерс в книге «Разработка требований к программному обеспечению» выделяет следующие ключевые характеристики        качественных требований:</p>    <ul>        <li><strong>Единичность</strong> — требование описывает одну и только одну вещь.</li>        <li><strong>Завершённость</strong> — содержит всю необходимую информацию для понимания и реализации.</li>        <li><strong>Последовательность</strong> — не противоречит другим требованиям и документации.</li>        <li><strong>Атомарность</strong> — неделимо на более мелкие требования без потери смысла.</li>        <li><strong>Отслеживаемость</strong> — можно проследить связь с бизнес-целями и другими артефактами проекта.        </li>        <li><strong>Актуальность</strong> — остаётся релевантным на протяжении жизненного цикла проекта.</li>        <li><strong>Выполнимость</strong> — технически реализуемо в рамках заданных ограничений.</li>        <li><strong>Недвусмысленность</strong> — формулировка не допускает разночтений.</li>        <li><strong>Проверяемость</strong> — существует способ проверить выполнение требования.</li>    </ul></section><section>    <h2>Методика INVEST: критерии пользовательских историй</h2>    <p>Для Agile-подходов популярна методика <strong>INVEST</strong>, предложенная Биллом Уэйком. Она задаёт критерии        качества пользовательских историй:</p>    <ul>        <li><strong>I (Independent)</strong> — независимость: история не должна зависеть от других историй.</li>        <li><strong>N (Negotiable)</strong> — обсуждаемость: описание — не контракт, а повод для обсуждения.</li>        <li><strong>V (Valuable)</strong> — ценность: приносит пользу пользователю или бизнесу.</li>        <li><strong>E (Estimable)</strong> — оцениваемость: можно оценить трудозатраты.</li>        <li><strong>S (Small)</strong> — компактность: достаточно мала для реализации в одном спринте.</li>        <li><strong>T (Testable)</strong> — проверяемость: есть критерии приёмки.</li>    </ul></section><section>    <h2>Метод SMART: критерии формулировки требований</h2>    <p>Принцип <strong>SMART</strong> помогает сформулировать требования так, чтобы они были пригодны для реализации:    </p>    <ul>        <li><strong>S (Specific)</strong> — конкретность: чёткое описание, что нужно сделать.</li>        <li><strong>M (Measurable)</strong> — измеримость: есть критерии проверки выполнения.</li>        <li><strong>A (Achievable)</strong> — достижимость: технически реализуемо.</li>        <li><strong>R (Relevant)</strong> — актуальность: соответствует бизнес-целям.</li>        <li><strong>T (Time-bound)</strong> — ограниченность по времени: понятны сроки реализации.</li>    </ul></section><section>    <h2>Как понять, что требования готовы к передаче в разработку</h2>    <p>Перед передачей требований команде разработки проведите чек-лист проверки:</p>    <ol>        <li><strong>Полнота</strong>: все ли сценарии и граничные случаи учтены?</li>        <li><strong>Ясность</strong>: поймёт ли разработчик требование без дополнительных вопросов?</li>        <li><strong>Согласованность</strong>: нет ли противоречий с другими требованиями?</li>        <li><strong>Приоритеты</strong>: определены ли приоритеты (например, можно использовать технику MoSCoW: Must have, Should have, Could            have, Won't have, или просто High, Medium, Low)?</li>        <li><strong>Критерии приёмки</strong>: есть ли чёткие условия, по которым можно проверить выполнение?</li>        <li><strong>Зависимости</strong>: учтены ли внешние системы или компоненты?</li>        <li><strong>Риски</strong>: идентифицированы ли потенциальные проблемы реализации?</li>    </ol></section><section>    <h2>Типичные ошибки в требованиях</h2>    <ul>        <li>Неоднозначные формулировки. <i>Пример: </i> «пользователь должен легко найти…» - здесь не ясно что значит легко, каков критерий легкости?.</li><li>Требования-решения вместо требований-целей. <i>Пример: </i> «В новом поле в базе данных в таблице Orders конкатенируйте поля Id и ShortCode через дефис…» - зачем нужно это поле в базе, может нужно просто отдавать его в ответе API? Или даже просто показывать в пользовательском интерфейсе?</li>        <li>Отсутствие критериев проверки. <i>Пример: </i>«система должна быть быстрой» - про что это требование? Может быть про открытие страницы, насколько быстро в таком случае она должна открываться - 3 минуты, 3 секунды? При каком количестве одновременных пользователей? </li>        <li>Избыточная детализация на раннем этапе.</li>        <li>Несогласованность с бизнес-целями.</li>    </ul></section><section>    <p>Хорошие требования — это баланс между детализацией и гибкостью, точностью и понятностью. Опираясь на стандарты        IEEE/ISO, подходы Вигерса, INVEST и SMART, можно создать основу для успешной разработки:</p>    <ul>        <li>Проверяйте требования по критериям качества.</li>        <li>Вовлекайте команду в обсуждение для устранения неясностей.</li>        <li>Документируйте критерии приёмки.</li>        <li>Поддерживайте актуальность требований в процессе разработки.</li>    </ul>    <p>Только качественно сформулированные требования позволяют минимизировать риски, сократить затраты и создать        продукт, который действительно решает задачи пользователей.</p></section>"
        },
        {
            "id": "3",
            "title": "Глава III: Что делать на новом проекте?",
            "content": "<section><p>Начало работы над новым проектом — критический этап для бизнес‑аналитика. Перед вами — чёткий план действий на старте.</p></section><section><h3>Шаг 1. Анализ стейкхолдеров</h3>    <p>Aнализ стейкхолдеров позволяет:</p>    <ul><li>определить ключевые источники требований;</li>        <li>выстроить коммуникацию;</li>        <li>предвосхитить конфликты интересов;</li>        <li>распределить ответственность.</li>    </ul>    <h4>Как провести анализ</h4>    <ol>        <li><strong>Идентификация.</strong> Составьте список всех возможных стейкхолдеров: заказчики, пользователи, регуляторы, команда, смежные подразделения. Простого списка будет вполне достаточно. С именами и позициями вам может помочь ваше контакое лицо по проекту, лучше всех будет знать SME, но для этого его нужно идентифицировать.</li>        <li><strong>Классификация.</strong> Разделите стейкхолдеров на группы:            <ul>                <li>внутренние / внешние;</li>                <li>первичные (прямое влияние) / вторичные;</li>                <li>поддерживающие / сопротивляющиеся.</li>            </ul>    <p>Для классификации первичных и вторичных стейкхолдеров очень хорошо подойдет Onion-диаграмма</p><img width=\"500px\" height=\"500px\" alt=\"Example of onion diagram\" src=\"onion.png\"><p><i>Пример Onion-диаграммы</i></p>    </li>        <li><strong>Оценка интересов и влияния.</strong> Используйте Power Interest Grid для того, чтобы выбрать стартегию поведения со стейкхолдером: <table border=\"1rem\" cellpadding=\"5\">                <tr><th>Stakeholder</th><th>Power</th><th>Interest</th><th>Strategy</th></tr><tr><th>Buying customer</th><th>High Power</th><th>High interest</th><th>Manage closely</th></tr><tr><th>Platform holder</th><th>Low Power</th><th>Low interest</th><th>Monitor</th></tr><tr><th>Enduser</th><th>High Power</th><th>Low interest</th><th>Keep satisfied</th></tr><tr><th>Development team</th><th>Low Power</th><th>High interest</th><th>Keep informed</th></tr></table><p><img width=\"500px\" height=\"500px\" alt=\"Example of Power Interest Grid\" src=\"powerinterest.png\"></p><p><i>Пример Power Interst Grid</i></p> </li>        <li><strong>Планирование взаимодействия.</strong> Выделите для себя ключевых стейкхолдеров и определите как часто и каким образом вы будете с ними общаться, будет ли это на регулярных общих встречах, 2 раза в неделю на рефайнментах бэклога, или каждую неделю на 1-1, нужно ли приглашать менеджера заказчика на ежедневные встречи, нужно ли отправлять отчеты и если да, то в какой форме их принято отправлять. Все это можно выявить на личных встречах. </section><section>    <h3>Шаг 2. Создание глоссария</h3><p>Глоссарий — словарь терминов проекта. Он устраняет разночтения и ускоряет коммуникацию. Первая глава наглядно иллюстрирует такого рода глоссарий.</p>    <h3>Что включать</h3>    <ul>        <li>отраслевые термины (например, «лид», «конверсия» в маркетинге);</li>        <li>названия систем и модулей;</li>        <li>аббревиатуры и сокращения;</li>        <li>специфические для компании понятия.</li>    </ul>    <h3>Как составлять</h3>    <ol>        <li>Выделите термины из первых интервью и документов.</li>        <li>Согласуйте определения со стейкхолдерами.</li>        <li>Укажите синонимы и примеры использования.</li>        <li>Обновляйте по мере появления новых понятий.</li>    </ol>  </section><section>    <h3>Шаг 3. Базовая документация</h3>    <p>На старте сформируйте минимальный набор документов. Он станет фундаментом для дальнейшей работы.</p><h3>Обязательные документы</h3><ol><li><strong>Устав проекта</strong> <p>Кратко отвечает на вопросы:</p><ul><li>Зачем проект нужен? (цели, бизнес‑ценность)</li><li>Что будет сделано? (границы, результаты)</li><li>Кто участвует? (в принципе, работа по анализу стейкхолдеров закрывает этот пункт)</li><li>Когда? (сроки, этапы, примерный roadmap, если есть, если нет, его нужно выяснить у стейкхолдеров)</li><li>Какие есть ограничения? (бюджет, ресурсы)</li></ul>  <p>Eсли у вас в команде есть архиткетор, или опытный тех лид, возможно SME с техническим бэкграундом, свяжитесь с ним и нарисуйте диаграмму продукта и его взаимосвязи с другими продуктами, например, можно использовать нотацию С4 для описания архитектуры системы.</p>      </li>        <li>            <strong>Список требований (Baseline Requirements)</strong>            <p>Таблица с требованиями. Колонки:</p>            <ul>                <li>ID требования;</li><li>Заголовок;</li><li>Описание</li><li>Критерии приемки</li></ul><p>Таблица с требованиями должна копировать все требования из тикетов в вашей системе управления проектом, которые уже были задеплоены в прод. Вы можете организовать ее в wiki, Conflunce, Sharepoint, Word, Git - репозитории, главное чтобы они были в едином месте, так удобнее понимать текущее состояние проекта, еще лучше было бы отслеживать в этом же документе, как одни требования отменяют или расширяют другие. Конечно, не обязательно копировать требования дословно, можно суммаризировать их и делать более короткими.</p> </li>        <li>            <strong>Протокол встреч (Meeting Minutes)</strong>            <p>После каждой встречи всегда фиксируйте:</p>            <ul>                <li>дату и участников;</li>                <li>ключевые решения;</li>                <li>действия и ответственных;</li>                <li>открытые вопросы.</li>            </ul><p>Теперь ИИ ассистенты могу делать большую часть такой работы за вас, так что не теряйте шанс использовать их.</p></li>        <li>            <strong>Риски и проблемы (Risk Log)</strong>            <p>Таблица с колонками:</p>            <ul>                <li>Описание риска;</li>                <li>Вероятность наступления - выскоая, средняя, низкая;</li>                <li>Степень влияния на проект - высокая, средняя,низкая;</li>                <li>Меры - описание мероприятий для предотвращения или снижения риска;</li>                <li>Ответственный;</li>            </ul>        </li>    </ol>    <div >        <strong>Совет:</strong> Не стремитесь к идеальности на старте. Документы должны быть «живыми» — обновляйте их по мере поступления информации, показывайте их другим участникам команды для обсуждения.    </div></section><section>    <h2>Чек-лист первых 2 недель</h2>    <p>Чтобы не упустить важное, следуйте плану:</p>    <ol>        <li>Проведите вводные встречи с ключевыми стейкхолдерами.</li>        <li>Составьте первичный список стейкхолдеров и матрицу влияния.</li>        <li>Начните заполнять глоссарий на основе первых обсуждений.</li>        <li>Оформите устав проекта (даже в черновике).</li>        <li>Заведите список требований — внесите первые 5–10 пунктов.</li>        <li>Фиксируйте все встречи и решения в протоколах.</li>        <li>Идентифицируйте ключевые риски.</li>    </ol></section>"
        },
        {
            "id": "4",
            "title": "Глава IV: Выявление требований",
            "content": "<p>Выявление требований - это прежде всего набор техник и приемов для получения требований, часто аналитик противопостоавляют этот термин термину сбор, так как требования не растут из земли и их иногда приходится добывать с трудом. В этой главе мы подробнее остановимся на четырех основных методах выявления требований и дадим практические рекомендации по их применению.</p><section><h3>1. Интервью</h3>    <div>        <p><strong>Суть:</strong> персональное общение с заинтересованными сторонами для получения информации о            потребностях, проблемах и ожиданиях.</p>        <p><strong>Когда применять:</strong> при работе с ключевыми стейкхолдерами. Это самый простой и в то же время самый надежный способ, который можно применить почти всегда. </p>    </div>    <h3>Как проводить эффективно</h3>    <ol>        <li>Подготовьтесь: изучите контекст, составьте список вопросов.</li><li>Начните с открытых вопросов («Расскажите, как вы сейчас решаете эту задачу?»).</li>        <li>Используйте уточняющие вопросы («Почему это важно?», «Что произойдёт, если…»).</li>   <li>Лучше иметь предмет разговора перед глазами, если есть готовое приложение, сайт, прототип, референс конкурента, документ или график, обязательно покажите его на своем экране или попросите стейкхолдера показать свой экран с примером.</li>     <li>Фиксируйте не только ответы, но и вашу оценку ответов, вам может показаться, что человек не уверeн в своем суждении, тогда этот момент стоит верифицировать с другими стейкхолдерами.</li>   <li>Обязательно спрашивайте о приоритетах и сроках - это не обязательно расплывчатые High, Medium, Low, приоритеты это скорее даты, которые ваши стейкхолдеры уже пообщеали своим стейкхолдерам, например, их новый клиент начнет работу с приложением в мае этого года, так что, если сейчас апрель все остальные фичи будут менее приоритетными</li>     <li>В конце резюмируйте ключевые тезисы, после встречи составьте протокол и разошлите его участникам, обязательно проговорите нужна ли последующая встреча.</li>    </ol>    <div>        <strong>Совет:</strong> избегайте наводящих вопросов. Вместо «Вам ведь нужен экспорт в Excel?» спросите: «В        каких форматах вам приходится обмениваться данными?»    </div></section><section>    <h3>2. Воркшопы</h3>  <div><p><strong>Суть:</strong> групповые сессии с участием нескольких стейкхолдеров для совместного выявления и обсуждения требований.</p><p><strong>Когда применять:</strong> при сложных проектах, необходимости согласования позиций, генерации идей.</p>    </div>    <h4>Преимущества</h4>    <ul>        <li>Экономия времени (одновременный сбор мнений от нескольких участников).</li>        <li>Возможность сразу разрешить противоречия.</li>        <li>Генерация новых идей благодаря участию стейкхолдеров из разных потоков бизнеса.</li>    </ul>  <p>По большом счету это просто массовое интервью, но так как участников много, нужна четкая агенда перед глазами.</p>   <div>        <strong>Совет:</strong> подготовьте виртуальную доску и отмечайте прогресс агенды на ней.</div></section><section>    <h3>3. Прототипы</h3>    <div> <p><strong>Суть:</strong> создание упрощённых моделей продукта (интерфейсов, процессов) для визуализации идей и получения обратной связи. Кроме того, когда вы создаете прототип и начинает продумывать состояния и переходы между ними, можно найти недостоющие и непродуманные состояния и выявить требования таким образом</p>        <p><strong>Когда применять:</strong> для уточнения требований к интерфейсам, проверки гипотез, демонстрации концепций.</p>    </div>    <h4>Виды прототипов</h4>    <ul>        <li><strong>Бумажные</strong> — быстрые наброски от руки.</li>        <li><strong>Интерактивные</strong> — кликабельные макеты (например, в Figma).</li>        <li><strong>Функциональные</strong> — рабочие версии с базовым функционалом.</li>    </ul>    <h3>Как использовать</h3>    <ol>        <li>Создайте прототип на основе первичных требований.</li>        <li>Проведите демонстрацию стейкхолдерам.</li>        <li>Соберите обратную связь: что непонятно, что нужно изменить.</li>        <li>Итерируйте: улучшайте прототип до согласования.</li>    </ol>    <div>        <strong>Совет:</strong> не вкладывайте слишком много времени в детализацию раннего прототипа — его цель: быстро        получить обратную связь.    </div><p><a href=\"https://www.youtube.com/watch?v=kbZejnPXyLM&pp=ygUMZmlnbWEgY291cnNl\" target=\"blank\">Ссылка на курс по Figma</a></p><p>Конечно, никто не запрещает делать прототип в Cursor App в эпоху ИИ.</p></section><section>    <h3>4. Анализ документации</h3>    <div>        <p><strong>Суть:</strong> изучение существующих документов для выявления требований и контекста.</p>        <p><strong>Когда применять:</strong> в начале проекта, при модернизации систем, для понимания текущих процессов.        </p>    </div>    <h3>Какие документы анализировать</h3>    <ul>        <li>Бизнес‑планы и стратегии.</li>        <li>Описания текущих процессов (BPMN, текстовые регламенты).</li>        <li>Техническая документация систем.</li>        <li>Отчёты и аналитика (KPI, метрики).</li>        <li>Предыдущие требования и ТЗ.</li>        <li>Пользовательское руководство и FAQ.</li>    </ul>    <h3>Алгоритм анализа</h3>    <ol>        <li>Составьте список источников.</li>        <li>Выделите ключевые термины и процессы.</li>        <li>Найдите противоречия и пробелы.</li>        <li>Сформулируйте вопросы для уточнения.</li>        <li>Зафиксируйте выявленные требования.</li>    </ol>    <div>        <strong>Совет:</strong> создайте глоссарий на основе терминологии из документов — это снизит риск разночтений.    </div></section>    <h3>Частые ошибки и как их избежать</h3>    <ul>        <li>            <strong>Запись пожеланий, а не потребностей:</strong>            <p>Стейкхолдеры часто формулируют решения («хочу кнопку красного цвета»), а не проблему. </p>            <p><em>Как избежать:</em> задавайте уточняющие вопросы: «Зачем это нужно?», «Какую задачу это решает?», «Что                будет, если этого не сделать?»</p>        </li>        <li>            <strong>Отсутствие валидации:</strong>            <p>Требования зафиксированы, но не проверены на реалистичность и согласованность.</p>            <p><em>Как избежать:</em> после сбора требований проведите ревью со стейкхолдерами, смоделируйте сценарии                использования.</p>        </li>        <li>            <strong>Игнорирование нефункциональных требований:</strong>            <p>Фокус только на функционале, без учёта производительности, безопасности, удобства использования.</p>            <p><em>Как избежать:</em> Составьте список вопросов по нефункциональным требованиям (Сколько запросов может случиться за день/час/минуту? Какое максимальное колличество строк в запросе? Ожидает ли партнерская система синхронный или асинхронный ответ? Должна ли быть логика повтороной отправки? Сколько раз пробовать переотправлять упавший запрос? Как быстро должна загружаться страница? и так далее).</p>        </li>        <li>            <strong>Слишком общие формулировки:</strong>            <p>«Система должна работать быстро», «Интерфейс должен быть удобным» — невозможно проверить.</p>            <p><em>Как избежать:</em> конкретизируйте: «Время отклика системы — не более 2 сек при нагрузке до 1000                пользователей».</p>        </li>        <li>            <strong>Недооценка влияния изменений:</strong>            <p>Новые требования не анализируются на совместимость с существующими процессами и системами.</p>            <p><em>Как избежать:</em> создайте диаграмму процесса учитывая нижестоящие системы (например используя BPMN, или UML диаграмму последовательности).</p>        </li>        <li>            <strong>Отсутствие приоритизации:</strong>            <p>Все требования считаются одинаково важными, что ведёт к перегрузке разработки.</p>            <p><em>Как избежать:</em> спрашивайте о сроках поставки, если же вышло так что все фичи стали срочными и приоритетными, а команда разработки перегружена, нужно приоретизировать уже применяя специализированные техники -  (например, MoSCoW, Cost Of Delay).</p>        </li>        <li>            <strong>Недокументирование источников:</strong>            <p>Неясно, кто и почему выдвинул требование, что затрудняет дальнейшие уточнения.</p>            <p><em>Как избежать:</em> фиксируйте в списке требований: стейкхолдера, дату, контекст.</p>        </li>        <li>            <strong>Пропуск граничных случаев:</strong>            <p>Учитываются только «идеальные» сценарии, игнорируются ошибки, исключительные ситуации.</p>            <p><em>Как избежать:</em> моделируйте негативные сценарии («Что, если пользователь введёт некорректные                данные?»).</p>        </li>        <li>            <strong>Чрезмерная детализация на раннем этапе:</strong>            <p>Попытка описать все нюансы до утверждения концепции ведёт к потере времени.</p>            <p><em>Как избежать:</em> сначала зафиксируйте высокоуровневые требования, затем углубляйтесь в детали.</p>        </li>        <li>            <strong>Отсутствие обратной связи:</strong>            <p>Требования переданы команде без планирования.</p>            <p><em>Как избежать:</em> команда разработки должна планировать истории вместе с вами, помните, что вы не можете знать всего, их вклад в требования очень ценен. Если вы не хотите отрывать всю команду можно попросить провести предварительный разговор с тех лидом и одним из наиболее опытных тестировщиков.</p>        </li>    </ul></section><section>    <h2>Заключение</h2>    <p>Выявление требований — это не разовое действие, а итеративный процесс. Чтобы минимизировать ошибки:</p>    <ol>        <li>Комбинируйте методы (интервью + прототипы + анализ документов).</li>        <li>Фиксируйте всё письменно.</li>        <li>Регулярно валидируйте требования со стейкхолдерами.</li>        <li>Будьте гибкими: допускайте корректировку по мере поступления новой информации.</li>        <li>Используйте шаблоны и чек‑листы для систематизации работы.</li>    </ol>  </section>"
        },
        {
            "id": "5",
            "title": "Глава V: Приоретизация требований",
            "content": "<section><p>В любом проекте ресурсы ограничены: время, бюджет, команда. Приоритизация помогает определить, какие задачи принесут наибольшую пользу и должны быть реализованы в первую очередь. Конечно, классическим способом приоретизации является установление сроков, если какая-то задача должна быть выпущена к определенному сроку приоретизировать ее гораздо проще. Баги из прода с большим потенциальным или реальным воздействием всегда приоритетнее новых задач. Методы приоретизации, предложенные ниже, скорее подойдут для разработки MVP, когда приоритеты конкурируют друг с другом и скоуп нужно сокращать. </p></section><section><h3>Метод MosCoW</h3><p>MosCoW — это метод категоризации требований на четыре группы:</p><ul><li><strong>MUST have</strong> — обязательные требования, без которых проект не будет успешным</li><li><strong>SHOULD have</strong> — важные требования, но не критичные</li><li><strong>COULD have</strong> — желательные требования, которые можно отложить</li><li><strong>WON'T have</strong> — требования, которые не будут реализованы в текущей версии</li></ul><h4>Когда использовать?</h4><p>Идеально подходит для проектов с фиксированными сроками и бюджетом, где нужно четко определить минимальныйжизнеспособный продукт (MVP).</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> простота, понятность, быстрое внедрение</p><p><strong>Минусы:</strong> субъективность, отсутствие количественных метрик</p></section><section><h3>Cost of Delay (Цена простоя)</h3><p>Cost of Delay оценивает финансовые потери от задержки реализации фичи.</p><p>Cost of Delay можно посчитать как доход от фичи за едницу времени умноженный на колличество единиц времени, необходимых на имплементацию. <i>Например: </i> у вас есть баг, который ломает отправку заказов, в день на заказах компания зарабатывает $10 000. Команда разработки говорит, что сможет пофиксить баг за 2 дня, <b>Cost of Delay = $10 000 x 2 = $20 000</b>.</p><p>Есть также другая метрика на основе Cost of Delay - CD3. CD3 считается как доход от фичи в еденицу времени деленный на колличество едниц времени, необходимых на имплементацию. CD3 позволяет определить, какой из багов приоритетнее. <i>Пример: </i> Есть баг в проде , который ломает отправку заказов, в день на заказах компания зарабатывает $10 000. Команда разработки говорит, что сможет пофиксить баг за 2 дня. Назовем его Баг А. Есть Баг Б, который не позволяет показывать рекламу на сайте, в день сайт теряет $4 000 из-за этого. Команда разработки говорит, что может пофиксить этот баг за четверь дня (2 часа). <b>Cost of delay Бага А = $20000</b>. <b>Cost of delay Бага Б = $1000</b>. <b>СD3 Бага А = $10 000/ 2 = 5 000.</b> <b>СD3 Бага Б = $4 000 / 0.25 = 16 000</b>. Получается, что если выбирать по этому показателю, первым нужно фиксить Баг Б, его фикс быстрее вернет выручку.</p><h4>Когда использовать?</h4><p>Особенно полезен в коммерческих проектах, где важны финансовые показатели и ROI, и, что самое главное, там, где эти данные есть.</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> объективные численные данные, фокус на бизнес-ценности.</p><p><strong>Минусы:</strong> сложность расчетов, требует точных данных.</p></section><section><h3>Метод RICE</h3><p>RICE — система оценки, учитывающая четыре фактора:</p><ul><li><strong>Reach (Охват)</strong> — сколько пользователей затронет функция</li><li><strong>Impact (Влияние)</strong> — насколько сильно функция повлияет на каждого пользователя</li><li><strong>Confidence (Уверенность)</strong> — насколько точны наши оценки</li><li><strong>Effort (Усилия)</strong> — сколько времени/ресурсов потребуется</li></ul><p>Формула: <em>RICE Score = (Reach × Impact × Confidence) / Effort</em></p><h4>Когда использовать?</h4><p>Для продуктов с большим количеством пользователей, где важны метрики вовлеченности.</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> комплексный подход, учитывает несколько факторов</p><p><strong>Минусы:</strong> требует сбора данных, может быть переусложнен</p></section><section><h3>Story Mapping</h3><p>Визуальный метод организации пользовательских историй вдоль оси пользовательского пути.</p><img width=\"1000px\" height=\"500px\" src=\"storymap.png\"><p><i>Пример Story Map в Figma</i></p></section><section><h2>Как выбрать подходящий метод?</h2><table border='1' cellpadding='8' cellspacing='0'><tr><th>Метод</th><th>Лучше всего подходит для</th><th>Сложность внедрения</th></tr><tr><td>MosCoW</td><td>Проектов с фиксированными сроками, MVP</td><td>Низкая</td></tr><tr><td>Cost of Delay</td><td>Коммерческих проектов, где важен ROI</td><td>Высокая</td></tr><tr><td>RICE</td><td>Продуктов с метриками пользователей</td><td>Средняя</td></tr></table></section><section><h2>Практические советы по приоритизации</h2><ol><li>Начинайте с простых методов и переходите к сложным по мере необходимости</li><li>Вовлекайте ключевых стейкхолдеров в процесс приоритизации</li><li>Регулярно пересматривайте приоритеты — они могут меняться</li><li>Не забывайте о техническом долге и нефункциональных требованиях</li></ol></section><section><p>Не существует универсального 'лучшего' метода приоритизации. Выбор зависит от контекста проекта и доступных данных. Ключ к успеху — системный подход и регулярный пересмотр приоритетов по мере поступленияновой информации. Экспементируйте с разными методами, адаптируйте их под свои нужды.</p></section>"
        },
        {
            "id": "6",
            "title": "Глава VI: Документация требований",
            "content": "<p>Давайте рассмотрим самые популярные форматы документации требований - User Story, Use Case, BPMN и UML диаграммы, а так же Entity Relation диаграмму.</p><section>    <h3>1. User Stories (пользовательские истории)</h3>    <p>Краткие описания функциональности с точки зрения пользователя. Основной формат в Agile‑разработке.</p>    <h4>Структура</h4>    <p>«Как <em>[роль пользователя]</em>, я хочу <em>[функционал]</em>, чтобы <em>[получать выгоду]</em>». («As a <em>[role]</em>, I want to <em>[feature]</em>, so that <em>[value]</em>. »)</p>    <p><strong>Пример:</strong> «Как покупатель, я хочу фильтровать товары по цене, чтобы быстрее находить подходящие        варианты».</p>    <h4>Когда применять</h4>    <ul>        <li>В итеративной разработке (Scrum, Kanban).</li>        <li>При необходимости быстрой приоритизации требований.</li>        <li>Для коммуникации с нетехническими стейкхолдерами.</li>    </ul>    <h4>Плюсы и минусы</h4>    <p><strong>Плюсы:</strong> простота, фокус на ценности для пользователя, гибкость.</p>    <p><strong>Минусы:</strong> недостаточная детализация для сложных сценариев, риск неоднозначности.</p></section><section> <h4>Основные ошибки</h4><ul><li>Невалидная роль - я часто вижу как аналитики пишут «Как менеджер продукта, я хочу». Менеджер продукта это не роль в приложении, роль в приложении, это какой-то пользователь. Даже если кажется, что пользователя нет, а потребителем является сторонняя система, в сторонней системе есть это пользователь, который чего-то от системы ожидает. Так же стоит сказать, что в истории можно перечиcлить нескольких пользователей.</li><li>Отсутствие ценности - аналитики часто пропускают часть с описанием ценности, чем абсолютно дискредитируют концепт. Прописываение ценности - это тоже элемент анализа - он заставляет вас задуматься еще раз, этой ли фичи хочет пользователь. Ценность также придает работе программистов какой-то смысл, а так же позволяет предложить альтернативные решения. Давайте сравним историю с ценностью и без ценносьти. «Как администратор каталога, я хочу иметь возможность изменять доступное колличество товаров на складе». У меня сразу возникают вопросы - зачем давать такую возможность, нету интеграции со складской системой? Откуда администратору знать сколько продуктов на складе? Тепрь давайте добавим ценность. «Как администратор каталога, я хочу иметь возможность изменять доступное колличество товаров на складе, чтобы исправлять ошибки интеграции со складом». А, тут все понятно, то есть интеграция со складом есть, но, видимо, есть ошибки, просчеты или периодические даунтаймы на стороне складской системы, поэтому нужно иметь возможность поправить колличество вручную. </li></ul> <p>Я хочу отметить, что одной только истории будет недостаточно для того, чтобы передать требования в разработку. Обычно я включаю так же тезисное описание функциональных требований и критерии приемки в формате пошаговых тестовых сценариев.</p> <p><i>Пример моих требований:</i></p><p>Как <b><i>пользователь каталога</i></b>, я хочу <b><i>получать сообщения о поступлении товара на склад</i></b>, чтобы я мог <b><i>начать заказывать товар со склада</i></b>.</p> <p><b><i>Требования:</i></b></p> <p><ol><li>Для получения информации о поступлении товара каталог будет используется существующий API `GET api/receipt`, необходимо расширить ответ этого API, чтобы каталог мог сохранить информацию о приеме товара к себе.</li><li>Недостающие поля: <ul><li>expectedQuantity - источник в базе `DatabaseName.PurchaseOrder.Quantity`</li><li>productName - источник в базе `DatabaseName.Item.ProductName`</li><li>purchaseOrderNumber - источник в базе `DatabaseName.PurchaseOrder.OrderNumber`</li></ul></li><li>Пример ответа на запрос c новыми полями: <pre><code>{<br>\"recordsFound\":10,<br>\"recordsOnPage\":10,<br>\"pageNumber\":0,<br>\"totalPages\":1,<br>\"receipts\":<br>[<div style=\"margin-left: 50px;\">{<br>\"id\":1,<br>\"receivedQuantity\":10,<br>\"expectedQuantity\":10,<br>\"productName\":\"T-Shirt\",<br>\"purchaseOrderNumber\":\"PO123456\",<br>\"purchaseOrderLine\":1<br>}</div>]}</code></pre></li></ol><p></p></p><p><b><i>Критерии приемки</i></b><ol><li>Ответ на запрос новых поступлений товара содержит новые поля<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = 'T-Shirt', на 10 штук, номер заказа 'PO123456', строка заказа номер 1 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123456', номер строки 1, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = 'T-Shirt', для заказа 'PO123456', строки 1, с expectedQuantity = 10, receivedQuantity=10</p></li><li>Поступление на товар без названия<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = null, на 12 штук, номер заказа 'PO123457', строка заказа номер 2 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123457', номер строки 2, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = null, для заказа 'PO123457', строки 2, с expectedQuantity = 12, receivedQuantity=10</p></li></ol></p><p>Я бы хотел отметить что эти требования пример того, как работает аналитик внутри гибких методолгий, эндпойнт уже есть, он описан в предыдущих требованиях, есть валидации для эндпойнта `POST api/receipt`, все это не касается этого тербования, здесь мы расширяем существующий ответ запроса, так как к нам пришел новый клиент, и ему нужны новые поля, чтобы интегрироваться с нами. Ну и конечно, в требованиях могут быть ошибки и неточности, пропущенные сценарии, но у аналитика есть мощный инструмент для работы с ними - планирование с командой разработки.</p>  <h2>2. Use Case (сценарии использования)</h2>    <p>Высокоуровневое описание взаимодействия пользователя с системой. Включает предусловия, шаги и        постусловия.</p><p><i>Пример</i></p> <p><strong>ID:</strong> UC-001</p><table>    <tbody>        <!-- Строка: Название -->        <tr>            <th width=\"20%\">Поле</th>            <td width=\"80%\">Оформление заказа в интернет-магазине</td>        </tr>        <!-- Строка: Акторы -->        <tr>            <th>Акторы</th>            <td>                <ul>                    <li>Пользователь (покупатель)</li>                    <li>Система (интернет-магазин)</li>                </ul>            </td>        </tr>        <!-- Строка: Предусловия -->        <tr>            <th>Предусловия</th>            <td>                <ol>                    <li>Пользователь зарегистрирован в системе.</li>                    <li>Пользователь авторизован.</li>                    <li>В корзине есть хотя бы один товар.</li>                </ol>            </td>        </tr>        <!-- Строка: Основной сценарий -->        <tr>            <th>Основной сценарий</th>            <td>                <ol>                    <li>Пользователь переходит в корзину.</li>                    <li>Система отображает список товаров в корзине.</li>                    <li>Пользователь нажимает кнопку «Оформить заказ».</li>                    <li>Система открывает форму заполнения данных для доставки.</li>                    <li>Пользователь заполняет необходимые поля (адрес, способ оплаты).</li>                    <li>Пользователь подтверждает заказ.</li>                    <li>Система формирует заказ и отправляет уведомление на email.</li>                    <li>Система отображает номер заказа и итоговую сумму.</li>                </ol>            </td>        </tr>        <!-- Строка: Альтернативные сценарии -->        <tr>            <th>Альтернативные сценарии</th>            <td>                <div>                    <strong>А1. Пользователь отменяет заказ:</strong>                    <ol>                        <li>На любом шаге пользователь нажимает «Отменить».</li>                        <li>Система возвращает пользователя на главную страницу.</li>                    </ol>                </div>                <div>                    <strong>А2. Ошибка при заполнении данных:</strong>                    <ol>                        <li>Пользователь вводит некорректные данные (например, неверный email).</li>                        <li>Система выделяет ошибочные поля и выводит подсказки.</li>                        <li>Пользователь исправляет данные и повторяет отправку.</li>                    </ol>                </div>            </td>        </tr>        <!-- Строка: Постусловия -->        <tr>            <th>Постусловия</th>            <td>                <ul>                    <li>Заказ создан в системе.</li>                    <li>Пользователь получил уведомление о заказе.</li>                    <li>Товары из корзины удалены (если заказ успешно оформлен).</li>                </ul>            </td>        </tr>        <!-- Строка: Примечания -->        <tr>            <th>Примечания</th>            <td>                <ul>                    <li>Срок хранения корзины — 30 дней.</li>                    <li>При отсутствии товаров в наличии система предупреждает пользователя до оформления заказа.</li>                </ul>            </td>        </tr>    </tbody></table><h3>Когда применять</h3>    <ul>        <li>Для вотерфольных проектов, где бизнес привык видеть описание сценариев.</li><li>В начале проекта, когда нужно зафиксировать базовое поведение системы и согласовать его со стейкхолдерами.</li><li>В проектах с жёсткими требованиями к спецификации.</li>    </ul><p>У этого подхода есть визуальный формат - Use Case Diagram.</p><img src=\"usecase.png\"><p><i>Пример Use Case Diagram</i></p><p>Эти диаграммы относятся к нотации UML, о которой мы еще поговорим в ниже в этой же главе. Акторы здесь обозначены как люди, они находятся вне прямоугольника, который обозначате нашу систему. Этот прямоугольник называют границами системы. Акторы могут быть как реальными пользователями, так и внешними системами. Сами по себе варианты использования (Use Case) обозначены овалами внутри системы. Так же между акторами и вариантами использования обозначены связи нескольких типов. Ассоциация (Association) обозначается сплошной линией и служит для обозначения связи между актором и вариантом. Актор должен быть связан хотя бы с одним вариантом использования, при этом один актор может быть связан с несколькими вариантами, а один вариант использования - с несколькими акторами. Обобщение (Generalization) — отношение, при котором один актор или вариант использования наследует характеристики другого. Обозначается сплошной линией с незакрашенным треугольником на конце. Например, акторы «Клиент» и «Администратор» могут быть представлены более общим актором «Пользователь». Включение (Include) — обязательное отношение, при котором один вариант использования включает функциональность другого. Это означает, что базовый вариант использования неполноценен без включённого. Обозначается пунктирной линией со стрелкой и подписью «include». Например, вариант использования «Оформить заказ» может включать «Оплатить товар». Расширение (Extend) — необязательное отношение, при котором один вариант использования расширяет другой при определённых условиях. Обозначается пунктирной линией со стрелкой и подписью «extend». Например, вариант использования «Оформить заказ» может расширяться на «Применить промокод» при выполнении определённых условий. </p></section><section><h2>3. UML (Unified Modeling Language)</h2>    <p>Стандартный язык графического описания для моделирования систем. Включает десятки диаграмм.</p>    <h4>Ключевые диаграммы для требований</h4>    <ul>        <li><strong>Диаграмма классов</strong> — структура данных и связи между объектами.</li>        <li><strong>Диаграмма последовательностей</strong> — взаимодействие компонентов во времени.</li>        <li><strong>Диаграмма состояний</strong> — возможные состояния объекта и переходы между ними.</li>        <li><strong>Диаграмма активности</strong> — поток работ или процессов.</li>    </ul>    <h4>Когда применять</h4>    <ul>        <li>Для визуализации архитектуры системы.</li>        <li>При описании сложных алгоритмов.</li>        <li>Для коммуникации с разработчиками и архитекторами.</li>    </ul>    <p>Самой главной диаграммой я считаю <b>диаграмму последовательности</b>, так как она позволяет визуализировать общение между системами без лишних визуальных артефактов, как это происходит с BPMN.</p><p><b>Основные элементы UML sequence diagram</b></p><ul><li>Объекты (акторы) — сущности, которые взаимодействуют друг с другом. Это могут быть пользователи, системы, микросервисы, классы и т. д. Каждый объект представлен прямоугольником с именем в верхней части.</li><li>Линии жизни (lifelines) — вертикальные пунктирные линии, которые показывают существование объекта во времени. Они тянутся вниз от объекта и обозначают период его активности в процессе взаимодействия.</li><li>Сообщения (messages) — обмен информацией между объектами. Отображаются в виде стрелок, направленных от одной линии жизни к другой. Стрелки могут быть разных типов в зависимости от типа сообщения.</li><li>Активационные блоки (activation boxes) — прямоугольники на линии жизни, которые показывают период активности объекта при обработке сообщения. Начинаются в момент получения сообщения и заканчиваются после завершения обработки.</li><li>Примечания (notes) — дополнительные пояснения к диаграмме. Размещаются рядом с соответствующими элементами.</li></ul><p>Хочу посоветовать вам стараться создавать все диаграммы с помощью текстовых движков для создания диаграм вместо обычных визуальных редакторов, таких как Draw.io и Lucidchart. Попробуйте использовать Mermaid в VS code. Он поддерживается в Confluence, Azure DevOps, в простом маркдауне , и так же будет корректно отображаться в гитхабе. Причина этого совета в том, что текст для LLM воспринимается куда легче чем картинка, таким образом вы дадите нейросети больше контекста для помощи в составлении требований.</p><p><i>Пример sequence diagram в Mermaid: </i></p><pre><code><div>sequenceDiagram</div> <div style=\"margin-left:30px\">participant User <br>participant System <br>User->>System: Login request <br>activate System <br>System-->>User: Login success <br>deactivate System</div></code></pre><img width=\"400px\" length=\"400px\"  src=\"sequence.png\"><p><i>Пример визуализации sequence diagram сгенерированной в Mermaid</i></p><table><thead><tr><th>Тип сообщения</th><th>Описание</th><th>Пример в Mermaid</th></tr></thead><tbody><tr><td>Обычное сообщение</td><td>Стрелка с треугольником на конце, показывает вызов метода или передачу данных</td><td><code>A-&gt;&gt;B: Hello</code></td></tr><tr><td>Ответное сообщение</td><td>Пунктирная стрелка, показывает возврат значения</td><td><code>B--&gt;&gt;A: OK</code></td></tr><tr><td>Самосообщение (self&nbsp;message)</td><td>Стрелка в форме буквы&nbsp;U, объект отправляет сообщение самому себе</td><td><code>A-)A: Process data</code></td></tr><tr><td>Создание объекта</td><td>Сообщение с пометкой <code>create</code>, создаёт новый объект</td><td><code>A-&gt;&gt;create B: New object</code></td></tr><tr><td>Удаление объекта</td><td>Стрелка с крестиком на конце, уничтожает объект</td><td><code>A-&gt;-x B: Delete</code></td></tr></tbody></table></section><section><h2>4. BPMN (Business Process Model and Notation)</h2>    <p>Нотация для моделирования бизнес‑процессов. Показывает последовательность действий, роли и потоки данных.</p>    <h3>Основные элементы</h3>    <ul>        <li><strong>События</strong> (старт, завершение, промежуточные).</li>        <li><strong>Действия</strong> (задачи, подпроцессы).</li>        <li><strong>Шлюзы</strong> (условия ветвления).</li>        <li><strong>Потоки</strong> (последовательность, данные).</li>        <li><strong>Пулы и дорожки</strong> (роли/подразделения).</li>    </ul>    <h3>Когда применять</h3>    <ul>        <li>Для анализа и оптимизации бизнес‑процессов.</li>        <li>При автоматизации рабочих процедур.</li>        <li>Для согласования процессов между подразделениями.</li>    </ul>    <p>Я предлагаю использовать для моделирования приложение Camunda.</p><a href=\"https://camunda.com/download/modeler/\"><b><i>Ccылка на скачивание</i></b><p></a><img width=\"1000px\" height=\"400px\" src=\"bpmn.png\"></p><p><i>Пример бизнес процесса созданного с помощью Camunda</i></p>В этой нотации довольно много правил, есть много специализированных видео о том, как правильно создавать процессы в этой нотации, например <a href=\"https://www.youtube.com/watch?v=Eutdbh03W5k\" target=\"blank\"><i>The Only BPMN Tutorial You Will Ever Need To Watch</i></a>. К тому же есть отличная шпрагалска которой я всегда пользуюсь - <a href=\"https://bpm-conference.org/assets/docs/bpmn-poster/BPMN2_0_Poster_EN.pdf\" target=\"blank\"><i>BPMN Poster</i></a>.</section><section>    <h2>5. ERD (Entity-Relationship Diagram)</h2>    <p>Диаграмма «сущность‑связь» для моделирования структуры данных. Основа для проектирования баз данных.</p>    <h3>Ключевые компоненты</h3>    <ul>        <li><strong>Сущности</strong> (объекты предметной области, например «Клиент», «Заказ»).</li>        <li><strong>Атрибуты</strong> (свойства сущностей: «ID клиента», «Дата заказа»).</li>        <li><strong>Связи</strong> (отношения между сущностями: «Клиент делает Заказ»).</li>  <li><strong>Ключи</strong> (PK (Primary Key) уникальный идентификатор записи, FK (Foreign Key) обычно ссылка на PK другой сущности).</li>  </ul> <p><i>Пример в Mermaid</i></p><pre><div>erDiagram</div><div style=\"margin-left:30px\">CUSTOMER ||--o{ ORDER : \"размещает\"<br>ORDER ||--|{ LINE_ITEM : \"содержит\"<br>PRODUCT ||--o{ LINE_ITEM : \"используется в\"<br>CUSTOMER }|..|{ DELIVERY_ADDRESS : \"имеет\"<br><p>%% Описание сущностей и их атрибутов</p><br>CUSTOMER {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>STRING name<br>STRING email<br>DATE created_at</div>}<br>ORDER  {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER customer_id FK<br>DATE order_date<br>STRING status</div>}<br>LINE_ITEM  {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER order_id FK<br>INTEGER product_id FK<br>INTEGER quantity<br>DECIMAL unit_price</div>}<br>PRODUCT {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>STRING title<br>DECIMAL price<br>BOOLEAN is_available</div>}<br>DELIVERY_ADDRESS {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER customer_id FK<br>STRING address<br>STRING city<br> STRING postal_code</div>}</div></pre> <div><p>Как читать обозначения связей в Mermaid</p><ul><li>||--o{ — «один ко многим» (1:N), левая сторона обязательна, правая — нет;</li><li>||--|{ — «один ко многим» (1:N), обе стороны обязательны;</li><li>}|..|{ — «один ко многим» (1:N), обе стороны необязательны;</li><li>||--|| — «один к одному» (1:1);</li><li>o{--o{ — «многие ко многим» (M:N).</li></ul></div><img width=\"800px\" height=\"1000px\" src=\"erd.png\"><p><i>Пример ERD сгенерированного в Mermaid</i></p>   <h3>Когда применять</h3>    <ul>        <li>На этапе проектирования базы данных.</li>        <li>Для уточнения требований к хранению данных.</li></li></ul></section>"
        },
        {
            "id": "7",
            "title": "Глава VII: Валидация требований",
            "content": "<p>В этой главе мы рассмотрим 2 техники валиадации требований - демо и критерии приемки.</p><section>    <h3>1. Демонстрации (демо)</h3>    <p>Наглядная проверка реализации требований через показ работающего функционала.</p>    <h4>Цели демо</h4>    <ul>        <li>Подтвердить, что функционал соответствует ожиданиям стейкхолдеров.</li>        <li>Выявить расхождения между требованиями и реализацией.</li>        <li>Получить обратную связь для корректировок.</li>        <li>Повысить прозрачность процесса разработки.</li>    </ul>    <h4>Как организовать эффективное демо</h4>    <ol>        <li><strong>Подготовьте сценарий:</strong> заранее определите, какие функции и сценарии будете показывать.</li>        <li><strong>Пригласите ключевых стейкхолдеров:</strong> заказчиков, конечных пользователей, представителей            бизнеса.</li>        <li><strong>Покажите реальные данные:</strong> используйте примеры из бизнес‑процессов, а не абстрактные            тестовые значения.</li>        <li><strong>Включите негативные сценарии:</strong> продемонстрируйте, как система реагирует на ошибки и            исключительные ситуации.</li>        <li><strong>Фиксируйте обратную связь:</strong> записывайте замечания и вопросы для дальнейшей работы.</li>    </ol>    <p><strong><i>Пример: </i></strong> При демо модуля оформления заказа покажите: выбор товара → добавление в корзину → ввод        данных → оплату → получение подтверждения. Затем смоделируйте ошибку платежа и проверьте обработку.</p><p><strong><i>Совет: </i></strong> Бизнесу не очень инетересно как устроена система, поэтому демо должно быть максимально живым, приближенным к их реалиям, если ваш продукт это маркетплейс, расскажите историю, о том как вам понравилась кружка, вы решаете ее купить, добавляете в корзину и так далее. К тому же это сделает демо не настолько скучным.</p></section><section>    <h3>2. Критерии приемки (Acceptance Criteria)</h3>    <p>Конкретные условия, которые должны быть выполнены, чтобы требование считалось реализованным.</p>    <h4>Зачем нужны</h4>    <ul>        <li>Устраняют неоднозначность в понимании требований.</li>        <li>Служат основой для тестирования.</li>        <li>Помогают оценить готовность функционала.</li>        <li>Снижают риск споров между командой и заказчиком.</li> <li>Помогают найти пропущенные сценарии</li>   </ul>    <h4>Формат постых сценариев</h4>    <p>Проше всего записывать критерии приемки как короткие сценарии. Ниже приведен пример таких критериев приемки для функции «Восстановление пароля»:</p><ol><li>Пользователь на странице входа. Пользователь нажимает «Забыли пароль», видит экран с полем для ввода электронной почты, вводит валидный email, и нажимает кнопку `Отправить ссылку на восттановление пароля`. <b>Ожидаемый результат: </b> Пользоваетль получает письмо со ссылкой для сброса.</li><li>Пользователь на странице входа. Пользователь нажимает «Забыли пароль», видит экран с полем для ввода электронной почты, вводит невалидный email. <b>Ожидаемый результат: </b> Кнопка `Отправить ссылку на восттановление пароля` неактивна, границы поля стали красными, под полем пользователь видит валидационную ошибку `Адрес электронной почты недействителен. Используйте формат user@example.com`.</li></ol></section><section>    <h4>Формат сценариев на языке Gherkin</h4>    <p>Специализированный язык для описания приемочных критериев в человекочитаемом формате, декларируется его легкая конвертация в автотесты.</p> <p>Использует ключевые слова на английском (можно адаптировать под любой другой язык):</p>    <ul>        <li><code>Feature:</code> — название функционала. (Функционал)</li>        <li><code>Scenario:</code> — конкретный сценарий проверки. (Сценарий)</li>        <li><code>Given:</code> — начальные условия. (Дано)</li>        <li><code>When:</code> — действие.(Когда)</li>        <li><code>Then:</code> — результат. (Тогда)</li>        <li><code>And:(И)</code> / <code>But:</code> — дополнительные условия.(Но)</li>    </ul>    <i>Пример на Gherkin</i>    <pre>Функционал: Оформление заказа<br>Сценарий: Успешное оформление с оплатой картой<br>Дано: пользователь авторизован<br>И: в корзине есть товары<br>Когда: он выбирает способ оплаты «Банковская карта» <br>И: вводит корректные данные карты <br>Тогда: заказ подтверждается<br>И: списывается сумма<br>И: приходит уведомление на email</pre>    <p>Преимущества Gherkin: </p>    <ul>        <li>Единое понимание: одинаково читается бизнес‑аналитиками, разработчиками и тестировщиками.        </li>        <li>Автоматизация: сценарии можно превратить в автоматизированные тесты (Cucumber, SpecFlow).        </li>        <li>Документация: служит живым описанием функционала.</li></ul>  <p>Недостатки Gherkin: </p><ul><li>Сценарии становятся очень многословными</li><li>Из-за попытки описать сценарий для автотестов читабельность для бизнеса снижается</li><li>Сценарии нужно писать от лица пользователя, это снижает детализацию системных требований внутри сценария.</li></ul> </section><h4>Формат тестовых сценариев</h4><p>Вместо коротких сценариев описывается каждый шаг, предусловие и ожидаемы результат, тут нет привязки к пользователям, их проще использовать тестировщикам для написания тестов, они так же подходят для автоматизации. Ниже скопировал пример из предыдушей главы.</p> <ol><li>Ответ на запрос новых поступлений товара содержит новые поля<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = 'T-Shirt', на 10 штук, номер заказа 'PO123456', строка заказа номер 1 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123456', номер строки 1, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = 'T-Shirt', для заказа 'PO123456', строки 1, с expectedQuantity = 10, receivedQuantity=10</p></li><li>Поступление на товар без названия<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = null, на 12 штук, номер заказа 'PO123457', строка заказа номер 2 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123457', номер строки 2, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = null, для заказа 'PO123457', строки 2, с expectedQuantity = 12, receivedQuantity=10</p></li></ol><section><h4>Лучшие практики</h4>    <ul>        <li>Пишите критерии до начала разработки.</li><li>Включайте граничные случаи (пустые поля, неверные форматы).</li>        <li>Согласовывайте с тестировщиками и заказчиками.</li><li>Пытайтесь отрисовать сценарии в форме прототипов (можете согласовывать сценарии используя прототипы - так гораздо нагляднее).</li>   </ul></section><section>    <h4>Частые ошибки</h4>    <ul>        <li><strong>Отсутствие критериев:</strong> требования без четких условий приемки ведут к разночтениям.</li>        <li><strong>Слишком общие формулировки:</strong> «Система работает корректно».        </li>        <li><strong>Игнорирование негативных сценариев:</strong> проверяйте не только «счастливый путь».</li>        <li><strong>Демо без подготовки:</strong> хаотичный показ функционала не дает ценной обратной связи.</li>        <li><strong>Gherkin как формальность:</strong> писать сценарии «для галочки», не используя их в тестировании.        </li>    </ul></section><section> <p>Валидация требований — не финальный этап, а непрерывный процесс. Комбинируя демо, и приемочные критерии, вы:</p>    <ul>        <li>снижаете риск недопонимания;</li>        <li>экономите время на переделки;</li>        <li>повышаете качество продукта;</li>        <li>делаете разработку прозрачнее для всех участников.</li>    </ul>    <p>Начните с малого: для каждой новой функции формулируйте 3–5 приемочных критерия и проводите мини‑демо для стейкхолдеров.</p></section>"
        },
        {
            "id": "8",
            "title": "Глава VIII: SQL для BA",
            "content": "<p>Глава не претендует на полный справочник по базам данных, но аналитку так или иначе нужно взаимодействовать с реляйионными базами данных. При этом, есть и другие форматы хранения данных, те же самые NoSQL базы данных, FTP. Об этом мы можем погворит в будущих главах.</p><section>    <p>Бизнес‑аналитику SQL нужен для:</p>    <ul>        <li>самостоятельного извлечения данных из баз;</li>        <li>проверки гипотез без привлечения разработчиков;</li>        <li>подготовки отчётов и дашбордов;</li>        <li>анализа пользовательского поведения;</li>        <li>валидации требований к данным.</li>    </ul>    <p>Достаточно знать базовые операторы — сложные оптимизации оставьте DBA.</p></section><section>    <h3>1. SELECT — выборка данных</h3>    <p>Основной оператор для получения данных из таблицы.</p>    <h3>Базовый синтаксис</h3>    <pre>SELECT столбец1, столбец2 FROM имя_таблицы;</pre>    <h3>Примеры</h3>    <ul>        <li>Выбрать все столбцы: <code>SELECT * FROM client;</code></li>        <li>Выбрать конкретные столбцы: <code>SELECT name, email FROM client;</code></li>        <li>С фильтрацией: <code>SELECT * FROM order WHERE status = 'Оплачен';</code></li>        <li>С сортировкой: <code>SELECT * FROM product ORDER BY price DESC;</code></li>    </ul>    <h3>Полезные модификаторы</h3>    <ul>        <li><code>WHERE</code> — условие отбора (фильтрация).</li>        <li><code>ORDER BY</code> — сортировка (ASC/DESC).</li>        <li><code>TOP</code> — ограничение числа строк.</li>    </ul></section><section>    <h3>2. JOIN — объединение таблиц</h3>    <p>Позволяет связывать данные из нескольких таблиц по общим полям.</p>    <h4>Основные типы JOIN</h4>    <h5>INNER JOIN</h5>    <p>Возвращает только совпадающие строки из обеих таблиц.</p>    <pre>SELECT order.id, client.name FROM order INNER JOIN client ON order.client_id = client.id;</pre>    <h5>LEFT JOIN</h5>    <p>Возвращает все строки из левой таблицы и совпадающие из правой (если нет совпадений — NULL).</p>    <pre>SELECT client.name, order.sum FROM client LEFT JOIN order ON client.id = order.client_id;</pre>    <h5>RIGHT JOIN</h5>    <p>Аналогично LEFT JOIN, но для правой таблицы.</p></section><section>    <h3>3. DISTINCT — уникальные значения</h3>    <p>Убирает дубликаты из результата запроса.</p>    <h4>Синтаксис</h4>    <pre>SELECT DISTINCT column FROM table;</pre>    <h4>Примеры</h4>    <ul>        <li>Уникальные статусы заказов: <code>SELECT DISTINCT status FROM order;</code></li>        <li>Уникальные комбинации: <code>SELECT DISTINCT city, region FROM client;</code></li></ul></section><section>    <h3>4. MAX — максимальное значение</h3>    <p>Находит наибольшее значение в столбце.</p>    <h4>Синтаксис</h4>    <pre>SELECT MAX(column) FROM table;</pre>    <h4>Примеры</h4>    <ul>        <li>Максимальная цена продукта: <code>SELECT MAX(price) FROM product;</code></li>        <li>Последняя дата заказа: <code>SELECT MAX(date) FROM order;</code></li>        <li>С группировкой: <code>SELECT category, MAX(price) FROM producy GROUP BY category;</code></li>    </ul>    </section><section>    <h3>5. AVG — среднее значение</h3>    <p>Вычисляет среднее арифметическое значений в столбце.</p>    <h4>Синтаксис</h4>    <pre>SELECT AVG(column) FROM table;</pre>    <h4>Примеры</h4>    <ul>        <li>Средняя стоимость заказа: <code>SELECT AVG(sum) FROM order;</code></li>        <li>Средний возраст клиентов: <code>SELECT AVG(age) FROM client;</code></li>        <li>По категориям: <code>SELECT type, AVG(rate) FROM feedback GROUP BY type;</code></li>    </ul>    <p><strong>Важно:</strong> AVG игнорирует NULL‑значения.</p></section><section>    <h3>Советы по работе с SQL</h3>    <ul>        <li><strong>Начинайте с простого:</strong> сначала освойте SELECT и WHERE, затем переходите к JOIN.</li>        <li><strong>Используйте комментарии:</strong> <code>-- Ваш комментарий</code> или            <code>/* комментарий */</code>.        </li>        <li><strong>Проверяйте запросы:</strong> запускайте на небольших выборках (<code>TOP 10</code>).</li>        <li><strong>Изучайте структуру БД:</strong> узнайте названия таблиц и ключей у администратора.</li>        <li><strong>Сохраняйте шаблоны:</strong> создайте библиотеку часто используемых запросов.</li><li><strong>Диалекты: </strong>в разных диалектах SQL есть незначительная разница в ключевых словах и синтаксисе, здесь я приводил примеры из TSQL. </li></ul></section>"
        },
        {
            "id": "9",
            "title": "Глава IX: Документация API",
            "content": "<h3>Документация API: зачем она нужна и почему без неё нельзя</h3><p>Документация API — это формальное и одновременно практическое описание того,как внешние и внутренние клиенты могут взаимодействовать с серверной частью системы.По сути, это <strong>контракт</strong>, который отвечает на вопросы:</p><ul>    <li>какие эндпоинты существуют</li>    <li>какие данные и в каком формате нужно передавать</li>    <li>какие ответы и ошибки можно получить</li>    <li>какие ограничения и правила действуют</li></ul><p>Хорошая документация снижает порог входа, ускоряет интеграции и уменьшает количество ошибок. Плохая или отсутствующая документация приводит к догадкам, хаотичным правкам и конфликтам между командами.</p><h3>Основные подходы к документированию API</h3><p>На практике чаще всего используются два подхода:</p><ul>    <li><strong>request-first</strong> — документация строится на основе реальных запросов</li>    <li><strong>API-first</strong> — сначала описывается контракт, потом реализуется код</li></ul><h3>Документация API в Postman</h3><h4>Что такое Postman и когда он подходит</h4><p>Postman изначально создавался как инструмент для тестирования API, но со временем превратился в универсальную платформу для работы с запросами, окружениями, автотестами и документацией.</p><p>Postman особенно хорошо подходит, когда:</p><ul>    <li>API уже существует</li>    <li>важно быстро показать примеры запросов</li>    <li>документацией пользуются разработчики и QA</li></ul><h4>Коллекции как основа документации</h4><p>Документация в Postman строится вокруг <strong>коллекций</strong>. Каждый запрос внутри коллекции может быть снабжён описанием и примерами.</p><p>Пример структуры коллекции:</p><pre>Users <br>├── GET /users <br>├── GET /users/{id} <br>├── POST /users <br>└── DELETE /users/{id}</pre><h4>Пример документированного запроса в Postman</h4><p>Описание эндпоинта:</p><pre>GET /users/{id}<br>Возвращает информацию о пользователе по его идентификатору.Требует авторизации.</pre><p>Параметры:</p><ul>    <li><strong>id</strong> (path, integer) — идентификатор пользователя</li></ul><p>Пример ответа (200 OK):</p><pre>{  <br>\"id\": 42, <br>\"name\": \"Ivan Ivanov\",  <br>\"email\": \"ivan@example.com\"<br>}</pre><p>Пример ошибки (404 Not Found):</p><pre>{  <br>\"error\": \"User not found\"<br>}</pre><h4>Плюсы Postman</h4><ul>    <li>документация создаётся «по ходу дела»</li>    <li>живые примеры запросов и ответов</li>    <li>удобно шарить с командой</li></ul><h4>Минусы Postman</h4><ul>    <li>нет строгой формализации контракта</li>    <li>сложно отслеживать изменения API</li>    <li>документация может отставать от реализации</li></ul><h3>Документация API в Swagger</h3><h4>Swagger и спецификация OpenAPI</h4><p>Swagger — это набор инструментов, работающих на основе спецификации OpenAPI</strong>. Здесь API описывается декларативно — в виде формального контракта.</p><p>Основной принцип: <strong>сначала описание, потом код</strong>.</p><h4>Структура OpenAPI-документа</h4><p>Типичный OpenAPI-файл содержит:</p><ul>    <li>описание API и версию</li>    <li>эндпоинты и HTTP-методы</li>    <li>параметры</li>    <li>схемы данных</li>    <li>коды ответов и ошибки</li></ul><h4>Пример описания эндпоинта в Swagger (YAML)</h4><code>paths:  <div style=\"margin-left:30px\">/users/{id}:</div><div style=\"margin-left:40px\">get:</div>      <div style=\"margin-left:50px\">summary: Получить пользователя</div>     <div style=\"margin-left:50px\">parameters:</div>        <div style=\"margin-left:60px\">- name: id</div>          <div style=\"margin-left:80px\">in: path</div>        <div style=\"margin-left:80px\">required: true</div> <div style=\"margin-left:80px\">schema:</div> <div style=\"margin-left:95px\">type: integer</div>  <div style=\"margin-left:50px\">responses:</div> <div style=\"margin-left:80px\">'200':</div> <div style=\"margin-left:95px\">description: Успешный ответ</div>        <div style=\"margin-left:80px\">'404':</div>  <div style=\"margin-left:95px\">description: Пользователь не найден</div></code><p>На основе этого описания автоматически генерируется интерактивная документация, где можно отправлять запросы прямо из браузера.</p><h4>Плюсы Swagger</h4><ul>    <li>чёткий и проверяемый контракт</li>    <li>удобен для внешних клиентов</li>    <li>поддерживает генерацию SDK и серверных заготовок</li></ul><h4>Минусы Swagger</h4><ul>    <li>требует больше времени на начальную настройку</li>    <li>менее гибок для исследовательского тестирования</li></ul><h3>Postman и Swagger вместе</h3><p>На практике эти инструменты часто используются совместно:</p><ul>    <li>Swagger — как единый источник правды для API</li>    <li>Postman — для тестирования и примеров</li></ul><p>Распространённый сценарий:</p><ol>    <li>описать API в OpenAPI</li>    <li>сгенерировать документацию Swagger</li>    <li>импортировать спецификацию в Postman</li>    <li>дополнить запросы тестами и примерами</li></ol><h3>Типичные ошибки при документировании API</h3><ul>    <li>описан только happy path</li>    <li>нет примеров ошибок</li>    <li>документация не обновляется</li>    <li>несовпадение документации и реального API</li></ul><p>Postman и Swagger решают одну задачу - документирование API - но с разных сторон. Swagger задаёт строгий контракт и отлично подходит для API-first подхода, а Postman делает API наглядным и удобным для тестирования.</p><p>Использование обоих инструментов вместе позволяет получитьактуальную, понятную и полезную документацию, которая действительно помогает работать с API.</p>"
        },
        {
            "id": "10",
            "title": "Глава X: Как работать в Agile команде",
            "content": "<section>  <p>В Agile‑команде BA — не «передаточное звено», а активный участник процесса разработки.</p>  <h3>1. Роль бизнес‑аналитика в Agile</h3>     Ключевые функции аналитика:</p>    <ul>        <li>выявление и анализ потребностей заказчика;</li>        <li>формулировка User Stories и критериев приёмки;</li>        <li>поддержка коммуникации между бизнесом и разработкой;</li>        <li>анализ данных для приоритизации задач;</li>        <li>участие в демонстрациях и ретроспективах.</li>    </ul>    <p><strong>Важно:</strong> фокус на ценности для пользователя, а не на формальной документации.</p></section><section>    <h3>2. Взаимодействие с Product Owner</h3>    <p>Совместная работа над бэклогом:</p>    <ol>        <li>Помогайте PO структурировать требования (разбивайте крупные задачи).</li>        <li>Уточняйте бизнес‑контекст для каждой User Story.</li>        <li>Предлагайте метрики для оценки ценности функций.</li>        <li>Обсуждайте компромиссы между бизнес‑потребностями и техническими ограничениями.</li>    </ol>    <p><strong>Пример:</strong> Если PO просит «улучшить интерфейс», задайте вопросы: «Какие метрики улучшим? Какие        сценарии пользователей затронем?»</p></section><section>    <h3>3. Работа с командой разработки</h3>    <p>Как эффективно взаимодействовать:</p>    <ul>        <li><strong>На планировании спринта:</strong> разъясняйте требования, обсуждайте риски.</li>        <li><strong>В процессе спринта:</strong> оперативно уточняйте детали, участвуйте в обсуждениях решений.</li>        <li><strong>При тестировании:</strong> проверяйте соответствие результата бизнес‑целям.</li>        <li><strong>На демо:</strong> объясняйте ценность реализованных функций заказчику.</li>    </ul>    <p><strong>Совет:</strong> посещайте ежедневные стендапы, даже если вас не спрашивают — это помогает быть в        контексте.</p></section><section>    <h3>4. Документирование в Agile</h3>    <p>Принцип: «Достаточно, но не избыточно». Что и как фиксировать:</p>    <ul>        <li><strong>User Stories:</strong> формат «Как [роль], я хочу [функцию], чтобы [выгода]».</li>        <li><strong>Критерии приёмки:</strong> конкретные условия выполнения задачи (Given‑When‑Then).</li>        <li><strong>Диаграммы/схемы:</strong> только если упрощают понимание (например, C4, BPMN).</li>        <li><strong>Решения по спорным вопросам:</strong> кратко фиксируйте итоги обсуждений.</li>    </ul>    <p><strong>Избегайте:</strong> многостраничных ТЗ без привязки к итерациям.</p></section><section>    <h3>5. Анализ требований в итеративном режиме</h3>    <p>Пошаговый подход:</p>    <ol>        <li><strong>Выявление:</strong> интервью со стейкхолдерами, анализ данных, наблюдение за процессами.</li>        <li><strong>Формулировка:</strong> превращайте потребности в User Stories с критериями приёмки и кладите их в бэклог.</li>        <li><strong>Приоритезация:</strong> совместно с PO определяйте порядок реализации, кладите тикеты в спринты.</li>        <li><strong>Планирование:</strong> перед спринтом планируйте задачи с командой, расставляйте оценки, чтобы понимать сложность имплементации.</li>        <li><strong>Валидация:</strong> на демо проверяйте, решает ли функционал задачу пользователя.</li>    </ol></section><section>    <h3>6. Участие в ритуалах Agile</h3>    <table border='1' cellpadding='5'>        <tr>            <th>Ритуал</th>            <th>Роль BA</th>        </tr>        <tr>            <td>Планирование спринта</td>            <td>Разъяснение требований, оценка сложности задач.</td>        </tr>        <tr>            <td>Ежедневный стендап</td>            <td>Сообщение о прогрессе по анализу, блокировках.</td>        </tr>        <tr>            <td>Обзор спринта</td>            <td>Демонстрация ценности реализованных функций, сбор обратной связи.</td>        </tr>        <tr>            <td>Ретроспектива</td>            <td>Предложение улучшений процессов анализа и коммуникации.</td>        </tr>    </table></section><section>    <h3>7. Работа с изменениями</h3>    <p>В Agile требования меняются — это норма. Как реагировать:</p>    <ul>        <li>Оценивайте влияние нового требования на текущий спринт.</li>        <li>Фиксируйте причины изменений (чтобы избежать «блуждающих» требований).</li>        <li>Обновляйте User Stories и критерии приёмки при необходимости.</li>        <li>Объясняйте команде бизнес‑контекст изменений.</li>    </ul>    <p><strong>Правило:</strong> «Нет изменений посреди спринта без согласования с командой».</p></section><section>    <h3>8. Типичные ошибки BA в Agile</h3>    <ul>        <li><strong>«Перекладывание» ответственности:</strong> ожидание, что команда сама додумает требования.</li>        <li><strong>Избыточная детализация:</strong> попытки описать всё до мелочей до начала разработки.</li>        <li><strong>Отсутствие валидации:</strong> не проверяете, понял ли разработчик суть задачи.</li>        <li><strong>Игнорирование данных:</strong> решения без анализа метрик и пользовательского поведения.</li>        <li><strong>Сопротивление изменениям:</strong> защита «идеального» ТЗ вместо адаптации к реальности.</li>    </ul></section><section>    <h3>9. Советы для эффективного BA в Agile</h3>    <ol>        <li>Говорите на языке бизнеса и техники: переводите требования между стейкхолдерами.</li>        <li>Фокусируйтесь на ценности: каждый функционал должен решать конкретную проблему.</li>        <li>Будьте проактивны: предлагайте улучшения процессов, а не только фиксируйте требования.</li>        <li>Учитесь у команды: понимайте технические ограничения и возможности.</li>        <li>Документируйте итерационно: обновляйте материалы по мере уточнения деталей.</li>        <li>Развивайте навыки фасилитации: проводите эффективные встречи.</li>        <li>Используйте визуализацию: схемы часто понятнее текста.</li> <li>Требования на новый спринт начинайте писать сразу после планирования текущего спринта - писать в стол на пару спринтов вперед не самая плохая идея.</li>   </ol></section>"
        },
        {
            "id": "11",
            "title": "Глава XI: В плену у Ганта",
            "content": "<p>Software Requirements Specification (SRS) — это ключевой документ в разработке программного обеспечения,который    формально описывает, <strong>что именно должна делать система</strong>. Один из самых распространённых и проверенных    временем подходов — использование шаблона IEEE. Он помогает структурировать требования, избежать двусмысленностей и    упростить коммуникацию междузаказчиком, аналитиками, разработчиками и тестировщиками.</p><p>В этой статье разберём, <strong>как правильно писать SRS, следуя шаблону IEEE</strong>, и на что обращать внимание в    каждом разделе.</p><h3>1. Introduction (Введение)</h3><h4>1.1 Purpose (Цель документа)</h4><p>Здесь нужно кратко объяснить, <strong>для чего создан этот документ</strong> и какой продукт он описывает. Укажите    название системы, версию и границы ответственности SRS (вся система или только её часть).</p><h4>1.2 Document Conventions (Соглашения документа)</h4><p>Опишите правила оформления требований: нумерацию, ключевые слова, приоритеты, использование сокращения TBD (to be discussed).</p><h4>1.3 Intended Audience and Reading Suggestions (Целевая аудитория)</h4><p>Перечислите, для кого предназначен документ: разработчики, тестировщики, менеджеры,  заказчики. Можно указать, какие    разделы наиболее полезны каждой роли.</p><h4>1.4 Product Scope (Область применения продукта)</h4><p>Краткое описание продукта, его целей и бизнес-ценности. Здесь важно ответить на вопрос: <em>какую проблему решает        система</em>.</p><h4>1.5 References (Ссылки)</h4><p>Список связанных документов: vision & scope, контракты, стандарты, UX-гайды и другие источники, на которые опирается    SRS.</p><h3>2. Overall Description (Общее описание)</h3><h4>2.1 Product Perspective (Контекст продукта)</h4><p>Опишите, является ли система новой, частью существующей экосистемыили заменой старого решения. Полезно дать общее    текстовое или логическое описание окружения.</p><h4>2.2 Product Functions (Функции продукта)</h4><p>На высоком уровне перечислите ключевые функции системы. Это не детальные требования, а обзор возможностей продукта.</p><h4>2.3 User Classes and Characteristics (Классы пользователей)</h4><p>Опишите типы пользователей, их опыт, частоту использования и уровень доступа. Это поможет корректно формулировать    требования в дальнейшем.</p><h4>2.4 Operating Environment (Среда эксплуатации)</h4><p>Укажите, где будет работать система: ОС, устройства, браузеры, сторонние сервисы и ограничения среды.</p><h4>2.5 Design and Implementation Constraints (Ограничения)</h4><p>Здесь фиксируются все ограничения: технологические, регуляторные, корпоративные стандарты, обязательные инструменты    или языки.</p><h4>2.6 User Documentation (Пользовательская документация)</h4><p>Перечислите документацию, которая будет поставляться вместе с продуктом: руководства, справка, туториалы.</p><h4>2.7 Assumptions and Dependencies (Допущения и зависимости)</h4><p>Зафиксируйте предположения и внешние зависимости, которые могут повлиять на требования и сроки проекта.</p><h3>3. External Interface Requirements (Внешние интерфейсы)</h3><h4>3.1 User Interfaces (Пользовательские интерфейсы)</h4><p>Опишите требования к UI: экраны, стандарты, навигация, общие элементы и ограничения.</p><h4>3.2 Hardware Interfaces (Аппаратные интерфейсы)</h4><p>Требования к взаимодействию с оборудованием, если оно используется.</p><h4>3.3 Software Interfaces (Программные интерфейсы)</h4><p>Интеграции с другими системами, API, базами данных, форматы данных и протоколы взаимодействия.</p><h4>3.4 Communications Interfaces (Коммуникации)</h4><p>Описание сетевых протоколов, форматов сообщений,требований к безопасности и скорости передачи данных.</p><h3>4. System Features (Функциональные возможности)</h3><p>Этот раздел — сердце SRS. Здесь описываются функции системы, сгруппированные по фичам или сценариям.</p><h4>4.x System Feature</h4><ul>    <li><strong>Description and Priority</strong> — что делает функция и насколько она важна</li>    <li><strong>Stimulus/Response</strong> — последовательность действий пользователя и реакции системы</li>    <li><strong>Functional Requirements</strong> — детальные, атомарные и проверяемые требования</li></ul><p>Каждое требование должно быть:</p><ul>    <li>однозначным</li>    <li>проверяемым</li>    <li>необходимым</li>    <li>уникально идентифицированным</li></ul><h3>5. Other Nonfunctional Requirements (Нефункциональные требования)</h3><h4>5.1 Performance Requirements (Производительность)</h4><p>Временные отклики, нагрузка, масштабируемость и ограничения по ресурсам.</p><h4>5.2 Safety Requirements (Безопасность)</h4><p>Требования, связанные с предотвращением ущерба и рисков.</p><h4>5.3 Security Requirements (Информационная безопасность)</h4><p>Аутентификация, авторизация, защита данных и соответствие стандартам.</p><h4>5.4 Software Quality Attributes (Качества ПО)</h4><p>Надёжность, удобство использования, сопровождаемость, переносимость и другие атрибуты качества.</p><h4>5.5 Business Rules (Бизнес-правила)</h4><p>Правила, определяющие поведение системы с точки зрения бизнеса и ролей пользователей.</p><h3>6. Other Requirements (Прочие требования)</h3><p>Любые дополнительные требования, не вошедшие в предыдущие разделы.</p><h3>Appendices (Приложения)</h3><h4>Appendix A: Glossary</h4><p>Словарь терминов и сокращений, используемых в документе.</p><h4>Appendix B: Analysis Models</h4><p>Диаграммы, модели данных, состояния и другие аналитические материалы.</p><h4>Appendix C: To Be Determined List</h4><p>Список всех TBD, которые необходимо уточнить в будущем.</p><p><strong>Итог:</strong> использование шаблона IEEE для SRS позволяет создать чёткий, структурированный и понятный    документ, который служит надёжнойосновой для проектирования, разработки и тестирования программного обеспечения.</p>"
        },
        {
            "id": "12",
            "title": "Глава XII: Управление изменениями",
            "content": "<p>Знаете, я бы хотел написать об этом очень просто. К вам рано или поздно прибежит клиент, прямо когда вы пишите требования, прямо в середине спринта, и скажет, что ему срочно нужно внедрить какой-то функционал. Но разработчики уже заняты, тестировщики начали регресс следующей версии.</p><p>Вот мой пошаговый алгоритм: </p><ol><li>Со стейкхолдерами определить, что это вообще за требование;</li><li>Установить срок и приоритет, желательно сранивая с текщими задачами в текущем спринтe;</li><li>Пойти к команде разработке или тех лиду и получить оценку. Желательно подготовить несколько вариантов реализации и несколько оценок для них, чтобы предоставить стейкхолдерам альтернативу. Обязательно обозначить, какие потери понесет следующий спринт или релиз, насколько нужно будет перенести релиз;</li><li>Вместе со стейкхолдерами согласовать один из вариантов;</li></ol><p>Если не получилось договориться с первого раза, можно заново собраться с командой разработки и подготовить новые альтернативы.</p><p>Документация изменения ничем не отличается от документации любых других требований. В любом случае любые договоренности нужно документировать - прописывать в имейлах.</p>"
        }
    ]
}