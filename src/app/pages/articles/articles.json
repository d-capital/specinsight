{
    "articles": [
        {
            "id": "1",
            "title": "Глава I: Базовые концепции",
            "content": "<p>Чтобы начать изучение бизнесс-анализа, нам нужно сначала договориться о некоторых общих терминах, чтобы мы могли понимать друг друга.</p><h3>Стейкхолдеры</h3><p><b>Стейкхолдеры</b> — это любые люди или организации, которые могут оказать влияние на ваш продукт или проект или могут подвергнуться влиянию вашего продукта или проекта. Прежде всего, давайте их классифицируем.</p><p><i>Платящий стейкхолдер</i> — представитель компании, которая платит за ваш проект, например, владелец продукта или менеджер продукта (Product Owner, Product Manager), возможно менеджер проекта (Project Manager), который отвечает за бюджет и принимает решение о продолжении финансирования, он заинтересован в реальном бизнес-результате, потому что он платит деньги, и если результатов не будет — вас уволят. К этому же типу стейкхолдеров можно отнести акционеров компании, поскольку они могут покупать, держать или продавать акции и голосовать за решения в совете директоров в зависимости от финансовых результатов компании. Вероятно, они также могут позволить себе купить стейк (steak), но на английском стейкхолдер пишется по-другому (stakeholders).</p><p><i>SME (Subject Matter Expert)</i> — эксперт предметной области, сотрудник, который много знает о бизнесе или системе, может помочь в ней разобраться, он может более не быть связан с продуктом напрямую, но он много знает о продукте и может дать ответы на вопросы о том, как система сторилась и каковы были ожидания от той или иной функциональности.</p><p><i>Команда разработки</i> — они выполняют работу, очень важно информировать их о том, что на самом деле нужно и почему, это ваша работа как бизнес-аналитика.</p><p><i>Команда поддержки</i> — если она есть, люди, которые помогают пользователям использовать систему, исправляют конфигурацию. Им нужно знать, как функционирует продукт, чтобы они могли помогать пользователям.</p><p><i>Конечные пользователи</i> — это люди, которые, в конечном счете, принимают решение об использовании вашего продукта. Именно пользователи генерируют прибыль, и на основе их поведения <b>платящий стейкхолдер</b> определяет ваше будущее.</p><p><i>Правительство</i> — правительство не только требуют от вас платить налоги, но и постоянно придумывают новые правила, о которых вы должны знать, и они не будут вас об этом информировать, поэтому вам лучше следить за заголовками новостей, чтобы не оказаться в тюрьме или не заплатить большой штраф.</p><p><i>Активисты и лоббисты</i> — попробуйте подумать обо всех НКО, которые пытаются подать на вас в суд.</p><p><i>Конкуренты</i> — другие компании, разрабатывающие аналогичный продукт или работающие в том же направлении, которые могут переманить ваших клиентов.</p><p><i>Поставщики и продавцы</i> — другие компании, помогающие бизнесу, могут быть фактическими поставщиками товаров или услуг, например, таким поставщиком услуг можно назвать клининговую компанию, аудитора, других поставщиков ПО.</p><h3>Типы требований</h3><h4>Функциональные и нефункциональные</h4><p><i>Функциональные требования (Functional Requirements - FR)</i> — описание ожиданий того, как должна повести себя система, в основном, в тех случая, когда пользователь совершает какое-то действие. Если при обсуждении требований кто-то говорит вам, что пользователь вообще не вовлечен в процесс, то этот кто-то, скорее всего, не знает о чем он говорит.  Даже если есть автоматическое задание, которое запускается по графику, причиной существования этого задания является использование результатов этого задания пользователем. <i>Пример:</i> допустим, есть цены,  которые наша система извлекает из стороннего API и сохраняет их в базе данных раз в день — эти цены будут использоваться при расчете стоимости заказа, когда пользователь его сформирует.</p><p><i>Нефункциональные требования (Non-Functional Requirements - NFR)</i> — описание ожиданий относительно того, как система должна работать в програмной среде — это требования к производительности (страница должна открываться в течение 3 секунд,  эндпойнт должен быть способен обрабатывать  100 000 записей одновременно), требования к  програмному обеспечению  (приложение должно быть доступно на iOS и Android,  сайт должен работать в IE11  (пожалуйста, скажите мне, что таких требований больше нет)),  требования к переводу (сайт должен быть доступен на испанском языке  — это требование все еще считается нефункциональным, но возможность переключения между языками  уже является функциональным требованием,  поскольку требует внешнего воздействия — действия пользователя),  требования к UX — например, соответствие HIPPA (Health Insurance Portability and Accountability Act - скажем 'привет', типу стейкхолдеров <i>правительство</i>),  когда от вас требуется предоставить аудиочитаемую версию сайта.</p><h4>Бизнес-требования и Системные требования</h4><p><i>Требования стейкхолдеров</i> — плохо сформулированные (возможно даже неправильно сформулированные) фрагменты предложений и мыслей, которые должен обработать бизнес-аналитик. В основном это проблемы бизнеса (например, «Я не знаю, пользователи будто игнорируют нашу новую страницу с прогнозом погоды, можем ли мы сделать большую красную кнопку, которая вела бы их туда прямо с лендинга?»)</p><p><i>Бизнес-требования</i> — ваш домен, эти требования должны быть хорошо структурированы, должны описывать, как работает система. («добавьте кнопку в центр главной страницы, следуйте дизайну, описанному в Figma (ссылка на источник); только пользователи, подписанные на план B, могут видеть эту кнопку и эту страницу; когда пользователь нажимает на кнопку, он перенаправляется на страницу с прогнозом погоды и видит ...»; и т. д.).</p><p>Кстати, приведенные выше требрвания - это не шаблон, мы поговорим о лучших способах написания требований в будущих главах этого курса. Я хотел бы подчеркнуть, что создание прототипа определенно является частью бизнес-требований, это подготовка к выявлению требований, такая же как и написание критериев приемки и поиск пропущенных сценариев.</p><p><i>Системные требования</i> — описание взаимодействия компонентов системы в результате действий пользователя. В спецификации системных требований (System Requirements Specification - SRS) такие требования называют требованиями к внешнему интерфейсу и системным функциям. Это в основном описание того, как система должна работать с другими системами или как компоненты одной системы взаимодействуют друг с другом, например,если у вас есть API эндпойнт, работу которого нужно задокументировать, вам нужно определить тело запроса и ответа, для каждого поля в теле запроса и ответа вам нужно определить тип данных, длинну, если это применимо (например для строчного типа данных, для десятичного типа данных), является ли поле обязательным или нет, какие валидации существуют для поля. Если информация хранится в базе данных, необходимо определить сопоставление полей базы данных с полями в запросе. Если информация передается в другую систему или извлекается другой системой, вам нужно определить сопоставление ваших полей с полями сторонего приложения (например, если информация передается между двумя микросервисами). Если информация периодически должна обновляться, как часто это должно происходить? Если возвращается много данных, должен ли эндпойнт поддерживать пагинацию? Должно ли быть ограничение по частоте запросов (rate limit). Если есть несколько вызовов между несколькими системами, используйте нотации UML или BPMN для визуализации последовательности выполненных вызовов и ожидаемых ответов. Если в бизнес-требованиях указано несколько состояний бизнес-объектов, сделайте себе одолжение и создайте диаграмму переходов состояний (state transition diagram), чтобы найти отсутствующие состояния и триггеры, которые приводят к переходу из одного состояния в другое.<p><p>Существует множество других классификаций, которые можно взять из IEEE/ISO, BABOK или книги Карла Вигерса.</p><h3>Выявление требований</h3><p><i>Выявление или cбор требований</i> — это этап в процессе бизнесс-анализа, когда аналитик собирает требования и пытается понять, какие требования вообще существуют, прежде чем записывать их. Существует множество методов:<ul><li>Интервью со стейкхолдерами</li><li>Мозговой штурм со стейкхолдерами</li><li>Интервью с пользователями</li><li>Наблюдение за поведением пользователей</li><li>Создание прототипов</li><li>Обзор и анализ документации и законодательства</li></ul></p><h3>Персоны и роли пользователей</h3><p>Существуют различные группы пользователей, в UX их также называют персонами — чтобы обозначить социальные различия в группах пользователей, обычно в одном приложении выделяются разные роли пользователей — Обычный пользователь, Администратор, Пользователь с подпиской А, Пользователь с подпиской Б. Если мы говорим о персонах — мы говорим о демографическом описании — вот пользователь Тим, ему около 25 лет, у него хорошее здоровье и он зарабатывает меньше денег, Джиму 45–50, он регулярно ходит к врачу и у него больше сбережений, чем у Тима, и т. д.</p><h3>Глоссарий</h3><p>Это буквально то, что вы читаете сейчас, и он должен быть в каждом хорошем проекте — глоссарий общих терминов по проекту, чтобы все говорили на одном языке, это особенно полезно,когда стейкхолдеры используют разные термины для одного и того же бизнес-объекта.</p><h3>User Story (Пользовательская история)</h3><p>Это шаблон для написания требований, в котором обязательно должны присутствовать роль пользователя, требуемая функция и ценность, которую пользователь получит от этой функции. <i>Пример:</i> Как <b><i>администратор приложения</i></b>, я хочу иметь возможность <b><i>добавлять статьи на главную страницу приложения</b></i>, чтобы <b><i>пользователь мог их прочитать</b></i>.</p><h3>Use Case</h3><p>Вариант использования системы — сценарий с пользовательским вводом и последовательностью действий системы, которые происходят из-за этого ввода.    <ol>        <li>Пользователь открывает главную страницу</li>        <li>Пользователь видит большую красную кнопку</li>        <li>Пользователь нажимает большую красную кнопку</li>        <li>Пользователь перенаправляется на такую-то страницу</li>    </ol></p><h3>Приемочное тестирование (Acceptance Testing)</h3><p>Тестирование, проводимое аналитиком перед развертыванием функционала в среде (environment), доступной заказчику или пользователю (PROD, UAT, Stage — существует множество названий для таких сред)</p><h3>Приемочное тестирование пользователем (User Acceptance Testing)</h3><p>Тестирование, проводимое пользователями в специально предназначенной для этого среде. Такая среда как раз может называться UAT или Stage.</p><h3>Release Notes</h3><p>Вместе с релизом в PROD стейкхолдерам отправляют документ, в котором перечислены все изменения, внесенные в релиз.</p><h3>Базовая документация</h3><p>Это статьи на wiki, Confluence, Sharepoint или любом другом инструменте, который может хранить общую информацию о функциональности продукта. Такая документация обязательно должна существовать, если ее нет, задача бизнесс аналитика будет заключаться в том, чтобы ее создать и поддерживать, она должна включать обзор проекта, диаграммы и схемы архитектуры.</p>"
        },
        {
            "id": "2",
            "title": "Глава II: Что такое хорошие требования?",
            "content": "<section><p>Требования — это фундамент любого проекта разработки. От их качества напрямую зависит успех реализации: сроки, бюджет и соответствие конечного продукта ожиданиям заказчика. В эпоху ИИ требования становятся еще важнее - теперь этот текст зачастую воспринимает не разработчик, а большая языковая модель, чем лучше будут тербования, тем лучше будет результат, инженеру останется больше времени для проектирования системы. В этой главе мы разберём, что делает требования «хорошими», опираясь на авторитетные источники: книгу Карла Вигерса «Разработка требований к ПО», стандарты IEEE/ISO, а также методики INVEST и SMART.</p></section><section>    <h2>Определение требования</h2> <p>В стандарте <strong>ISO/IEC/IEEE 29148:2011 4.1.17</strong> требования определяются как утверждение, которое толкует или выражает потребность, а также связанные с ней ограничения и условия (\"statement which translates or expresses a need and its associated constraints and conditions\").</p></section><section> <h2>Критерии хороших требований (по Карлу Вигерсу, глава 5)</h2>    <p>Карл Вигерс в книге «Разработка требований к программному обеспечению» выделяет следующие ключевые характеристики        качественных требований:</p>    <ul>        <li><strong>Единичность</strong> — требование описывает одну и только одну вещь.</li>        <li><strong>Завершённость</strong> — содержит всю необходимую информацию для понимания и реализации.</li>        <li><strong>Последовательность</strong> — не противоречит другим требованиям и документации.</li>        <li><strong>Атомарность</strong> — неделимо на более мелкие требования без потери смысла.</li>        <li><strong>Отслеживаемость</strong> — можно проследить связь с бизнес-целями и другими артефактами проекта.        </li>        <li><strong>Актуальность</strong> — остаётся релевантным на протяжении жизненного цикла проекта.</li>        <li><strong>Выполнимость</strong> — технически реализуемо в рамках заданных ограничений.</li>        <li><strong>Недвусмысленность</strong> — формулировка не допускает разночтений.</li>        <li><strong>Проверяемость</strong> — существует способ проверить выполнение требования.</li>    </ul></section><section>    <h2>Методика INVEST: критерии пользовательских историй</h2>    <p>Для Agile-подходов популярна методика <strong>INVEST</strong>, предложенная Биллом Уэйком. Она задаёт критерии        качества пользовательских историй:</p>    <ul>        <li><strong>I (Independent)</strong> — независимость: история не должна зависеть от других историй.</li>        <li><strong>N (Negotiable)</strong> — обсуждаемость: описание — не контракт, а повод для обсуждения.</li>        <li><strong>V (Valuable)</strong> — ценность: приносит пользу пользователю или бизнесу.</li>        <li><strong>E (Estimable)</strong> — оцениваемость: можно оценить трудозатраты.</li>        <li><strong>S (Small)</strong> — компактность: достаточно мала для реализации в одном спринте.</li>        <li><strong>T (Testable)</strong> — проверяемость: есть критерии приёмки.</li>    </ul></section><section>    <h2>Метод SMART: критерии формулировки требований</h2>    <p>Принцип <strong>SMART</strong> помогает сформулировать требования так, чтобы они были пригодны для реализации:    </p>    <ul>        <li><strong>S (Specific)</strong> — конкретность: чёткое описание, что нужно сделать.</li>        <li><strong>M (Measurable)</strong> — измеримость: есть критерии проверки выполнения.</li>        <li><strong>A (Achievable)</strong> — достижимость: технически реализуемо.</li>        <li><strong>R (Relevant)</strong> — актуальность: соответствует бизнес-целям.</li>        <li><strong>T (Time-bound)</strong> — ограниченность по времени: понятны сроки реализации.</li>    </ul></section><section>    <h2>Как понять, что требования готовы к передаче в разработку</h2>    <p>Перед передачей требований команде разработки проведите чек-лист проверки:</p>    <ol>        <li><strong>Полнота</strong>: все ли сценарии и граничные случаи учтены?</li>        <li><strong>Ясность</strong>: поймёт ли разработчик требование без дополнительных вопросов?</li>        <li><strong>Согласованность</strong>: нет ли противоречий с другими требованиями?</li>        <li><strong>Приоритеты</strong>: определены ли приоритеты (например, можно использовать технику MoSCoW: Must have, Should have, Could            have, Won't have, или просто High, Medium, Low)?</li>        <li><strong>Критерии приёмки</strong>: есть ли чёткие условия, по которым можно проверить выполнение?</li>        <li><strong>Зависимости</strong>: учтены ли внешние системы или компоненты?</li>        <li><strong>Риски</strong>: идентифицированы ли потенциальные проблемы реализации?</li>    </ol></section><section>    <h2>Типичные ошибки в требованиях</h2>    <ul>        <li>Неоднозначные формулировки. <i>Пример: </i> «пользователь должен легко найти…» - здесь не ясно что значит легко, каков критерий легкости?.</li><li>Требования-решения вместо требований-целей. <i>Пример: </i> «В новом поле в базе данных в таблице Orders конкатенируйте поля Id и ShortCode через дефис…» - зачем нужно это поле в базе, может нужно просто отдавать его в ответе API? Или даже просто показывать в пользовательском интерфейсе?</li>        <li>Отсутствие критериев проверки. <i>Пример: </i>«система должна быть быстрой» - про что это требование? Может быть про открытие страницы, насколько быстро в таком случае она должна открываться - 3 минуты, 3 секунды? При каком количестве одновременных пользователей? </li>        <li>Избыточная детализация на раннем этапе.</li>        <li>Несогласованность с бизнес-целями.</li>    </ul></section><section>    <p>Хорошие требования — это баланс между детализацией и гибкостью, точностью и понятностью. Опираясь на стандарты        IEEE/ISO, подходы Вигерса, INVEST и SMART, можно создать основу для успешной разработки:</p>    <ul>        <li>Проверяйте требования по критериям качества.</li>        <li>Вовлекайте команду в обсуждение для устранения неясностей.</li>        <li>Документируйте критерии приёмки.</li>        <li>Поддерживайте актуальность требований в процессе разработки.</li>    </ul>    <p>Только качественно сформулированные требования позволяют минимизировать риски, сократить затраты и создать        продукт, который действительно решает задачи пользователей.</p></section>"
        },
        {
            "id": "3",
            "title": "Глава III: Что делать на новом проекте?",
            "content": "<section><p>Начало работы над новым проектом — критический этап для бизнес‑аналитика. Перед вами — чёткий план действий на старте.</p></section><section><h3>Шаг 1. Анализ стейкхолдеров</h3>    <p>Aнализ стейкхолдеров позволяет:</p>    <ul><li>определить ключевые источники требований;</li>        <li>выстроить коммуникацию;</li>        <li>предвосхитить конфликты интересов;</li>        <li>распределить ответственность.</li>    </ul>    <h4>Как провести анализ</h4>    <ol>        <li><strong>Идентификация.</strong> Составьте список всех возможных стейкхолдеров: заказчики, пользователи, регуляторы, команда, смежные подразделения. Простого списка будет вполне достаточно. С именами и позициями вам может помочь ваше контакое лицо по проекту, лучше всех будет знать SME, но для этого его нужно идентифицировать.</li>        <li><strong>Классификация.</strong> Разделите стейкхолдеров на группы:            <ul>                <li>внутренние / внешние;</li>                <li>первичные (прямое влияние) / вторичные;</li>                <li>поддерживающие / сопротивляющиеся.</li>            </ul>    <p>Для классификации первичных и вторичных стейкхолдеров очень хорошо подойдет Onion-диаграмма</p><img width=\"500px\" height=\"500px\" alt=\"Example of onion diagram\" src=\"onion.png\"><p><i>Пример Onion-диаграммы</i></p>    </li>        <li><strong>Оценка интересов и влияния.</strong> Используйте Power Interest Grid для того, чтобы выбрать стартегию поведения со стейкхолдером: <table border=\"1rem\" cellpadding=\"5\">                <tr><th>Stakeholder</th><th>Power</th><th>Interest</th><th>Strategy</th></tr><tr><th>Buying customer</th><th>High Power</th><th>High interest</th><th>Manage closely</th></tr><tr><th>Platform holder</th><th>Low Power</th><th>Low interest</th><th>Monitor</th></tr><tr><th>Enduser</th><th>High Power</th><th>Low interest</th><th>Keep satisfied</th></tr><tr><th>Development team</th><th>Low Power</th><th>High interest</th><th>Keep informed</th></tr></table><p><img width=\"500px\" height=\"500px\" alt=\"Example of Power Interest Grid\" src=\"powerinterest.png\"></p><p><i>Пример Power Interst Grid</i></p> </li>        <li><strong>Планирование взаимодействия.</strong> Выделите для себя ключевых стейкхолдеров и определите как часто и каким образом вы будете с ними общаться, будет ли это на регулярных общих встречах, 2 раза в неделю на рефайнментах бэклога, или каждую неделю на 1-1, нужно ли приглашать менеджера заказчика на ежедневные встречи, нужно ли отправлять отчеты и если да, то в какой форме их принято отправлять. Все это можно выявить на личных встречах. </section><section>    <h3>Шаг 2. Создание глоссария</h3><p>Глоссарий — словарь терминов проекта. Он устраняет разночтения и ускоряет коммуникацию. Первая глава наглядно иллюстрирует такого рода глоссарий.</p>    <h3>Что включать</h3>    <ul>        <li>отраслевые термины (например, «лид», «конверсия» в маркетинге);</li>        <li>названия систем и модулей;</li>        <li>аббревиатуры и сокращения;</li>        <li>специфические для компании понятия.</li>    </ul>    <h3>Как составлять</h3>    <ol>        <li>Выделите термины из первых интервью и документов.</li>        <li>Согласуйте определения со стейкхолдерами.</li>        <li>Укажите синонимы и примеры использования.</li>        <li>Обновляйте по мере появления новых понятий.</li>    </ol>  </section><section>    <h3>Шаг 3. Базовая документация</h3>    <p>На старте сформируйте минимальный набор документов. Он станет фундаментом для дальнейшей работы.</p><h3>Обязательные документы</h3><ol><li><strong>Устав проекта</strong> <p>Кратко отвечает на вопросы:</p><ul><li>Зачем проект нужен? (цели, бизнес‑ценность)</li><li>Что будет сделано? (границы, результаты)</li><li>Кто участвует? (в принципе, работа по анализу стейкхолдеров закрывает этот пункт)</li><li>Когда? (сроки, этапы, примерный roadmap, если есть, если нет, его нужно выяснить у стейкхолдеров)</li><li>Какие есть ограничения? (бюджет, ресурсы)</li></ul>  <p>Eсли у вас в команде есть архиткетор, или опытный тех лид, возможно SME с техническим бэкграундом, свяжитесь с ним и нарисуйте диаграмму продукта и его взаимосвязи с другими продуктами, например, можно использовать нотацию С4 для описания архитектуры системы.</p>      </li>        <li>            <strong>Список требований (Baseline Requirements)</strong>            <p>Таблица с требованиями. Колонки:</p>            <ul>                <li>ID требования;</li><li>Заголовок;</li><li>Описание</li><li>Критерии приемки</li></ul><p>Таблица с требованиями должна копировать все требования из тикетов в вашей системе управления проектом, которые уже были задеплоены в прод. Вы можете организовать ее в wiki, Conflunce, Sharepoint, Word, Git - репозитории, главное чтобы они были в едином месте, так удобнее понимать текущее состояние проекта, еще лучше было бы отслеживать в этом же документе, как одни требования отменяют или расширяют другие. Конечно, не обязательно копировать требования дословно, можно суммаризировать их и делать более короткими.</p> </li>        <li>            <strong>Протокол встреч (Meeting Minutes)</strong>            <p>После каждой встречи всегда фиксируйте:</p>            <ul>                <li>дату и участников;</li>                <li>ключевые решения;</li>                <li>действия и ответственных;</li>                <li>открытые вопросы.</li>            </ul><p>Теперь ИИ ассистенты могу делать большую часть такой работы за вас, так что не теряйте шанс использовать их.</p></li>        <li>            <strong>Риски и проблемы (Risk Log)</strong>            <p>Таблица с колонками:</p>            <ul>                <li>Описание риска;</li>                <li>Вероятность наступления - выскоая, средняя, низкая;</li>                <li>Степень влияния на проект - высокая, средняя,низкая;</li>                <li>Меры - описание мероприятий для предотвращения или снижения риска;</li>                <li>Ответственный;</li>            </ul>        </li>    </ol>    <div >        <strong>Совет:</strong> Не стремитесь к идеальности на старте. Документы должны быть «живыми» — обновляйте их по мере поступления информации, показывайте их другим участникам команды для обсуждения.    </div></section><section>    <h2>Чек-лист первых 2 недель</h2>    <p>Чтобы не упустить важное, следуйте плану:</p>    <ol>        <li>Проведите вводные встречи с ключевыми стейкхолдерами.</li>        <li>Составьте первичный список стейкхолдеров и матрицу влияния.</li>        <li>Начните заполнять глоссарий на основе первых обсуждений.</li>        <li>Оформите устав проекта (даже в черновике).</li>        <li>Заведите список требований — внесите первые 5–10 пунктов.</li>        <li>Фиксируйте все встречи и решения в протоколах.</li>        <li>Идентифицируйте ключевые риски.</li>    </ol></section>"
        },
        {
            "id": "4",
            "title": "Глава IV: Выявление требований",
            "content": "<p>Выявление требований - это прежде всего набор техник и приемов для получения требований, часто аналитик противопостоавляют этот термин термину сбор, так как требования не растут из земли и их иногда приходится добывать с трудом. В этой главе мы подробнее остановимся на четырех основных методах выявления требований и дадим практические рекомендации по их применению.</p><section><h3>1. Интервью</h3>    <div>        <p><strong>Суть:</strong> персональное общение с заинтересованными сторонами для получения информации о            потребностях, проблемах и ожиданиях.</p>        <p><strong>Когда применять:</strong> при работе с ключевыми стейкхолдерами. Это самый простой и в то же время самый надежный способ, который можно применить почти всегда. </p>    </div>    <h3>Как проводить эффективно</h3>    <ol>        <li>Подготовьтесь: изучите контекст, составьте список вопросов.</li><li>Начните с открытых вопросов («Расскажите, как вы сейчас решаете эту задачу?»).</li>        <li>Используйте уточняющие вопросы («Почему это важно?», «Что произойдёт, если…»).</li>   <li>Лучше иметь предмет разговора перед глазами, если есть готовое приложение, сайт, прототип, референс конкурента, документ или график, обязательно покажите его на своем экране или попросите стейкхолдера показать свой экран с примером.</li>     <li>Фиксируйте не только ответы, но и вашу оценку ответов, вам может показаться, что человек не уверeн в своем суждении, тогда этот момент стоит верифицировать с другими стейкхолдерами.</li>   <li>Обязательно спрашивайте о приоритетах и сроках - это не обязательно расплывчатые High, Medium, Low, приоритеты это скорее даты, которые ваши стейкхолдеры уже пообщеали своим стейкхолдерам, например, их новый клиент начнет работу с приложением в мае этого года, так что, если сейчас апрель все остальные фичи будут менее приоритетными</li>     <li>В конце резюмируйте ключевые тезисы, после встречи составьте протокол и разошлите его участникам, обязательно проговорите нужна ли последующая встреча.</li>    </ol>    <div>        <strong>Совет:</strong> избегайте наводящих вопросов. Вместо «Вам ведь нужен экспорт в Excel?» спросите: «В        каких форматах вам приходится обмениваться данными?»    </div></section><section>    <h3>2. Воркшопы</h3>  <div><p><strong>Суть:</strong> групповые сессии с участием нескольких стейкхолдеров для совместного выявления и обсуждения требований.</p><p><strong>Когда применять:</strong> при сложных проектах, необходимости согласования позиций, генерации идей.</p>    </div>    <h4>Преимущества</h4>    <ul>        <li>Экономия времени (одновременный сбор мнений от нескольких участников).</li>        <li>Возможность сразу разрешить противоречия.</li>        <li>Генерация новых идей благодаря участию стейкхолдеров из разных потоков бизнеса.</li>    </ul>  <p>По большом счету это просто массовое интервью, но так как участников много, нужна четкая агенда перед глазами.</p>   <div>        <strong>Совет:</strong> подготовьте виртуальную доску и отмечайте прогресс агенды на ней.</div></section><section>    <h3>3. Прототипы</h3>    <div> <p><strong>Суть:</strong> создание упрощённых моделей продукта (интерфейсов, процессов) для визуализации идей и получения обратной связи. Кроме того, когда вы создаете прототип и начинает продумывать состояния и переходы между ними, можно найти недостоющие и непродуманные состояния и выявить требования таким образом</p>        <p><strong>Когда применять:</strong> для уточнения требований к интерфейсам, проверки гипотез, демонстрации концепций.</p>    </div>    <h4>Виды прототипов</h4>    <ul>        <li><strong>Бумажные</strong> — быстрые наброски от руки.</li>        <li><strong>Интерактивные</strong> — кликабельные макеты (например, в Figma).</li>        <li><strong>Функциональные</strong> — рабочие версии с базовым функционалом.</li>    </ul>    <h3>Как использовать</h3>    <ol>        <li>Создайте прототип на основе первичных требований.</li>        <li>Проведите демонстрацию стейкхолдерам.</li>        <li>Соберите обратную связь: что непонятно, что нужно изменить.</li>        <li>Итерируйте: улучшайте прототип до согласования.</li>    </ol>    <div>        <strong>Совет:</strong> не вкладывайте слишком много времени в детализацию раннего прототипа — его цель: быстро        получить обратную связь.    </div><p><a href=\"https://www.youtube.com/watch?v=kbZejnPXyLM&pp=ygUMZmlnbWEgY291cnNl\" target=\"blank\">Ссылка на курс по Figma</a></p><p>Конечно, никто не запрещает делать прототип в Cursor App в эпоху ИИ.</p></section><section>    <h3>4. Анализ документации</h3>    <div>        <p><strong>Суть:</strong> изучение существующих документов для выявления требований и контекста.</p>        <p><strong>Когда применять:</strong> в начале проекта, при модернизации систем, для понимания текущих процессов.        </p>    </div>    <h3>Какие документы анализировать</h3>    <ul>        <li>Бизнес‑планы и стратегии.</li>        <li>Описания текущих процессов (BPMN, текстовые регламенты).</li>        <li>Техническая документация систем.</li>        <li>Отчёты и аналитика (KPI, метрики).</li>        <li>Предыдущие требования и ТЗ.</li>        <li>Пользовательское руководство и FAQ.</li>    </ul>    <h3>Алгоритм анализа</h3>    <ol>        <li>Составьте список источников.</li>        <li>Выделите ключевые термины и процессы.</li>        <li>Найдите противоречия и пробелы.</li>        <li>Сформулируйте вопросы для уточнения.</li>        <li>Зафиксируйте выявленные требования.</li>    </ol>    <div>        <strong>Совет:</strong> создайте глоссарий на основе терминологии из документов — это снизит риск разночтений.    </div></section>    <h3>Частые ошибки и как их избежать</h3>    <ul>        <li>            <strong>Запись пожеланий, а не потребностей:</strong>            <p>Стейкхолдеры часто формулируют решения («хочу кнопку красного цвета»), а не проблему. </p>            <p><em>Как избежать:</em> задавайте уточняющие вопросы: «Зачем это нужно?», «Какую задачу это решает?», «Что                будет, если этого не сделать?»</p>        </li>        <li>            <strong>Отсутствие валидации:</strong>            <p>Требования зафиксированы, но не проверены на реалистичность и согласованность.</p>            <p><em>Как избежать:</em> после сбора требований проведите ревью со стейкхолдерами, смоделируйте сценарии                использования.</p>        </li>        <li>            <strong>Игнорирование нефункциональных требований:</strong>            <p>Фокус только на функционале, без учёта производительности, безопасности, удобства использования.</p>            <p><em>Как избежать:</em> Составьте список вопросов по нефункциональным требованиям (Сколько запросов может случиться за день/час/минуту? Какое максимальное колличество строк в запросе? Ожидает ли партнерская система синхронный или асинхронный ответ? Должна ли быть логика повтороной отправки? Сколько раз пробовать переотправлять упавший запрос? Как быстро должна загружаться страница? и так далее).</p>        </li>        <li>            <strong>Слишком общие формулировки:</strong>            <p>«Система должна работать быстро», «Интерфейс должен быть удобным» — невозможно проверить.</p>            <p><em>Как избежать:</em> конкретизируйте: «Время отклика системы — не более 2 сек при нагрузке до 1000                пользователей».</p>        </li>        <li>            <strong>Недооценка влияния изменений:</strong>            <p>Новые требования не анализируются на совместимость с существующими процессами и системами.</p>            <p><em>Как избежать:</em> создайте диаграмму процесса учитывая нижестоящие системы (например используя BPMN, или UML диаграмму последовательности).</p>        </li>        <li>            <strong>Отсутствие приоритизации:</strong>            <p>Все требования считаются одинаково важными, что ведёт к перегрузке разработки.</p>            <p><em>Как избежать:</em> спрашивайте о сроках поставки, если же вышло так что все фичи стали срочными и приоритетными, а команда разработки перегружена, нужно приоретизировать уже применяя специализированные техники -  (например, MoSCoW, Cost Of Delay).</p>        </li>        <li>            <strong>Недокументирование источников:</strong>            <p>Неясно, кто и почему выдвинул требование, что затрудняет дальнейшие уточнения.</p>            <p><em>Как избежать:</em> фиксируйте в списке требований: стейкхолдера, дату, контекст.</p>        </li>        <li>            <strong>Пропуск граничных случаев:</strong>            <p>Учитываются только «идеальные» сценарии, игнорируются ошибки, исключительные ситуации.</p>            <p><em>Как избежать:</em> моделируйте негативные сценарии («Что, если пользователь введёт некорректные                данные?»).</p>        </li>        <li>            <strong>Чрезмерная детализация на раннем этапе:</strong>            <p>Попытка описать все нюансы до утверждения концепции ведёт к потере времени.</p>            <p><em>Как избежать:</em> сначала зафиксируйте высокоуровневые требования, затем углубляйтесь в детали.</p>        </li>        <li>            <strong>Отсутствие обратной связи:</strong>            <p>Требования переданы команде без планирования.</p>            <p><em>Как избежать:</em> команда разработки должна планировать истории вместе с вами, помните, что вы не можете знать всего, их вклад в требования очень ценен. Если вы не хотите отрывать всю команду можно попросить провести предварительный разговор с тех лидом и одним из наиболее опытных тестировщиков.</p>        </li>    </ul></section><section>    <h2>Заключение</h2>    <p>Выявление требований — это не разовое действие, а итеративный процесс. Чтобы минимизировать ошибки:</p>    <ol>        <li>Комбинируйте методы (интервью + прототипы + анализ документов).</li>        <li>Фиксируйте всё письменно.</li>        <li>Регулярно валидируйте требования со стейкхолдерами.</li>        <li>Будьте гибкими: допускайте корректировку по мере поступления новой информации.</li>        <li>Используйте шаблоны и чек‑листы для систематизации работы.</li>    </ol>  </section>"
        },
        {
            "id": "5",
            "title": "Глава V: Приоретизация требований",
            "content": "<section><p>В любом проекте ресурсы ограничены: время, бюджет, команда. Приоритизация помогает определить, какие задачи принесут наибольшую пользу и должны быть реализованы в первую очередь. Конечно, классическим способом приоретизации является установление сроков, если какая-то задача должна быть выпущена к определенному сроку приоретизировать ее гораздо проще. Баги из прода с большим потенциальным или реальным воздействием всегда приоритетнее новых задач. Методы приоретизации, предложенные ниже, скорее подойдут для разработки MVP, когда приоритеты конкурируют друг с другом и скоуп нужно сокращать. </p></section><section><h3>Метод MosCoW</h3><p>MosCoW — это метод категоризации требований на четыре группы:</p><ul><li><strong>MUST have</strong> — обязательные требования, без которых проект не будет успешным</li><li><strong>SHOULD have</strong> — важные требования, но не критичные</li><li><strong>COULD have</strong> — желательные требования, которые можно отложить</li><li><strong>WON'T have</strong> — требования, которые не будут реализованы в текущей версии</li></ul><h4>Когда использовать?</h4><p>Идеально подходит для проектов с фиксированными сроками и бюджетом, где нужно четко определить минимальныйжизнеспособный продукт (MVP).</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> простота, понятность, быстрое внедрение</p><p><strong>Минусы:</strong> субъективность, отсутствие количественных метрик</p></section><section><h3>Cost of Delay (Цена простоя)</h3><p>Cost of Delay оценивает финансовые потери от задержки реализации фичи.</p><p>Cost of Delay можно посчитать как доход от фичи за едницу времени умноженный на колличество единиц времени, необходимых на имплементацию. <i>Например: </i> у вас есть баг, который ломает отправку заказов, в день на заказах компания зарабатывает $10 000. Команда разработки говорит, что сможет пофиксить баг за 2 дня, <b>Cost of Delay = $10 000 x 2 = $20 000</b>.</p><p>Есть также другая метрика на основе Cost of Delay - CD3. CD3 считается как доход от фичи в еденицу времени деленный на колличество едниц времени, необходимых на имплементацию. CD3 позволяет определить, какой из багов приоритетнее. <i>Пример: </i> Есть баг в проде , который ломает отправку заказов, в день на заказах компания зарабатывает $10 000. Команда разработки говорит, что сможет пофиксить баг за 2 дня. Назовем его Баг А. Есть Баг Б, который не позволяет показывать рекламу на сайте, в день сайт теряет $4 000 из-за этого. Команда разработки говорит, что может пофиксить этот баг за четверь дня (2 часа). <b>Cost of delay Бага А = $20000</b>. <b>Cost of delay Бага Б = $1000</b>. <b>СD3 Бага А = $10 000/ 2 = 5 000.</b> <b>СD3 Бага Б = $4 000 / 0.25 = 16 000</b>. Получается, что если выбирать по этому показателю, первым нужно фиксить Баг Б, его фикс быстрее вернет выручку.</p><h4>Когда использовать?</h4><p>Особенно полезен в коммерческих проектах, где важны финансовые показатели и ROI, и, что самое главное, там, где эти данные есть.</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> объективные численные данные, фокус на бизнес-ценности.</p><p><strong>Минусы:</strong> сложность расчетов, требует точных данных.</p></section><section><h3>Метод RICE</h3><p>RICE — система оценки, учитывающая четыре фактора:</p><ul><li><strong>Reach (Охват)</strong> — сколько пользователей затронет функция</li><li><strong>Impact (Влияние)</strong> — насколько сильно функция повлияет на каждого пользователя</li><li><strong>Confidence (Уверенность)</strong> — насколько точны наши оценки</li><li><strong>Effort (Усилия)</strong> — сколько времени/ресурсов потребуется</li></ul><p>Формула: <em>RICE Score = (Reach × Impact × Confidence) / Effort</em></p><h4>Когда использовать?</h4><p>Для продуктов с большим количеством пользователей, где важны метрики вовлеченности.</p><h4>Преимущества и недостатки</h4><p><strong>Плюсы:</strong> комплексный подход, учитывает несколько факторов</p><p><strong>Минусы:</strong> требует сбора данных, может быть переусложнен</p></section><section><h3>Story Mapping</h3><p>Визуальный метод организации пользовательских историй вдоль оси пользовательского пути.</p><img width=\"1000px\" height=\"500px\" src=\"storymap.png\"><p><i>Пример Story Map в Figma</i></p></section><section><h2>Как выбрать подходящий метод?</h2><table border='1' cellpadding='8' cellspacing='0'><tr><th>Метод</th><th>Лучше всего подходит для</th><th>Сложность внедрения</th></tr><tr><td>MosCoW</td><td>Проектов с фиксированными сроками, MVP</td><td>Низкая</td></tr><tr><td>Cost of Delay</td><td>Коммерческих проектов, где важен ROI</td><td>Высокая</td></tr><tr><td>RICE</td><td>Продуктов с метриками пользователей</td><td>Средняя</td></tr></table></section><section><h2>Практические советы по приоритизации</h2><ol><li>Начинайте с простых методов и переходите к сложным по мере необходимости</li><li>Вовлекайте ключевых стейкхолдеров в процесс приоритизации</li><li>Регулярно пересматривайте приоритеты — они могут меняться</li><li>Не забывайте о техническом долге и нефункциональных требованиях</li></ol></section><section><p>Не существует универсального 'лучшего' метода приоритизации. Выбор зависит от контекста проекта и доступных данных. Ключ к успеху — системный подход и регулярный пересмотр приоритетов по мере поступленияновой информации. Экспементируйте с разными методами, адаптируйте их под свои нужды.</p></section>"
        },
        {
            "id": "6",
            "title": "Глава VI: Документация требований",
            "content": "<p>Давайте рассмотрим самые популярные форматы документации требований - User Story, Use Case, BPMN и UML диаграммы, а так же Entity Relation диаграмму.</p><section>    <h3>1. User Stories (пользовательские истории)</h3>    <p>Краткие описания функциональности с точки зрения пользователя. Основной формат в Agile‑разработке.</p>    <h4>Структура</h4>    <p>«Как <em>[роль пользователя]</em>, я хочу <em>[функционал]</em>, чтобы <em>[получать выгоду]</em>». («As a <em>[role]</em>, I want to <em>[feature]</em>, so that <em>[value]</em>. »)</p>    <p><strong>Пример:</strong> «Как покупатель, я хочу фильтровать товары по цене, чтобы быстрее находить подходящие        варианты».</p>    <h4>Когда применять</h4>    <ul>        <li>В итеративной разработке (Scrum, Kanban).</li>        <li>При необходимости быстрой приоритизации требований.</li>        <li>Для коммуникации с нетехническими стейкхолдерами.</li>    </ul>    <h4>Плюсы и минусы</h4>    <p><strong>Плюсы:</strong> простота, фокус на ценности для пользователя, гибкость.</p>    <p><strong>Минусы:</strong> недостаточная детализация для сложных сценариев, риск неоднозначности.</p></section><section> <h4>Основные ошибки</h4><ul><li>Невалидная роль - я часто вижу как аналитики пишут «Как менеджер продукта, я хочу». Менеджер продукта это не роль в приложении, роль в приложении, это какой-то пользователь. Даже если кажется, что пользователя нет, а потребителем является сторонняя система, в сторонней системе есть это пользователь, который чего-то от системы ожидает. Так же стоит сказать, что в истории можно перечиcлить нескольких пользователей.</li><li>Отсутствие ценности - аналитики часто пропускают часть с описанием ценности, чем абсолютно дискредитируют концепт. Прописываение ценности - это тоже элемент анализа - он заставляет вас задуматься еще раз, этой ли фичи хочет пользователь. Ценность также придает работе программистов какой-то смысл, а так же позволяет предложить альтернативные решения. Давайте сравним историю с ценностью и без ценносьти. «Как администратор каталога, я хочу иметь возможность изменять доступное колличество товаров на складе». У меня сразу возникают вопросы - зачем давать такую возможность, нету интеграции со складской системой? Откуда администратору знать сколько продуктов на складе? Тепрь давайте добавим ценность. «Как администратор каталога, я хочу иметь возможность изменять доступное колличество товаров на складе, чтобы исправлять ошибки интеграции со складом». А, тут все понятно, то есть интеграция со складом есть, но, видимо, есть ошибки, просчеты или периодические даунтаймы на стороне складской системы, поэтому нужно иметь возможность поправить колличество вручную. </li></ul> <p>Я хочу отметить, что одной только истории будет недостаточно для того, чтобы передать требования в разработку. Обычно я включаю так же тезисное описание функциональных требований и критерии приемки в формате пошаговых тестовых сценариев.</p> <p><i>Пример моих требований:</i></p><p>Как <b><i>пользователь каталога</i></b>, я хочу <b><i>получать сообщения о поступлении товара на склад</i></b>, чтобы я мог <b><i>начать заказывать товар со склада</i></b>.</p> <p><b><i>Требования:</i></b></p> <p><ol><li>Для получения информации о поступлении товара каталог будет используется существующий API `GET api/receipt`, необходимо расширить ответ этого API, чтобы каталог мог сохранить информацию о приеме товара к себе.</li><li>Недостающие поля: <ul><li>expectedQuantity - источник в базе `DatabaseName.PurchaseOrder.Quantity`</li><li>productName - источник в базе `DatabaseName.Item.ProductName`</li><li>purchaseOrderNumber - источник в базе `DatabaseName.PurchaseOrder.OrderNumber`</li></ul></li><li>Пример ответа на запрос c новыми полями: <pre><code>{<br>\"recordsFound\":10,<br>\"recordsOnPage\":10,<br>\"pageNumber\":0,<br>\"totalPages\":1,<br>\"receipts\":<br>[<div style=\"margin-left: 50px;\">{<br>\"id\":1,<br>\"receivedQuantity\":10,<br>\"expectedQuantity\":10,<br>\"productName\":\"T-Shirt\",<br>\"purchaseOrderNumber\":\"PO123456\",<br>\"purchaseOrderLine\":1<br>}</div>]}</code></pre></li></ol><p></p></p><p><b><i>Критерии приемки</i></b><ol><li>Ответ на запрос новых поступлений товара содержит новые поля<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = 'T-Shirt', на 10 штук, номер заказа 'PO123456', строка заказа номер 1 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123456', номер строки 1, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = 'T-Shirt', для заказа 'PO123456', строки 1, с expectedQuantity = 10, receivedQuantity=10</p></li><li>Поступление на товар без названия<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = null, на 12 штук, номер заказа 'PO123457', строка заказа номер 2 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123457', номер строки 2, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = null, для заказа 'PO123457', строки 2, с expectedQuantity = 12, receivedQuantity=10</p></li></ol></p><p>Я бы хотел отметить что эти требования пример того, как работает аналитик внутри гибких методолгий, эндпойнт уже есть, он описан в предыдущих требованиях, есть валидации для эндпойнта `POST api/receipt`, все это не касается этого тербования, здесь мы расширяем существующий ответ запроса, так как к нам пришел новый клиент, и ему нужны новые поля, чтобы интегрироваться с нами. Ну и конечно, в требованиях могут быть ошибки и неточности, пропущенные сценарии, но у аналитика есть мощный инструмент для работы с ними - планирование с командой разработки.</p>  <h2>2. Use Case (сценарии использования)</h2>    <p>Высокоуровневое описание взаимодействия пользователя с системой. Включает предусловия, шаги и        постусловия.</p><p><i>Пример</i></p> <p><strong>ID:</strong> UC-001</p><table>    <tbody>        <!-- Строка: Название -->        <tr>            <th width=\"20%\">Поле</th>            <td width=\"80%\">Оформление заказа в интернет-магазине</td>        </tr>        <!-- Строка: Акторы -->        <tr>            <th>Акторы</th>            <td>                <ul>                    <li>Пользователь (покупатель)</li>                    <li>Система (интернет-магазин)</li>                </ul>            </td>        </tr>        <!-- Строка: Предусловия -->        <tr>            <th>Предусловия</th>            <td>                <ol>                    <li>Пользователь зарегистрирован в системе.</li>                    <li>Пользователь авторизован.</li>                    <li>В корзине есть хотя бы один товар.</li>                </ol>            </td>        </tr>        <!-- Строка: Основной сценарий -->        <tr>            <th>Основной сценарий</th>            <td>                <ol>                    <li>Пользователь переходит в корзину.</li>                    <li>Система отображает список товаров в корзине.</li>                    <li>Пользователь нажимает кнопку «Оформить заказ».</li>                    <li>Система открывает форму заполнения данных для доставки.</li>                    <li>Пользователь заполняет необходимые поля (адрес, способ оплаты).</li>                    <li>Пользователь подтверждает заказ.</li>                    <li>Система формирует заказ и отправляет уведомление на email.</li>                    <li>Система отображает номер заказа и итоговую сумму.</li>                </ol>            </td>        </tr>        <!-- Строка: Альтернативные сценарии -->        <tr>            <th>Альтернативные сценарии</th>            <td>                <div>                    <strong>А1. Пользователь отменяет заказ:</strong>                    <ol>                        <li>На любом шаге пользователь нажимает «Отменить».</li>                        <li>Система возвращает пользователя на главную страницу.</li>                    </ol>                </div>                <div>                    <strong>А2. Ошибка при заполнении данных:</strong>                    <ol>                        <li>Пользователь вводит некорректные данные (например, неверный email).</li>                        <li>Система выделяет ошибочные поля и выводит подсказки.</li>                        <li>Пользователь исправляет данные и повторяет отправку.</li>                    </ol>                </div>            </td>        </tr>        <!-- Строка: Постусловия -->        <tr>            <th>Постусловия</th>            <td>                <ul>                    <li>Заказ создан в системе.</li>                    <li>Пользователь получил уведомление о заказе.</li>                    <li>Товары из корзины удалены (если заказ успешно оформлен).</li>                </ul>            </td>        </tr>        <!-- Строка: Примечания -->        <tr>            <th>Примечания</th>            <td>                <ul>                    <li>Срок хранения корзины — 30 дней.</li>                    <li>При отсутствии товаров в наличии система предупреждает пользователя до оформления заказа.</li>                </ul>            </td>        </tr>    </tbody></table><h3>Когда применять</h3>    <ul>        <li>Для вотерфольных проектов, где бизнес привык видеть описание сценариев.</li><li>В начале проекта, когда нужно зафиксировать базовое поведение системы и согласовать его со стейкхолдерами.</li><li>В проектах с жёсткими требованиями к спецификации.</li>    </ul><p>У этого подхода есть визуальный формат - Use Case Diagram.</p><img src=\"usecase.png\"><p><i>Пример Use Case Diagram</i></p><p>Эти диаграммы относятся к нотации UML, о которой мы еще поговорим в ниже в этой же главе. Акторы здесь обозначены как люди, они находятся вне прямоугольника, который обозначате нашу систему. Этот прямоугольник называют границами системы. Акторы могут быть как реальными пользователями, так и внешними системами. Сами по себе варианты использования (Use Case) обозначены овалами внутри системы. Так же между акторами и вариантами использования обозначены связи нескольких типов. Ассоциация (Association) обозначается сплошной линией и служит для обозначения связи между актором и вариантом. Актор должен быть связан хотя бы с одним вариантом использования, при этом один актор может быть связан с несколькими вариантами, а один вариант использования - с несколькими акторами. Обобщение (Generalization) — отношение, при котором один актор или вариант использования наследует характеристики другого. Обозначается сплошной линией с незакрашенным треугольником на конце. Например, акторы «Клиент» и «Администратор» могут быть представлены более общим актором «Пользователь». Включение (Include) — обязательное отношение, при котором один вариант использования включает функциональность другого. Это означает, что базовый вариант использования неполноценен без включённого. Обозначается пунктирной линией со стрелкой и подписью «include». Например, вариант использования «Оформить заказ» может включать «Оплатить товар». Расширение (Extend) — необязательное отношение, при котором один вариант использования расширяет другой при определённых условиях. Обозначается пунктирной линией со стрелкой и подписью «extend». Например, вариант использования «Оформить заказ» может расширяться на «Применить промокод» при выполнении определённых условий. </p></section><section><h2>3. UML (Unified Modeling Language)</h2>    <p>Стандартный язык графического описания для моделирования систем. Включает десятки диаграмм.</p>    <h4>Ключевые диаграммы для требований</h4>    <ul>        <li><strong>Диаграмма классов</strong> — структура данных и связи между объектами.</li>        <li><strong>Диаграмма последовательностей</strong> — взаимодействие компонентов во времени.</li>        <li><strong>Диаграмма состояний</strong> — возможные состояния объекта и переходы между ними.</li>        <li><strong>Диаграмма активности</strong> — поток работ или процессов.</li>    </ul>    <h4>Когда применять</h4>    <ul>        <li>Для визуализации архитектуры системы.</li>        <li>При описании сложных алгоритмов.</li>        <li>Для коммуникации с разработчиками и архитекторами.</li>    </ul>    <p>Самой главной диаграммой я считаю <b>диаграмму последовательности</b>, так как она позволяет визуализировать общение между системами без лишних визуальных артефактов, как это происходит с BPMN.</p><p><b>Основные элементы UML sequence diagram</b></p><ul><li>Объекты (акторы) — сущности, которые взаимодействуют друг с другом. Это могут быть пользователи, системы, микросервисы, классы и т. д. Каждый объект представлен прямоугольником с именем в верхней части.</li><li>Линии жизни (lifelines) — вертикальные пунктирные линии, которые показывают существование объекта во времени. Они тянутся вниз от объекта и обозначают период его активности в процессе взаимодействия.</li><li>Сообщения (messages) — обмен информацией между объектами. Отображаются в виде стрелок, направленных от одной линии жизни к другой. Стрелки могут быть разных типов в зависимости от типа сообщения.</li><li>Активационные блоки (activation boxes) — прямоугольники на линии жизни, которые показывают период активности объекта при обработке сообщения. Начинаются в момент получения сообщения и заканчиваются после завершения обработки.</li><li>Примечания (notes) — дополнительные пояснения к диаграмме. Размещаются рядом с соответствующими элементами.</li></ul><p>Хочу посоветовать вам стараться создавать все диаграммы с помощью текстовых движков для создания диаграм вместо обычных визуальных редакторов, таких как Draw.io и Lucidchart. Попробуйте использовать Mermaid в VS code. Он поддерживается в Confluence, Azure DevOps, в простом маркдауне , и так же будет корректно отображаться в гитхабе. Причина этого совета в том, что текст для LLM воспринимается куда легче чем картинка, таким образом вы дадите нейросети больше контекста для помощи в составлении требований.</p><p><i>Пример sequence diagram в Mermaid: </i></p><pre><code><div>sequenceDiagram</div> <div style=\"margin-left:30px\">participant User <br>participant System <br>User->>System: Login request <br>activate System <br>System-->>User: Login success <br>deactivate System</div></code></pre><img width=\"400px\" length=\"400px\"  src=\"sequence.png\"><p><i>Пример визуализации sequence diagram сгенерированной в Mermaid</i></p><table><thead><tr><th>Тип сообщения</th><th>Описание</th><th>Пример в Mermaid</th></tr></thead><tbody><tr><td>Обычное сообщение</td><td>Стрелка с треугольником на конце, показывает вызов метода или передачу данных</td><td><code>A-&gt;&gt;B: Hello</code></td></tr><tr><td>Ответное сообщение</td><td>Пунктирная стрелка, показывает возврат значения</td><td><code>B--&gt;&gt;A: OK</code></td></tr><tr><td>Самосообщение (self&nbsp;message)</td><td>Стрелка в форме буквы&nbsp;U, объект отправляет сообщение самому себе</td><td><code>A-)A: Process data</code></td></tr><tr><td>Создание объекта</td><td>Сообщение с пометкой <code>create</code>, создаёт новый объект</td><td><code>A-&gt;&gt;create B: New object</code></td></tr><tr><td>Удаление объекта</td><td>Стрелка с крестиком на конце, уничтожает объект</td><td><code>A-&gt;-x B: Delete</code></td></tr></tbody></table></section><section><h2>4. BPMN (Business Process Model and Notation)</h2>    <p>Нотация для моделирования бизнес‑процессов. Показывает последовательность действий, роли и потоки данных.</p>    <h3>Основные элементы</h3>    <ul>        <li><strong>События</strong> (старт, завершение, промежуточные).</li>        <li><strong>Действия</strong> (задачи, подпроцессы).</li>        <li><strong>Шлюзы</strong> (условия ветвления).</li>        <li><strong>Потоки</strong> (последовательность, данные).</li>        <li><strong>Пулы и дорожки</strong> (роли/подразделения).</li>    </ul>    <h3>Когда применять</h3>    <ul>        <li>Для анализа и оптимизации бизнес‑процессов.</li>        <li>При автоматизации рабочих процедур.</li>        <li>Для согласования процессов между подразделениями.</li>    </ul>    <p>Я предлагаю использовать для моделирования приложение Camunda.</p><a href=\"https://camunda.com/download/modeler/\"><b><i>Ccылка на скачивание</i></b><p></a><img width=\"1000px\" height=\"400px\" src=\"bpmn.png\"></p><p><i>Пример бизнес процесса созданного с помощью Camunda</i></p>В этой нотации довольно много правил, есть много специализированных видео о том, как правильно создавать процессы в этой нотации, например <a href=\"https://www.youtube.com/watch?v=Eutdbh03W5k\" target=\"blank\"><i>The Only BPMN Tutorial You Will Ever Need To Watch</i></a>. К тому же есть отличная шпрагалска которой я всегда пользуюсь - <a href=\"https://bpm-conference.org/assets/docs/bpmn-poster/BPMN2_0_Poster_EN.pdf\" target=\"blank\"><i>BPMN Poster</i></a>.</section><section>    <h2>5. ERD (Entity-Relationship Diagram)</h2>    <p>Диаграмма «сущность‑связь» для моделирования структуры данных. Основа для проектирования баз данных.</p>    <h3>Ключевые компоненты</h3>    <ul>        <li><strong>Сущности</strong> (объекты предметной области, например «Клиент», «Заказ»).</li>        <li><strong>Атрибуты</strong> (свойства сущностей: «ID клиента», «Дата заказа»).</li>        <li><strong>Связи</strong> (отношения между сущностями: «Клиент делает Заказ»).</li>  <li><strong>Ключи</strong> (PK (Primary Key) уникальный идентификатор записи, FK (Foreign Key) обычно ссылка на PK другой сущности).</li>  </ul> <p><i>Пример в Mermaid</i></p><pre><div>erDiagram</div><div style=\"margin-left:30px\">CUSTOMER ||--o{ ORDER : \"размещает\"<br>ORDER ||--|{ LINE_ITEM : \"содержит\"<br>PRODUCT ||--o{ LINE_ITEM : \"используется в\"<br>CUSTOMER }|..|{ DELIVERY_ADDRESS : \"имеет\"<br><p>%% Описание сущностей и их атрибутов</p><br>CUSTOMER {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>STRING name<br>STRING email<br>DATE created_at</div>}<br>ORDER  {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER customer_id FK<br>DATE order_date<br>STRING status</div>}<br>LINE_ITEM  {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER order_id FK<br>INTEGER product_id FK<br>INTEGER quantity<br>DECIMAL unit_price</div>}<br>PRODUCT {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>STRING title<br>DECIMAL price<br>BOOLEAN is_available</div>}<br>DELIVERY_ADDRESS {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER customer_id FK<br>STRING address<br>STRING city<br> STRING postal_code</div>}</div></pre> <div><p>Как читать обозначения связей в Mermaid</p><ul><li>||--o{ — «один ко многим» (1:N), левая сторона обязательна, правая — нет;</li><li>||--|{ — «один ко многим» (1:N), обе стороны обязательны;</li><li>}|..|{ — «один ко многим» (1:N), обе стороны необязательны;</li><li>||--|| — «один к одному» (1:1);</li><li>o{--o{ — «многие ко многим» (M:N).</li></ul></div><img width=\"800px\" height=\"1000px\" src=\"erd.png\"><p><i>Пример ERD сгенерированного в Mermaid</i></p>   <h3>Когда применять</h3>    <ul>        <li>На этапе проектирования базы данных.</li>        <li>Для уточнения требований к хранению данных.</li></li></ul></section>"
        },
        {
            "id": "7",
            "title": "Глава VII: Валидация требований",
            "content": "<p>В этой главе мы рассмотрим 2 техники валиадации требований - демо и критерии приемки.</p><section>    <h3>1. Демонстрации (демо)</h3>    <p>Наглядная проверка реализации требований через показ работающего функционала.</p>    <h4>Цели демо</h4>    <ul>        <li>Подтвердить, что функционал соответствует ожиданиям стейкхолдеров.</li>        <li>Выявить расхождения между требованиями и реализацией.</li>        <li>Получить обратную связь для корректировок.</li>        <li>Повысить прозрачность процесса разработки.</li>    </ul>    <h4>Как организовать эффективное демо</h4>    <ol>        <li><strong>Подготовьте сценарий:</strong> заранее определите, какие функции и сценарии будете показывать.</li>        <li><strong>Пригласите ключевых стейкхолдеров:</strong> заказчиков, конечных пользователей, представителей            бизнеса.</li>        <li><strong>Покажите реальные данные:</strong> используйте примеры из бизнес‑процессов, а не абстрактные            тестовые значения.</li>        <li><strong>Включите негативные сценарии:</strong> продемонстрируйте, как система реагирует на ошибки и            исключительные ситуации.</li>        <li><strong>Фиксируйте обратную связь:</strong> записывайте замечания и вопросы для дальнейшей работы.</li>    </ol>    <p><strong><i>Пример: </i></strong> При демо модуля оформления заказа покажите: выбор товара → добавление в корзину → ввод        данных → оплату → получение подтверждения. Затем смоделируйте ошибку платежа и проверьте обработку.</p><p><strong><i>Совет: </i></strong> Бизнесу не очень инетересно как устроена система, поэтому демо должно быть максимально живым, приближенным к их реалиям, если ваш продукт это маркетплейс, расскажите историю, о том как вам понравилась кружка, вы решаете ее купить, добавляете в корзину и так далее. К тому же это сделает демо не настолько скучным.</p></section><section>    <h3>2. Критерии приемки (Acceptance Criteria)</h3>    <p>Конкретные условия, которые должны быть выполнены, чтобы требование считалось реализованным.</p>    <h4>Зачем нужны</h4>    <ul>        <li>Устраняют неоднозначность в понимании требований.</li>        <li>Служат основой для тестирования.</li>        <li>Помогают оценить готовность функционала.</li>        <li>Снижают риск споров между командой и заказчиком.</li> <li>Помогают найти пропущенные сценарии</li>   </ul>    <h4>Формат постых сценариев</h4>    <p>Проше всего записывать критерии приемки как короткие сценарии. Ниже приведен пример таких критериев приемки для функции «Восстановление пароля»:</p><ol><li>Пользователь на странице входа. Пользователь нажимает «Забыли пароль», видит экран с полем для ввода электронной почты, вводит валидный email, и нажимает кнопку `Отправить ссылку на восттановление пароля`. <b>Ожидаемый результат: </b> Пользоваетль получает письмо со ссылкой для сброса.</li><li>Пользователь на странице входа. Пользователь нажимает «Забыли пароль», видит экран с полем для ввода электронной почты, вводит невалидный email. <b>Ожидаемый результат: </b> Кнопка `Отправить ссылку на восттановление пароля` неактивна, границы поля стали красными, под полем пользователь видит валидационную ошибку `Адрес электронной почты недействителен. Используйте формат user@example.com`.</li></ol></section><section>    <h4>Формат сценариев на языке Gherkin</h4>    <p>Специализированный язык для описания приемочных критериев в человекочитаемом формате, декларируется его легкая конвертация в автотесты.</p> <p>Использует ключевые слова на английском (можно адаптировать под любой другой язык):</p>    <ul>        <li><code>Feature:</code> — название функционала. (Функционал)</li>        <li><code>Scenario:</code> — конкретный сценарий проверки. (Сценарий)</li>        <li><code>Given:</code> — начальные условия. (Дано)</li>        <li><code>When:</code> — действие.(Когда)</li>        <li><code>Then:</code> — результат. (Тогда)</li>        <li><code>And:(И)</code> / <code>But:</code> — дополнительные условия.(Но)</li>    </ul>    <i>Пример на Gherkin</i>    <pre>Функционал: Оформление заказа<br>Сценарий: Успешное оформление с оплатой картой<br>Дано: пользователь авторизован<br>И: в корзине есть товары<br>Когда: он выбирает способ оплаты «Банковская карта» <br>И: вводит корректные данные карты <br>Тогда: заказ подтверждается<br>И: списывается сумма<br>И: приходит уведомление на email</pre>    <p>Преимущества Gherkin: </p>    <ul>        <li>Единое понимание: одинаково читается бизнес‑аналитиками, разработчиками и тестировщиками.        </li>        <li>Автоматизация: сценарии можно превратить в автоматизированные тесты (Cucumber, SpecFlow).        </li>        <li>Документация: служит живым описанием функционала.</li></ul>  <p>Недостатки Gherkin: </p><ul><li>Сценарии становятся очень многословными</li><li>Из-за попытки описать сценарий для автотестов читабельность для бизнеса снижается</li><li>Сценарии нужно писать от лица пользователя, это снижает детализацию системных требований внутри сценария.</li></ul> </section><h4>Формат тестовых сценариев</h4><p>Вместо коротких сценариев описывается каждый шаг, предусловие и ожидаемы результат, тут нет привязки к пользователям, их проще использовать тестировщикам для написания тестов, они так же подходят для автоматизации. Ниже скопировал пример из предыдушей главы.</p> <ol><li>Ответ на запрос новых поступлений товара содержит новые поля<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = 'T-Shirt', на 10 штук, номер заказа 'PO123456', строка заказа номер 1 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123456', номер строки 1, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = 'T-Shirt', для заказа 'PO123456', строки 1, с expectedQuantity = 10, receivedQuantity=10</p></li><li>Поступление на товар без названия<p><b>Пререквизит:</b> Создан заказ на получение товара на склад для товара c productName = null, на 12 штук, номер заказа 'PO123457', строка заказа номер 2 </p><p><b>Шаги</b><ol><li>Создать поступление через API `POST api/receipt` для заказа 'PO123457', номер строки 2, на 10 штук</li><li>Отправить запрос GET `api/receipt` c параметром dateFrom заполненным сегодняшней датой</li></ol></p><p><b>Ожидаемый результат:</b> Ответ содержит поступление товара с productName = null, для заказа 'PO123457', строки 2, с expectedQuantity = 12, receivedQuantity=10</p></li></ol><section><h4>Лучшие практики</h4>    <ul>        <li>Пишите критерии до начала разработки.</li><li>Включайте граничные случаи (пустые поля, неверные форматы).</li>        <li>Согласовывайте с тестировщиками и заказчиками.</li><li>Пытайтесь отрисовать сценарии в форме прототипов (можете согласовывать сценарии используя прототипы - так гораздо нагляднее).</li>   </ul></section><section>    <h4>Частые ошибки</h4>    <ul>        <li><strong>Отсутствие критериев:</strong> требования без четких условий приемки ведут к разночтениям.</li>        <li><strong>Слишком общие формулировки:</strong> «Система работает корректно».        </li>        <li><strong>Игнорирование негативных сценариев:</strong> проверяйте не только «счастливый путь».</li>        <li><strong>Демо без подготовки:</strong> хаотичный показ функционала не дает ценной обратной связи.</li>        <li><strong>Gherkin как формальность:</strong> писать сценарии «для галочки», не используя их в тестировании.        </li>    </ul></section><section> <p>Валидация требований — не финальный этап, а непрерывный процесс. Комбинируя демо, и приемочные критерии, вы:</p>    <ul>        <li>снижаете риск недопонимания;</li>        <li>экономите время на переделки;</li>        <li>повышаете качество продукта;</li>        <li>делаете разработку прозрачнее для всех участников.</li>    </ul>    <p>Начните с малого: для каждой новой функции формулируйте 3–5 приемочных критерия и проводите мини‑демо для стейкхолдеров.</p></section>"
        },
        {
            "id": "8",
            "title": "Глава VIII: SQL для BA",
            "content": "<p>Глава не претендует на полный справочник по базам данных, но аналитку так или иначе нужно взаимодействовать с реляйионными базами данных. При этом, есть и другие форматы хранения данных, те же самые NoSQL базы данных, FTP. Об этом мы можем погворит в будущих главах.</p><section>    <p>Бизнес‑аналитику SQL нужен для:</p>    <ul>        <li>самостоятельного извлечения данных из баз;</li>        <li>проверки гипотез без привлечения разработчиков;</li>        <li>подготовки отчётов и дашбордов;</li>        <li>анализа пользовательского поведения;</li>        <li>валидации требований к данным.</li>    </ul>    <p>Достаточно знать базовые операторы — сложные оптимизации оставьте DBA.</p></section><section>    <h3>1. SELECT — выборка данных</h3>    <p>Основной оператор для получения данных из таблицы.</p>    <h3>Базовый синтаксис</h3>    <pre>SELECT столбец1, столбец2 FROM имя_таблицы;</pre>    <h3>Примеры</h3>    <ul>        <li>Выбрать все столбцы: <code>SELECT * FROM client;</code></li>        <li>Выбрать конкретные столбцы: <code>SELECT name, email FROM client;</code></li>        <li>С фильтрацией: <code>SELECT * FROM order WHERE status = 'Оплачен';</code></li>        <li>С сортировкой: <code>SELECT * FROM product ORDER BY price DESC;</code></li>    </ul>    <h3>Полезные модификаторы</h3>    <ul>        <li><code>WHERE</code> — условие отбора (фильтрация).</li>        <li><code>ORDER BY</code> — сортировка (ASC/DESC).</li>        <li><code>TOP</code> — ограничение числа строк.</li>    </ul></section><section>    <h3>2. JOIN — объединение таблиц</h3>    <p>Позволяет связывать данные из нескольких таблиц по общим полям.</p>    <h4>Основные типы JOIN</h4>    <h5>INNER JOIN</h5>    <p>Возвращает только совпадающие строки из обеих таблиц.</p>    <pre>SELECT order.id, client.name FROM order INNER JOIN client ON order.client_id = client.id;</pre>    <h5>LEFT JOIN</h5>    <p>Возвращает все строки из левой таблицы и совпадающие из правой (если нет совпадений — NULL).</p>    <pre>SELECT client.name, order.sum FROM client LEFT JOIN order ON client.id = order.client_id;</pre>    <h5>RIGHT JOIN</h5>    <p>Аналогично LEFT JOIN, но для правой таблицы.</p></section><section>    <h3>3. DISTINCT — уникальные значения</h3>    <p>Убирает дубликаты из результата запроса.</p>    <h4>Синтаксис</h4>    <pre>SELECT DISTINCT column FROM table;</pre>    <h4>Примеры</h4>    <ul>        <li>Уникальные статусы заказов: <code>SELECT DISTINCT status FROM order;</code></li>        <li>Уникальные комбинации: <code>SELECT DISTINCT city, region FROM client;</code></li></ul></section><section>    <h3>4. MAX — максимальное значение</h3>    <p>Находит наибольшее значение в столбце.</p>    <h4>Синтаксис</h4>    <pre>SELECT MAX(column) FROM table;</pre>    <h4>Примеры</h4>    <ul>        <li>Максимальная цена продукта: <code>SELECT MAX(price) FROM product;</code></li>        <li>Последняя дата заказа: <code>SELECT MAX(date) FROM order;</code></li>        <li>С группировкой: <code>SELECT category, MAX(price) FROM producy GROUP BY category;</code></li>    </ul>    </section><section>    <h3>5. AVG — среднее значение</h3>    <p>Вычисляет среднее арифметическое значений в столбце.</p>    <h4>Синтаксис</h4>    <pre>SELECT AVG(column) FROM table;</pre>    <h4>Примеры</h4>    <ul>        <li>Средняя стоимость заказа: <code>SELECT AVG(sum) FROM order;</code></li>        <li>Средний возраст клиентов: <code>SELECT AVG(age) FROM client;</code></li>        <li>По категориям: <code>SELECT type, AVG(rate) FROM feedback GROUP BY type;</code></li>    </ul>    <p><strong>Важно:</strong> AVG игнорирует NULL‑значения.</p></section><section>    <h3>Советы по работе с SQL</h3>    <ul>        <li><strong>Начинайте с простого:</strong> сначала освойте SELECT и WHERE, затем переходите к JOIN.</li>        <li><strong>Используйте комментарии:</strong> <code>-- Ваш комментарий</code> или            <code>/* комментарий */</code>.        </li>        <li><strong>Проверяйте запросы:</strong> запускайте на небольших выборках (<code>TOP 10</code>).</li>        <li><strong>Изучайте структуру БД:</strong> узнайте названия таблиц и ключей у администратора.</li>        <li><strong>Сохраняйте шаблоны:</strong> создайте библиотеку часто используемых запросов.</li><li><strong>Диалекты: </strong>в разных диалектах SQL есть незначительная разница в ключевых словах и синтаксисе, здесь я приводил примеры из TSQL. </li></ul></section>"
        },
        {
            "id": "9",
            "title": "Глава IX: Документация API",
            "content": "<p>Документация API — это формальное и одновременно практическое описание того,как внешние и внутренние клиенты могут взаимодействовать с серверной частью системы.По сути, это <strong>контракт</strong>, который отвечает на вопросы:</p><ul>    <li>какие эндпоинты существуют</li>    <li>какие данные и в каком формате нужно передавать</li>    <li>какие ответы и ошибки можно получить</li>    <li>какие ограничения и правила действуют</li></ul><p>Хорошая документация снижает порог входа, ускоряет интеграции и уменьшает количество ошибок. Плохая или отсутствующая документация приводит к догадкам, хаотичным правкам и конфликтам между командами.</p><h3>Основные подходы к документированию API</h3><p>На практике чаще всего используются два подхода:</p><ul>    <li><strong>request-first</strong> — документация строится на основе реальных запросов</li>    <li><strong>API-first</strong> — сначала описывается контракт, потом реализуется код</li></ul><h3>Документация API в Postman</h3><h4>Что такое Postman и когда он подходит</h4><p>Postman изначально создавался как инструмент для тестирования API, но со временем превратился в универсальную платформу для работы с запросами, окружениями, автотестами и документацией.</p><p>Postman особенно хорошо подходит, когда:</p><ul>    <li>API уже существует</li>    <li>важно быстро показать примеры запросов</li>    <li>документацией пользуются разработчики и QA</li></ul><h4>Коллекции как основа документации</h4><p>Документация в Postman строится вокруг <strong>коллекций</strong>. Каждый запрос внутри коллекции может быть снабжён описанием и примерами.</p><p>Пример структуры коллекции:</p><pre>Users <br>├── GET /users <br>├── GET /users/{id} <br>├── POST /users <br>└── DELETE /users/{id}</pre><h4>Пример документированного запроса в Postman</h4><p>Описание эндпоинта:</p><pre>GET /users/{id}<br>Возвращает информацию о пользователе по его идентификатору.Требует авторизации.</pre><p>Параметры:</p><ul>    <li><strong>id</strong> (path, integer) — идентификатор пользователя</li></ul><p>Пример ответа (200 OK):</p><pre>{  <br>\"id\": 42, <br>\"name\": \"Ivan Ivanov\",  <br>\"email\": \"ivan@example.com\"<br>}</pre><p>Пример ошибки (404 Not Found):</p><pre>{  <br>\"error\": \"User not found\"<br>}</pre><h4>Плюсы Postman</h4><ul>    <li>документация создаётся «по ходу дела»</li>    <li>живые примеры запросов и ответов</li>    <li>удобно шарить с командой</li></ul><h4>Минусы Postman</h4><ul>    <li>нет строгой формализации контракта</li>    <li>сложно отслеживать изменения API</li>    <li>документация может отставать от реализации</li></ul><h3>Документация API в Swagger</h3><h4>Swagger и спецификация OpenAPI</h4><p>Swagger — это набор инструментов, работающих на основе спецификации OpenAPI</strong>. Здесь API описывается декларативно — в виде формального контракта.</p><p>Основной принцип: <strong>сначала описание, потом код</strong>.</p><h4>Структура OpenAPI-документа</h4><p>Типичный OpenAPI-файл содержит:</p><ul>    <li>описание API и версию</li>    <li>эндпоинты и HTTP-методы</li>    <li>параметры</li>    <li>схемы данных</li>    <li>коды ответов и ошибки</li></ul><h4>Пример описания эндпоинта в Swagger (YAML)</h4><code>paths:  <div style=\"margin-left:30px\">/users/{id}:</div><div style=\"margin-left:40px\">get:</div>      <div style=\"margin-left:50px\">summary: Получить пользователя</div>     <div style=\"margin-left:50px\">parameters:</div>        <div style=\"margin-left:60px\">- name: id</div>          <div style=\"margin-left:80px\">in: path</div>        <div style=\"margin-left:80px\">required: true</div> <div style=\"margin-left:80px\">schema:</div> <div style=\"margin-left:95px\">type: integer</div>  <div style=\"margin-left:50px\">responses:</div> <div style=\"margin-left:80px\">'200':</div> <div style=\"margin-left:95px\">description: Успешный ответ</div>        <div style=\"margin-left:80px\">'404':</div>  <div style=\"margin-left:95px\">description: Пользователь не найден</div></code><p>На основе этого описания автоматически генерируется интерактивная документация, где можно отправлять запросы прямо из браузера.</p><h4>Плюсы Swagger</h4><ul>    <li>чёткий и проверяемый контракт</li>    <li>удобен для внешних клиентов</li>    <li>поддерживает генерацию SDK и серверных заготовок</li></ul><h4>Минусы Swagger</h4><ul>    <li>требует больше времени на начальную настройку</li>    <li>менее гибок для исследовательского тестирования</li></ul><h3>Postman и Swagger вместе</h3><p>На практике эти инструменты часто используются совместно:</p><ul>    <li>Swagger — как единый источник правды для API</li>    <li>Postman — для тестирования и примеров</li></ul><p>Распространённый сценарий:</p><ol>    <li>описать API в OpenAPI</li>    <li>сгенерировать документацию Swagger</li>    <li>импортировать спецификацию в Postman</li>    <li>дополнить запросы тестами и примерами</li></ol><h3>Типичные ошибки при документировании API</h3><ul>    <li>описан только happy path</li>    <li>нет примеров ошибок</li>    <li>документация не обновляется</li>    <li>несовпадение документации и реального API</li></ul><p>Postman и Swagger решают одну задачу - документирование API - но с разных сторон. Swagger задаёт строгий контракт и отлично подходит для API-first подхода, а Postman делает API наглядным и удобным для тестирования.</p><p>Использование обоих инструментов вместе позволяет получитьактуальную, понятную и полезную документацию, которая действительно помогает работать с API.</p>"
        },
        {
            "id": "10",
            "title": "Глава X: Как работать в Agile команде",
            "content": "<section>  <p>В Agile‑команде BA — не «передаточное звено», а активный участник процесса разработки.</p>  <h3>1. Роль бизнес‑аналитика в Agile</h3>     Ключевые функции аналитика:</p>    <ul>        <li>выявление и анализ потребностей заказчика;</li>        <li>формулировка User Stories и критериев приёмки;</li>        <li>поддержка коммуникации между бизнесом и разработкой;</li>        <li>анализ данных для приоритизации задач;</li>        <li>участие в демонстрациях и ретроспективах.</li>    </ul>    <p><strong>Важно:</strong> фокус на ценности для пользователя, а не на формальной документации.</p></section><section>    <h3>2. Взаимодействие с Product Owner</h3>    <p>Совместная работа над бэклогом:</p>    <ol>        <li>Помогайте PO структурировать требования (разбивайте крупные задачи).</li>        <li>Уточняйте бизнес‑контекст для каждой User Story.</li>        <li>Предлагайте метрики для оценки ценности функций.</li>        <li>Обсуждайте компромиссы между бизнес‑потребностями и техническими ограничениями.</li>    </ol>    <p><strong>Пример:</strong> Если PO просит «улучшить интерфейс», задайте вопросы: «Какие метрики улучшим? Какие        сценарии пользователей затронем?»</p></section><section>    <h3>3. Работа с командой разработки</h3>    <p>Как эффективно взаимодействовать:</p>    <ul>        <li><strong>На планировании спринта:</strong> разъясняйте требования, обсуждайте риски.</li>        <li><strong>В процессе спринта:</strong> оперативно уточняйте детали, участвуйте в обсуждениях решений.</li>        <li><strong>При тестировании:</strong> проверяйте соответствие результата бизнес‑целям.</li>        <li><strong>На демо:</strong> объясняйте ценность реализованных функций заказчику.</li>    </ul>    <p><strong>Совет:</strong> посещайте ежедневные стендапы, даже если вас не спрашивают — это помогает быть в        контексте.</p></section><section>    <h3>4. Документирование в Agile</h3>    <p>Принцип: «Достаточно, но не избыточно». Что и как фиксировать:</p>    <ul>        <li><strong>User Stories:</strong> формат «Как [роль], я хочу [функцию], чтобы [выгода]».</li>        <li><strong>Критерии приёмки:</strong> конкретные условия выполнения задачи (Given‑When‑Then).</li>        <li><strong>Диаграммы/схемы:</strong> только если упрощают понимание (например, C4, BPMN).</li>        <li><strong>Решения по спорным вопросам:</strong> кратко фиксируйте итоги обсуждений.</li>    </ul>    <p><strong>Избегайте:</strong> многостраничных ТЗ без привязки к итерациям.</p></section><section>    <h3>5. Анализ требований в итеративном режиме</h3>    <p>Пошаговый подход:</p>    <ol>        <li><strong>Выявление:</strong> интервью со стейкхолдерами, анализ данных, наблюдение за процессами.</li>        <li><strong>Формулировка:</strong> превращайте потребности в User Stories с критериями приёмки и кладите их в бэклог.</li>        <li><strong>Приоритезация:</strong> совместно с PO определяйте порядок реализации, кладите тикеты в спринты.</li>        <li><strong>Планирование:</strong> перед спринтом планируйте задачи с командой, расставляйте оценки, чтобы понимать сложность имплементации.</li>        <li><strong>Валидация:</strong> на демо проверяйте, решает ли функционал задачу пользователя.</li>    </ol></section><section>    <h3>6. Участие в ритуалах Agile</h3>    <table border='1' cellpadding='5'>        <tr>            <th>Ритуал</th>            <th>Роль BA</th>        </tr>        <tr>            <td>Планирование спринта</td>            <td>Разъяснение требований, оценка сложности задач.</td>        </tr>        <tr>            <td>Ежедневный стендап</td>            <td>Сообщение о прогрессе по анализу, блокировках.</td>        </tr>        <tr>            <td>Обзор спринта</td>            <td>Демонстрация ценности реализованных функций, сбор обратной связи.</td>        </tr>        <tr>            <td>Ретроспектива</td>            <td>Предложение улучшений процессов анализа и коммуникации.</td>        </tr>    </table></section><section>    <h3>7. Работа с изменениями</h3>    <p>В Agile требования меняются — это норма. Как реагировать:</p>    <ul>        <li>Оценивайте влияние нового требования на текущий спринт.</li>        <li>Фиксируйте причины изменений (чтобы избежать «блуждающих» требований).</li>        <li>Обновляйте User Stories и критерии приёмки при необходимости.</li>        <li>Объясняйте команде бизнес‑контекст изменений.</li>    </ul>    <p><strong>Правило:</strong> «Нет изменений посреди спринта без согласования с командой».</p></section><section>    <h3>8. Типичные ошибки BA в Agile</h3>    <ul>        <li><strong>«Перекладывание» ответственности:</strong> ожидание, что команда сама додумает требования.</li>        <li><strong>Избыточная детализация:</strong> попытки описать всё до мелочей до начала разработки.</li>        <li><strong>Отсутствие валидации:</strong> не проверяете, понял ли разработчик суть задачи.</li>        <li><strong>Игнорирование данных:</strong> решения без анализа метрик и пользовательского поведения.</li>        <li><strong>Сопротивление изменениям:</strong> защита «идеального» ТЗ вместо адаптации к реальности.</li>    </ul></section><section>    <h3>9. Советы для эффективного BA в Agile</h3>    <ol>        <li>Говорите на языке бизнеса и техники: переводите требования между стейкхолдерами.</li>        <li>Фокусируйтесь на ценности: каждый функционал должен решать конкретную проблему.</li>        <li>Будьте проактивны: предлагайте улучшения процессов, а не только фиксируйте требования.</li>        <li>Учитесь у команды: понимайте технические ограничения и возможности.</li>        <li>Документируйте итерационно: обновляйте материалы по мере уточнения деталей.</li>        <li>Развивайте навыки фасилитации: проводите эффективные встречи.</li>        <li>Используйте визуализацию: схемы часто понятнее текста.</li> <li>Требования на новый спринт начинайте писать сразу после планирования текущего спринта - писать в стол на пару спринтов вперед не самая плохая идея.</li>   </ol></section>"
        },
        {
            "id": "11",
            "title": "Глава XI: В плену у Ганта",
            "content": "<p>Software Requirements Specification (SRS) — это ключевой документ в разработке программного обеспечения,который    формально описывает, <strong>что именно должна делать система</strong>. Один из самых распространённых и проверенных    временем подходов — использование шаблона IEEE. Он помогает структурировать требования, избежать двусмысленностей и    упростить коммуникацию междузаказчиком, аналитиками, разработчиками и тестировщиками.</p><p>В этой статье разберём, <strong>как правильно писать SRS, следуя шаблону IEEE</strong>, и на что обращать внимание в    каждом разделе.</p><h3>1. Introduction (Введение)</h3><h4>1.1 Purpose (Цель документа)</h4><p>Здесь нужно кратко объяснить, <strong>для чего создан этот документ</strong> и какой продукт он описывает. Укажите    название системы, версию и границы ответственности SRS (вся система или только её часть).</p><h4>1.2 Document Conventions (Соглашения документа)</h4><p>Опишите правила оформления требований: нумерацию, ключевые слова, приоритеты, использование сокращения TBD (to be discussed).</p><h4>1.3 Intended Audience and Reading Suggestions (Целевая аудитория)</h4><p>Перечислите, для кого предназначен документ: разработчики, тестировщики, менеджеры,  заказчики. Можно указать, какие    разделы наиболее полезны каждой роли.</p><h4>1.4 Product Scope (Область применения продукта)</h4><p>Краткое описание продукта, его целей и бизнес-ценности. Здесь важно ответить на вопрос: <em>какую проблему решает        система</em>.</p><h4>1.5 References (Ссылки)</h4><p>Список связанных документов: vision & scope, контракты, стандарты, UX-гайды и другие источники, на которые опирается    SRS.</p><h3>2. Overall Description (Общее описание)</h3><h4>2.1 Product Perspective (Контекст продукта)</h4><p>Опишите, является ли система новой, частью существующей экосистемыили заменой старого решения. Полезно дать общее    текстовое или логическое описание окружения.</p><h4>2.2 Product Functions (Функции продукта)</h4><p>На высоком уровне перечислите ключевые функции системы. Это не детальные требования, а обзор возможностей продукта.</p><h4>2.3 User Classes and Characteristics (Классы пользователей)</h4><p>Опишите типы пользователей, их опыт, частоту использования и уровень доступа. Это поможет корректно формулировать    требования в дальнейшем.</p><h4>2.4 Operating Environment (Среда эксплуатации)</h4><p>Укажите, где будет работать система: ОС, устройства, браузеры, сторонние сервисы и ограничения среды.</p><h4>2.5 Design and Implementation Constraints (Ограничения)</h4><p>Здесь фиксируются все ограничения: технологические, регуляторные, корпоративные стандарты, обязательные инструменты    или языки.</p><h4>2.6 User Documentation (Пользовательская документация)</h4><p>Перечислите документацию, которая будет поставляться вместе с продуктом: руководства, справка, туториалы.</p><h4>2.7 Assumptions and Dependencies (Допущения и зависимости)</h4><p>Зафиксируйте предположения и внешние зависимости, которые могут повлиять на требования и сроки проекта.</p><h3>3. External Interface Requirements (Внешние интерфейсы)</h3><h4>3.1 User Interfaces (Пользовательские интерфейсы)</h4><p>Опишите требования к UI: экраны, стандарты, навигация, общие элементы и ограничения.</p><h4>3.2 Hardware Interfaces (Аппаратные интерфейсы)</h4><p>Требования к взаимодействию с оборудованием, если оно используется.</p><h4>3.3 Software Interfaces (Программные интерфейсы)</h4><p>Интеграции с другими системами, API, базами данных, форматы данных и протоколы взаимодействия.</p><h4>3.4 Communications Interfaces (Коммуникации)</h4><p>Описание сетевых протоколов, форматов сообщений,требований к безопасности и скорости передачи данных.</p><h3>4. System Features (Функциональные возможности)</h3><p>Этот раздел — сердце SRS. Здесь описываются функции системы, сгруппированные по фичам или сценариям.</p><h4>4.x System Feature</h4><ul>    <li><strong>Description and Priority</strong> — что делает функция и насколько она важна</li>    <li><strong>Stimulus/Response</strong> — последовательность действий пользователя и реакции системы</li>    <li><strong>Functional Requirements</strong> — детальные, атомарные и проверяемые требования</li></ul><p>Каждое требование должно быть:</p><ul>    <li>однозначным</li>    <li>проверяемым</li>    <li>необходимым</li>    <li>уникально идентифицированным</li></ul><h3>5. Other Nonfunctional Requirements (Нефункциональные требования)</h3><h4>5.1 Performance Requirements (Производительность)</h4><p>Временные отклики, нагрузка, масштабируемость и ограничения по ресурсам.</p><h4>5.2 Safety Requirements (Безопасность)</h4><p>Требования, связанные с предотвращением ущерба и рисков.</p><h4>5.3 Security Requirements (Информационная безопасность)</h4><p>Аутентификация, авторизация, защита данных и соответствие стандартам.</p><h4>5.4 Software Quality Attributes (Качества ПО)</h4><p>Надёжность, удобство использования, сопровождаемость, переносимость и другие атрибуты качества.</p><h4>5.5 Business Rules (Бизнес-правила)</h4><p>Правила, определяющие поведение системы с точки зрения бизнеса и ролей пользователей.</p><h3>6. Other Requirements (Прочие требования)</h3><p>Любые дополнительные требования, не вошедшие в предыдущие разделы.</p><h3>Appendices (Приложения)</h3><h4>Appendix A: Glossary</h4><p>Словарь терминов и сокращений, используемых в документе.</p><h4>Appendix B: Analysis Models</h4><p>Диаграммы, модели данных, состояния и другие аналитические материалы.</p><h4>Appendix C: To Be Determined List</h4><p>Список всех TBD, которые необходимо уточнить в будущем.</p><p><strong>Итог:</strong> использование шаблона IEEE для SRS позволяет создать чёткий, структурированный и понятный    документ, который служит надёжнойосновой для проектирования, разработки и тестирования программного обеспечения.</p>"
        },
        {
            "id": "12",
            "title": "Глава XII: Управление изменениями",
            "content": "<p>Знаете, я бы хотел написать об этом очень просто. К вам рано или поздно прибежит клиент, прямо когда вы пишите требования, прямо в середине спринта, и скажет, что ему срочно нужно внедрить какой-то функционал. Но разработчики уже заняты, тестировщики начали регресс следующей версии.</p><p>Вот мой пошаговый алгоритм: </p><ol><li>Со стейкхолдерами определить, что это вообще за требование;</li><li>Установить срок и приоритет, желательно сранивая с текщими задачами в текущем спринтe;</li><li>Пойти к команде разработке или тех лиду и получить оценку. Желательно подготовить несколько вариантов реализации и несколько оценок для них, чтобы предоставить стейкхолдерам альтернативу. Обязательно обозначить, какие потери понесет следующий спринт или релиз, насколько нужно будет перенести релиз;</li><li>Вместе со стейкхолдерами согласовать один из вариантов;</li></ol><p>Если не получилось договориться с первого раза, можно заново собраться с командой разработки и подготовить новые альтернативы.</p><p>Документация изменения ничем не отличается от документации любых других требований. В любом случае любые договоренности нужно документировать - прописывать в имейлах.</p>"
        },{
            "id": "13",
            "title":"Глава XIII: Очереди сообщений",
            "content":"<p>В распределённых системах очереди сообщений используются для асинхронного обмена данными между сервисами. Для бизнес-аналитика и системного аналитика понимание принципов работы очередей необходимо для корректной постановки требований: какие события передаются, в каком формате, какие гарантии доставки требуются, как обрабатываются ошибки и дубликаты.</p><p>Без этих уточнений техническое задание будет неполным, что приведёт к разночтениям в реализации.</p><h3>Базовые понятия: очередь, топик, брокер</h3><p>Очередь сообщений — это механизм передачи сообщений между системами через брокер сообщений.</p><ul><li><strong>Producer (отправитель)</strong> — сервис, который публикует сообщение.</li><li><strong>Consumer (получатель)</strong> — сервис, который читает сообщение.</li><li><strong>Broker</strong> — инфраструктурный компонент, управляющий доставкой сообщений.</li><li><strong>Queue</strong> — модель «один к одному» (одно сообщение — одному потребителю).</li><li><strong>Topic</strong> — модель «один ко многим» (сообщение получают несколько подписчиков).</li></ul><p>Пример популярных брокеров: <strong>ActiveMQ</strong> и <strong>Apache Kafka</strong>.</p><h3>Бизнес-кейс: передача ордера от API Gateway в сервис сохранения заказов</h3><p>Рассмотрим пример: клиент отправляет HTTP-запрос на создание заказа. Запрос поступает в API Gateway. Вместо синхронного вызова сервиса заказов API Gateway публикует сообщение в очередь. Сервис заказов асинхронно получает сообщение и сохраняет данные в БД.</p><h3>Архитектурная схема взаимодействия</h3><ol><li>Клиент отправляет POST /orders</li><li>API Gateway проверяет авторизацию</li><li>API Gateway публикует сообщение в брокер</li><li>Order Service читает сообщение</li><li>Order Service сохраняет заказ в базе данных</li></ol><h3>Формат сообщения (пример JSON)</h3><pre>{  <br>\"eventId\": <br>\"uuid-12345\",  <br>\"eventType\": <br>\"OrderCreated\",  <br>\"eventTime\": \"2026-02-19T10:15:30Z\",  <br>\"source\": \"api-gateway\",  <br>\"payload\": {    <br>\"orderId\": \"ORD-10001\",    <br>\"customerId\": \"CUST-777\",    <br>\"orderDate\": \"2026-02-19\",    <br>\"currency\": \"RUB\",    <br>\"totalAmount\": 12500.50,    <br>\"items\": <br>[      <br>{        <br>\"productId\": \"P-100\",        <br>\"quantity\": 2,        <br>\"price\": 5000     <br>},     <br>{        <br>\"productId\": \"P-200\",        <br>\"quantity\": 1,        <br>\"price\": 2500.50      <br>}    <br>]  <br>}}</pre><h3>Что аналитик должен зафиксировать в ТЗ</h3><ul><li>Название очереди или топика</li><li>Формат сообщения (JSON / Avro / XML)</li><li>Обязательные поля</li><li>Гарантия доставки (at least once / exactly once)</li><li>Требования к идемпотентности</li><li>Политика ретраев</li><li>Сценарии ошибок</li><li>Срок хранения сообщений</li></ul><h3>Реализация на ActiveMQ</h3><p>ActiveMQ реализует классическую модель JMS (Java Message Service).В нём есть очереди (Queue) и топики (Topic).</p><h3>Пример конфигурации для ActiveMQ</h3><ul><li>Queue name: ORDER.CREATED.QUEUE</li><li>Producer: api-gateway</li><li>Consumer: order-service</li><li>Delivery mode: persistent</li><li>Acknowledgement mode: client acknowledgment</li></ul><p>В модели Queue каждое сообщение будет обработано только одним экземпляром order-service.Это удобно для балансировки нагрузки.</p><h3>Особенности, которые аналитик должен учесть при ActiveMQ</h3><ul><li>Сообщение может быть доставлено повторно (если consumer не подтвердил получение).</li><li>Необходима идемпотентность по полю eventId или orderId.</li><li>Возможна настройка Dead Letter Queue (например, ORDER.CREATED.DLQ).</li><li>Требуется определить TTL сообщений.</li></ul><h3>Как это выглядело бы в Apache Kafka</h3><p>Apache Kafka использует модель логов (append-only log). Вместо очередей — топики, которые делятся на партиции.</p><h3>Пример конфигурации Kafka</h3><ul><li>Topic name: order.created.v1</li><li>Количество партиций: 3</li><li>Replication factor: 2</li><li>Producer: api-gateway</li><li>Consumer group: order-service-group</li></ul><h3>Ключ сообщения в Kafka</h3><p>В Kafka важно определить key. Например:</p><pre>Key: orderIdValue: JSON с событием OrderCreated</pre><p>Использование orderId как key обеспечивает попадание всех событий одного заказа в одну и ту же партицию и сохранение порядка обработки.</p><h3>Отличия ActiveMQ и Kafka с точки зрения требований</h3><table border=\"1\"><tr><td>Критерий</td><td>ActiveMQ</td><td>Kafka</td></tr><tr><td>Модель</td><td>Очередь / Topic</td><td>Distributed log</td></tr><tr><td>Хранение</td><td>До подтверждения или TTL</td><td>По времени хранения (retention)</td></tr><tr><td>Повторное чтение</td><td>Сложно</td><td>Легко (через offset)</td></tr><tr><td>Масштабирование</td><td>Через конкурирующих consumer'ов</td><td>Через партиции</td></tr></table><h3>Что дополнительно указать в ТЗ при использовании Kafka</h3><ul><li>Стратегию партиционирования</li><li>Политику retention (например, 7 дней)</li><li>Формат сериализации (JSON / Avro + Schema Registry)</li><li>Версионирование топика (order.created.v1)</li><li>Consumer group</li><li>Гарантии доставки (at least once / exactly once)</li></ul><h3>Идемпотентность как обязательное требование</h3><p>Поскольку большинство брокеров гарантируют доставку «как минимум один раз», сервис order-service обязан быть идемпотентным. Аналитик должен зафиксировать правило: повторная обработка события с тем же eventId не должна приводить к созданию дубликата заказа.</p><h3>Нефункциональные требования</h3><ul><li>Производительность (например, 1000 сообщений в секунду)</li><li>Максимальная задержка обработки (не более 5 секунд)</li><li>Мониторинг и алертинг</li><li>Логирование correlationId</li><li>Требования к отказоустойчивости</li></ul><h3>Типовая формулировка требования для ТЗ</h3><p>API Gateway при создании заказа обязан публиковать событие OrderCreated в топик order.created.v1 брокера сообщений. Формат сообщения — JSON согласно утверждённой схеме. Сервис order-service обязан подписаться на данный топик в составе consumer group order-service-group и обеспечить идемпотентную обработку сообщений по полю eventId.</p><p>Аналитик, который фиксирует не только бизнес-событие, но и формат сообщения, название очереди/топика, гарантию доставки, стратегию обработки ошибок и нефункциональные требования, существенно снижает риски интеграционных проблем.</p><p>Понимание различий между ActiveMQ и Kafka позволяет корректно формулировать архитектурные ограничения и ожидания от команды разработки.</p>"
        },
        {
            "id": "14",
            "title": "Глава XIV: Нереляционные базы данных и объектные хранилища",
            "content": "<p>В современных информационных системах помимо классических реляционных СУБД широко используются нереляционные базы данных (NoSQL) и объектные хранилища. Для бизнес-аналитика и системного аналитика важно понимать, в каких сценариях они применяются, какие ограничения имеют и какие параметрынеобходимо зафиксировать в техническом задании.</p><p>Если в ТЗ указано только «данные хранятся в базе» или «файлы сохраняются в хранилище», это создаёт неопределённость для разработчиков и архитекторов.</p><h3>Что такое нереляционная база данных (NoSQL)</h3><p>NoSQL — это класс систем хранения данных, которые не используюттрадиционную табличную модель с жёсткой схемой. Они предназначены для масштабирования, высокой нагрузки и гибкой структуры данных.</p><p>Основные типы NoSQL-баз:</p><ul><li>Документо-ориентированные (например, MongoDB)</li><li>Key-Value (например, Redis)</li><li>Колонковые (например, Cassandra)</li><li>Графовые (например, Neo4j)</li></ul><h3>Когда использовать NoSQL: бизнес-сценарии</h3><ul><li>Хранение событий (event store)</li><li>Каталоги товаров с разной структурой атрибутов</li><li>Профили пользователей с динамическими полями</li><li>Кэширование сессий</li><li>Логи и телеметрия</li></ul><p>NoSQL подходит, когда структура данных меняется часто или требуется горизонтальное масштабирование.</p><h3>Пример 1: хранение профиля клиента в документо-ориентированной БД</h3><p>В интернет-магазине профиль клиента может содержать:</p><ul><li>Персональные данные</li><li>Список адресов</li><li>Историю заказов</li><li>Настройки уведомлений</li></ul><p>В документо-ориентированной БД это может храниться как единый JSON-документ:</p><pre>{  <br>\"customerId\": \"CUST-777\",  <br>\"name\": \"James James\",  <br>\"email\": \"james@example.com\",  <br>\"addresses\": <br>[    <br>{      <br>\"type\": \"delivery\",      <br>\"city\": \"Chicago\",      <br>\"street\": \"Carter street 2\"    <br>}  <br>],  <br>\"preferences\": {    <br>\"newsletter\": true,    <br>\"smsNotifications\": false  <br>}<br>}</pre><h3>Что аналитик должен указать в ТЗ при использовании NoSQL</h3><ul><li>Тип базы (документная, key-value и т.д.)</li><li>Модель хранения данных (пример структуры документа)</li><li>Правила версионирования структуры</li><li>Требования к индексации</li><li>Объём данных и ожидаемый рост</li><li>Требования к масштабированию</li><li>Требования к консистентности (eventual / strong)</li><li>Требования к резервному копированию</li></ul><h3>Отличия от реляционных БД, важные для требований</h3><ul><li>Отсутствие жёсткой схемы</li><li>Ограниченная поддержка транзакций (в некоторых системах)</li><li>Денормализация данных</li><li>Оптимизация под чтение или запись</li></ul><p>Аналитику важно учитывать, что данные могут дублироваться в разных документах,и нужно описывать бизнес-правила синхронизации.</p><h3>Что такое объектное хранилище</h3><p>Объектное хранилище предназначено для хранения файлов (объектов):изображений, документов, видео, резервных копий.</p><p>Пример системы — MinIO, совместимая с API Amazon S3.</p><h3>Основные понятия объектного хранилища</h3><ul><li>Bucket — логический контейнер (аналог каталога)</li><li>Object — файл</li><li>Key — уникальный путь к объекту</li><li>Metadata — метаданные объекта</li></ul><h3>Пример 2: хранение документов заказов в MinIO</h3><p>В системе электронного документооборота необходимо хранить:</p><ul><li>PDF-счета</li><li>Подписанные договоры</li><li>Скан-копии документов</li></ul><p>Пример структуры хранения:</p><ul><li>Bucket: order-documents</li><li>Object key: 2026/02/ORD-10001/invoice.pdf</li><li>Metadata:    <ul>        <li>orderId: ORD-10001</li>        <li>documentType: invoice</li>        <li>uploadedBy: order-service</li>    </ul></li></ul><h3>Когда использовать объектное хранилище</h3><ul><li>Хранение больших файлов</li><li>Медиа-контент</li><li>Архивы и резервные копии</li><li>Документы, связанные с бизнес-сущностями</li></ul><h3>Что аналитик должен зафиксировать в ТЗ для объектного хранилища</h3><ul><li>Название bucket</li><li>Структура ключей (key naming convention)</li><li>Максимальный размер файла</li><li>Разрешённые форматы файлов</li><li>Политика хранения (retention)</li><li>Требования к шифрованию</li><li>Права доступа (кто читает, кто загружает)</li><li>Срок хранения файлов</li><li>Требования к версионированию объектов</li></ul><h3>Пример формулировки требования для ТЗ (NoSQL)</h3><p>Профиль клиента должен храниться в документо-ориентированной базе данных. Структура документа определяется утверждённой JSON-схемой. Система должна поддерживать горизонтальное масштабирование и хранениене менее 10 миллионов документов.</p><h3>Пример формулировки требования для ТЗ (Object Storage)</h3><p>Все документы заказов должны сохраняться в bucket order-documents. Формат ключа: {год}/{месяц}/{orderId}/{documentType}.{ext}. Максимальный размер файла — 20 МБ. Доступ к чтению — только у сервисов billing-service и order-service.</p><h3>Нефункциональные требования</h3><ul><li>Производительность (время загрузки/чтения файла)</li><li>Доступность (SLA, например 99.9%)</li><li>Резервное копирование</li><li>Репликация</li><li>Мониторинг использования дискового пространства</li></ul><h3>Типичные ошибки в постановке требований</h3><ul><li>Не указана модель данных</li><li>Нет требований к объёму хранения</li><li>Не описана стратегия удаления данных</li><li>Не указаны правила именования объектов</li><li>Отсутствуют требования к безопасности</li></ul><p>Понимание различий между реляционными БД, NoSQL и объектными хранилищамипозволяет аналитику корректно формулировать архитектурные ограничения.</p><p>Хорошее техническое задание должно содержать:</p><ul><li>Тип хранилища</li><li>Пример структуры данных</li><li>Нефункциональные требования</li><li>Требования к безопасности и доступу</li><li>Правила масштабирования и резервирования</li></ul><p>Чем более конкретно описана модель хранения данных, тем меньшеархитектурных рисков и доработок в дальнейшем.</p>"
        }
    ],
    "articles_en": [
        {
            "id": "1",
            "title": "Chapter I: Basic Concepts",
            "content": "<p>To begin studying business analysis, we first need to agree on some common terms so that we can understand each other.</p><h3>Stakeholders</h3><p><b>Stakeholders</b> are any people or organizations that can influence your product or project or can be influenced by your product or project. First of all, let's classify them.</p><p><i>Paying stakeholder</i> - a representative of the company that is paying for your project, for example, the Product Owner or Product Manager, possibly the Project Manager, who is responsible for the budget and decides on continuing funding, he is interested in the real business result, because he is paying money, and if there are no results, you will be fired. The same type of stakeholder can be attributed to the shareholders of the company, since they can buy, hold or sell shares and vote for decisions in the board of directors depending on the financial results of the company.</p><p><i>SME (Subject Matter Expert)</i> — a subject matter expert, an employee who knows a lot about the business or system, can help understand it, he may no longer be directly involved with the product, but he knows a lot about the product and can answer questions about how the system was built and what were the expectations from this or that functionality.</p><p><i>Development Team</i> — they do the work, it is very important to inform them of what is actually needed and why, this is your job as a business analyst.</p><p><i>Support Team</i> — if there is one, people who help users use the system, fix the configuration. They need to know how the product functions so that they can help users.</p><p><i>End Users</i> are the people who ultimately decide to use your product. It is the users who generate profit, and based on their behavior <b>The paying stakeholder</b> determines your future.</p><p><i>Government</i> - Not only does the government require you to pay taxes, but they are constantly coming up with new rules that you need to know about, and they won't inform you about them, so you better follow the headlines to avoid ending up in jail or paying a big fine.</p><p><i>Activists and lobbyists</i> - Try thinking about all the nonprofit organizations that are trying to sue you.</p><p><i>Competitors</i> - Other companies developing a similar product or working in the same direction that can poach your customers.</p><p><i>Suppliers and vendors</i> - Other companies that help the business may be the actual suppliers of goods or services, for example, such a service provider could be a cleaning company, an auditor, other software providers.</p><h3>Types of Requirements</h3><p><i>Functional Requirements (FR)</i> are a description of the expectations of how the system should behave, mainly in cases where the user performs some action. If, when discussing requirements, someone tells you that the user is not involved in the process at all, then this someone most likely does not know what they are talking about. Even if there is an automatic task that runs on a schedule, the reason for the existence of this task is the use of the results of this task by the user. <i>Example:</i> let's say there are prices that our system retrieves from a third-party API and stores them in the database once a day - these prices will be used to calculate the cost of an order when the user places it.</p><p><i>Non-Functional Requirements (NFR)</i> are a description of the expectations regarding how the system should work in the software environment - these are performance requirements (the page should open within 3 seconds, the endpoint should be able to handle 100 000 records at a time), software requirements (the app must be available on iOS and Android, the site must work in IE11 (please tell me there are no more requirements like this)), translation requirements (the site must be available in Spanish - this requirement is still considered non-functional, but the ability to switch between languages is already a functional requirement since it requires external influence - a user action), UX requirements - for example, HIPPA (Health Insurance Portability and Accountability Act - say 'hello' to the <i>government</i> stakeholder type) compliance, where you are required to provide an audio-readable version of the site.</p><h4>Business Requirements and System Requirements</h4><p><i>Stakeholder Requirements</i> - poorly formulated (maybe even incorrectly formulated) fragments of sentences and thoughts that a business analyst must process. They are mainly business problems (e.g., \"I don't know, users seem to be ignoring our new weather forecast page, can we make a big red button that would lead them there directly from the landing page?)</p><p><i>Business Requirements</i> — your domain, these requirements should be well structured, should describe how the system works. (“add a button to the center of the homepage, follow the design described in Figma (source link); only users subscribed to Plan B can see this button and this page; when the user clicks on the button, he is redirected to the weather forecast page and sees ...”; etc.).</p><p>By the way, the requirements above are not a template, we will talk about the best ways to write requirements in future chapters of this course. I would like to emphasize that prototyping is definitely a part of business requirements, it is a preparation for requirements elicitation, the same as writing acceptance criteria and finding missed scenarios.</p><p><i>System Requirements</i> — a description of the interaction of system components as a result of user actions. In the System Requirements Specification (SRS), such requirements are called external requirements interface and system functions. This is basically a description of how the system should work with other systems or how the components of one system interact with each other, for example, if you have an API endpoint whose operation needs to be documented, you need to define the request and response body, for each field in the request and response body you need to define the data type, length, if applicable (e.g. for a string data type, for a decimal data type), whether the field is required or not, what validations exist for the field. If the information is stored in a database, you need to define a mapping of the database fields to the fields in the request. If the information is passed to another system or retrieved by another system, you need to define a mapping of your fields to the fields of the third-party application (for example, if information is passed between two microservices). If the information needs to be updated periodically, how often should this happen? If a lot of data is returned, should the endpoint support pagination? Should there be a rate limit on the requests? If there are multiple calls between multiple systems, use UML or BPMN notations to visualize the sequence of calls made and the expected answers. If your business requirements specify multiple states for business objects, do yourself a favor and create a state transition diagram to identify missing states and the triggers that cause the transition from one state to another.<p><p>There are many other classifications that can be taken from IEEE/ISO, BABOK, or Karl Wiegers' book.</p><h3>Requirements Elicitation</h3><p><i>Requirements elicitation or gathering</i> is the step in the business analysis process when the analyst gathers requirements and tries to understand what requirements even exist before writing them down. There are many methods:<ul><li>Interviews with stakeholders</li><li>Brainstorming with stakeholders</li><li>Interviews with users</li><li>Observing user behavior</li><li>Creating prototypes</li><li>Review and analysis of documentation and legislation</li></ul></p><h3>Personas and user roles</h3><p>There are different groups of users, in UX they are also called personas - to indicate social differences in user groups, usually in one application there are different user roles - Regular User, Administrator, Subscription User A, Subscription User B. If we talk about personas - we talk about a demographic description - here is user Tim, he is about 25 years old, he is in good health and he earns less money, Jim is 45-50, he regularly goes to the doctor and he has more savings than Tim, etc. :</p><h3>Glossary</h3><p>This is literally what you're reading now, and every good project should have one - a glossary of common project terms so everyone is speaking the same language, especially useful when stakeholders use different terms for the same business object.</p><h3>User Story</h3><p>This is a template for writing requirements that must include the user role, the required feature, and the value the user will get from that feature. <i>Example:</i> As an <b><i>application administrator</i></b>, I want to be able to <b><i>add articles to the application's homepage</b></i> so the <b><i>user can read them</b></i>.</p><h3>Use Case</h3><p>A system use case is a scenario with user input and a sequence of system actions that occur because of that input. <ol> <li>User opens the home page</li> <li>User sees a big red button</li> <li>User clicks the big red button</li> <li>User is redirected to such-and-such page</li> </ol></p><h3>Acceptance Testing</h3><p>Testing performed by an analyst before deploying functionality to an environment available to the customer or user (PROD, UAT, Stage - there are many names for such environments)</p><h3>User Acceptance Testing</h3><p>Testing performed by users in a specially designed environment. Such an environment can be called UAT or Stage.</p><h3>Release Notes</h3><p>Along with the release to PROD, stakeholders are sent a document listing all the changes made in the release.</p><h3>Basic Documentation</h3><p>These are articles on wikis, Confluence, Sharepoint, or any other tool that can store general information about the product's functionality. Such documentation is essential; if it doesn't exist, the business analyst's job will be to create and maintain it. It should include a project overview, diagrams, and architecture schemes.</p>"
        },
        {
            "id": "2",
            "title": "Chapter II: What are good requirements?",
            "content": "<section><p>Requirements are the foundation of any development project. The success of the implementation directly depends on their quality: deadlines, budget, and whether the final product meets customer expectations. In the AI era, requirements are becoming even more important - now this text is often perceived not by the developer, but by a large language model. The better the requirements, the better the result, the more time the engineer will have to design the system. In this chapter, we will analyze what makes requirements \"good\", relying on authoritative sources: Karl Wiegers' book \"Developing Software Requirements\", IEEE/ISO standards, as well as the INVEST and SMART methodologies.</p></section><section> <h2>Definition of a requirement</h2> <p>In the standard <strong>ISO/IEC/IEEE 29148:2011 4.1.17</strong>, requirements are defined as a statement which translates or expresses a need and its associated constraints and conditions\").</p></section><section> <h2>Criteria for Good Requirements (according to Karl Wiegers, Chapter 5)</h2> <p>Karl Wiegers in his book \"Engineering Software Requirements\" identifies the following key characteristics of quality requirements:</p> <ul> <li><strong>Uniqueness</strong> - a requirement describes one and only one thing.</li> <li><strong>Completeness</strong> - contains all the information necessary for understanding and implementation.</li> <li><strong>Consistency</strong> - does not conflict with other requirements and documentation.</li> <li><strong>Atomicity</strong> - cannot be divided into smaller requirements without losing meaning.</li> <li><strong>Traceability</strong> - can be traced back to business goals and other project artifacts.</li> <li><strong>Relevance</strong> - remains relevant throughout the project life cycle.</li> <li><strong>Feasibility</strong> - technically feasible in within the given constraints.</li> <li><strong>Unambiguity</strong> — the wording does not allow for different interpretations.</li> <li><strong>Verifability</strong> — there is a way to verify that the requirement has been met.</li> </ul></section><section> <h2>INVEST Methodology: User Story Criteria</h2> <p>The <strong>INVEST</strong> methodology proposed by Bill Wake is popular for Agile approaches. It sets criteria for the quality of user stories:</p> <ul> <li><strong>I (Independent)</strong> — independence: the story should not depend on other stories.</li> <li><strong>N (Negotiable)</strong> — negotiability: the description is not a contract, but a reason for discussion.</li> <li><strong>V (Valuable)</strong> — value: brings benefit to the user or business.</li> <li><strong>E (Estimable)</strong> — evaluability: can be estimated Effort.</li> <li><strong>S (Small)</strong> — compactness: small enough to be implemented in one sprint.</li> <li><strong>T (Testable)</strong> — testability: there are acceptance criteria.</li> </ul></section><section> <h2>SMART Method: Criteria for Formulating Requirements</h2> <p>The <strong>SMART</strong> principle helps formulate requirements so that they are suitable for implementation: </p> <ul> <li><strong>S (Specific)</strong> — specificity: a clear description of what needs to be done.</li> <li><strong>M (Measurable)</strong> — measurability: there are criteria for verifying completion.</li> <li><strong>A (Achievable)</strong> — achievability: technically feasible.</li> <li><strong>R (Relevant)</strong> — relevance: corresponds to business goals.</li> <li><strong>T (Time-bound)</strong> — time-bound: the implementation deadlines are clear.</li> </ul></section><section> <h2>How do you know when requirements are ready for development?</h2> <p>Before handing over requirements to the development team, run the following checklist:</p> <ol> <li><strong>Completeness</strong>: Have all scenarios and edge cases been considered?</li> <li><strong>Clarity</strong>: Will the developer understand the requirement without further questions?</li> <li><strong>Consistency</strong>: Are there any conflicts with other requirements?</li> <li><strong>Priorities</strong>: Have priorities been defined (for example, you can use the MoSCoW technique: Must have, Should have, Could have, Won't have, or simply High, Medium, Low)?</li> <li><strong>Acceptance criteria</strong>: Are there clear conditions by which implementation can be checked?</li> <li><strong>Dependencies</strong>: Are external systems or components taken into account?</li> <li><strong>Risks</strong>: Are potential implementation issues identified?</li> </ol></section><section> <h2>Typical Requirements Errors</h2> <ul> <li>Ambiguous wording. <i>Example:</i> \"the user should easily find…\" - it is not clear what \"easy\" means here, what is the criterion for ease?</li><li>Solution requirements instead of goal requirements. <i>Example:</i> \"In a new field in the database in the Orders table, concatenate the Id and ShortCode fields with a hyphen…\" - why is this field needed in the database, maybe it should just be returned in the API response? Or even just shown in the user interface?</li> <li>Lack of validation criteria. <i>Example:</i> \"the system should be fast\" - what is this requirement about? Maybe about opening a page, how fast in that case Should it open in 3 minutes, 3 seconds? With what number of concurrent users? </li> <li>Excessive detail at an early stage.</li> <li>Inconsistency with business goals.</li> </ul></section><section> <p>Good requirements are a balance between detail and flexibility, precision and clarity. Based on IEEE/ISO standards, the Wiegers, INVEST, and SMART approaches, you can create a foundation for successful development:</p> <ul> <li>Check requirements against quality criteria.</li> <li>Involve the team in discussions to resolve ambiguities.</li> <li>Document acceptance criteria.</li> <li>Keep requirements current throughout the development process.</li> </ul> <p>Only well-formulated requirements can minimize risks, reduce costs, and create a product that truly solves user problems.</p></section>"
        },
        {
            "id": "3",
            "title": "Chapter III: What to do on a new project?",
            "content": "<section><p>Starting a new project is a critical stage for a business analyst. Here is a clear plan of action at the start.</p></section><section><h3>Step 1. Stakeholder Analysis</h3> <p>Stakeholder analysis allows you to:</p> <ul><li>identify key sources of requirements;</li> <li>build communication;</li> <li>anticipate conflicts of interest;</li> <li>distribute responsibilities.</li> </ul> <h4>How to conduct the analysis</h4> <ol> <li><strong>Identification.</strong> Make a list of all possible stakeholders: customers, users, regulators, the team, related departments. A simple list will be quite sufficient. Your contact person on the project can help you with names and positions; the SME will know best, but for this you need to identify him.</li> <li><strong>Classification.</strong> Divide stakeholders into groups: <ul> <li>internal / external;</li> <li>primary (direct influence) / secondary;</li> <li>supportive / resistant.</li> </ul> <p>An Onion diagram is very suitable for classifying primary and secondary stakeholders.</p><img width=\"500px\" height=\"500px\" alt=\"Example of onion diagram\" src=\"onion.png\"><p><i>Example of Onion Diagram</i></p> </li> <li><strong>Evaluation of interests and influence.</strong> Use the Power Interest Grid to choose a strategy for behavior with a stakeholder: <table border=\"1rem\" cellpadding=\"5\"> <tr><th>Stakeholder</th><th>Power</th><th>Interest</th><th>Strategy</th></tr><tr><th>Buying customer</th><th>High Power</th><th>High interest</th><th>Manage closely</th></tr><tr><th>Platform holder</th><th>Low Power</th><th>Low interest</th><th>Monitor</th></tr><tr><th>Enduser</th><th>High Power</th><th>Low interest</th><th>Keep satisfied</th></tr><tr><th>Development team</th><th>Low Power</th><th>High interest</th><th>Keep informed</th></tr></table><p><img width=\"500px\" height=\"500px\" alt=\"Example of Power Interest Grid\" src=\"powerinterest.png\"></p><p><i>Power Interst Grid Example</i></p> </li> <li><strong>Planning Interaction.</strong> Identify key stakeholders and determine how often and how you will communicate with them, whether it will be at regular general meetings, twice a week at backlog refinements, or every week at 1-1, whether it is necessary to invite the customer's manager to daily meetings, whether it is necessary to send reports and, if so, in what form they are usually sent. All this can be determined during personal meetings. </section><section> <h3>Step 2. Creating a Glossary</h3><p>A glossary is a dictionary of project terms. It eliminates misunderstandings and speeds up communication. The first chapter clearly illustrates this kind of glossary.</p> <h3>What to include</h3> <ul> <li>industry terms (e.g., \"lead\", \"conversion\" in marketing);</li> <li>names of systems and modules;</li> <li>abbreviations and acronyms;</li> <li>company-specific concepts.</li> </ul> <h3>How to compose</h3> <ol> <li>Highlight terms from the first interviews and documents.</li> <li>Agree definitions with stakeholders.</li> <li>Indicate synonyms and examples of use.</li> <li>Update as new concepts emerge.</li> </ol> </section><section> <h3>Step 3. Basic documentation</h3> <p>At the start, create a minimum set of documents. It will become the foundation for further work.</p><h3>Mandatory documents</h3><ol><li><strong>Project charter</strong> <p>Briefly answers the questions:</p><ul><li>Why is the project needed? (goals, business value)</li><li>What will be done? (boundaries, results)</li><li>Who is involved? (in principle, stakeholder analysis work covers this point)</li><li>When? (deadlines, stages, approximate roadmap, if any, if not, it needs to be clarified with stakeholders)</li><li>What are the constraints? (budget, resources)</li></ul> <p>If you have an architect or an experienced tech lead on your team, perhaps an SME with a technical background, contact them and draw a diagram of the product and its relationships with other products, for example, you can use the C4 notation to describe the system architecture.</p> </li> <li> <strong>List of requirements (Baseline Requirements)</strong> <p>Table with requirements. Columns:</p> <ul> <li>Requirement ID;</li><li>Title;</li><li>Description</li><li>Criteria acceptance</li></ul><p>The requirements table should copy all the requirements from the tickets in your project management system that have already been deployed to production. You can organize it in a wiki, Confluence, Sharepoint, Word, Git repository, the main thing is that they are in one place, it is easier to understand the current state of the project, it would be even better to track in the same document how some requirements cancel or expand others. Of course, it is not necessary to copy the requirements verbatim, you can summarize them and make them shorter.</p> </li> <li> <strong>Meeting Minutes</strong> <p>After each meeting, always record:</p> <ul> <li>date and participants;</li> <li>key decisions;</li> <li>actions and responsible persons;</li> <li>open questions.</li> </ul><p>Now AI assistants can do most of this work for you, so don't lose the chance to use them.</p></li> <li> <strong>Risks and Issues (Risk Log)</strong> <p>Table with columns:</p> <ul> <li>Risk Description;</li> <li>Probability of Occurrence - High, Medium, Low;</li> <li>Degree of Impact on the Project - High, Medium, Low;</li> <li>Measures - description of activities to prevent or reduce the risk;</li> <li>Responsible;</li> </ul> </li> </ol> <div > <strong>Advice:</strong> Don't strive for perfection at the start. Documents should be \"live\" - update them as information comes in, show them to other team members for discussion. </div></section><section> <h2>Checklist for the First 2 Weeks</h2> <p>To avoid missing the important, follow the plan:</p> <ol> <li>Hold introductory meetings with key stakeholders.</li> <li>Create an initial list of stakeholders and an influence matrix.</li> <li>Start filling out the glossary based on initial discussions.</li> <li>Draft the project charter (even in draft form).</li> <li>Make a list of requirements - include the first 5-10 items.</li> <li>Record all meetings and decisions in minutes.</li> <li>Identify key risks.</li> </ol></section>"
        },
        {
            "id": "4",
            "title": "Chapter IV: Requirements Elicitation",
            "content": "<p>Requirements elicitation is, first of all, a set of techniques and methods for obtaining requirements. Analysts often contrast this term with the term collection, since requirements do not grow out of the ground and sometimes have to be extracted with difficulty. In this chapter, we will dwell in more detail on four main methods of eliciting requirements and give practical recommendations for their application.</p><section><h3>1. Interviews</h3> <div> <p><strong>Essence:</strong> personal communication with stakeholders to obtain information about needs, problems, and expectations.</p> <p><strong>When to apply:</strong> when working with key stakeholders. This is the simplest and at the same time the most reliable method that can be applied almost always.</p> </div> <h3>How to conduct it effectively</h3> <ol> <li>Prepare: study the context, make a list of questions.</li><li>Start with open-ended questions (\"Tell me how you currently solve this problem?\").</li> <li>Use clarifying questions (\"Why is this important?\", \"What will happen if...\").</li> <li>It's better to have the subject of the conversation in front of you. If you have a finished application, website, prototype, competitor's reference, document or graph, be sure to show it on your screen or ask the stakeholder to show their screen with an example.</li> <li>Record not only the answers, but also your assessment of the answers. You may feel that the person is not confident in their judgment, then this point is worth verifying with other stakeholders.</li> <li>Be sure to ask about priorities and deadlines - these are not necessarily vague High, Medium, Low, priorities are rather dates that your stakeholders have already communicated to their stakeholders, for example, their new client will start working with the application in May of this year, so if now it is April, all other features will be less of a priority.</li> <li>At the end, summarize the key points, after the meeting, draw up a protocol and send it out Participants, be sure to discuss whether a follow-up meeting is necessary.</li> </ol> <div> <strong>Tip:</strong> Avoid leading questions. Instead of \"You need to export to Excel, right?\" ask, \"In what formats do you exchange data?\" </div></section><section> <h3>2. Workshops</h3> <div><p><strong>Essence:</strong> group sessions with several stakeholders for joint identification and discussion of requirements.</p><p><strong>When to use:</strong> for complex projects, the need to coordinate positions, generate ideas.</p> </div> <h4>Advantages</h4> <ul> <li>Time saving (simultaneous collection of opinions from several participants).</li> <li>Ability to immediately resolve contradictions.</li> <li>Generation of new ideas due to the participation of stakeholders from different business streams.</li> </ul> <p>By and large, this is just a mass interview, but since there are many participants, a clear agenda is needed.</p> <div> <strong>Advice:</strong> prepare a virtual board and mark the progress of the agenda on it.</div></section><section> <h3>3. Prototypes</h3> <div> <p><strong>Essence:</strong> creating simplified models of a product (interfaces, processes) to visualize ideas and get feedback. In addition, when you create a prototype and start thinking through states and transitions between them, you can find missing and ill-conceived states and identify requirements this way.</p> <p><strong>When to use:</strong> to clarify interface requirements, test hypotheses, demonstrate concepts.</p> </div> <h4>Types of prototypes</h4> <ul> <li><strong>Paper</strong> - quick hand sketches.</li> <li><strong>Interactive</strong> - clickable mockups (for example, in Figma).</li> <li><strong>Functional</strong> - working versions with basic functionality.</li> </ul> <h3>How to use</h3> <ol> <li>Create a prototype based on the initial requirements.</li> <li>Conduct demonstration to stakeholders.</li> <li>Collect feedback: what is unclear, what needs to be changed.</li> <li>Iterate: improve the prototype until it is approved.</li> </ol> <div> <strong>Tip:</strong> Don't invest too much time in detailing an early prototype - its purpose is to quickly get feedback. </div><p><a href=\"https://www.youtube.com/watch?v=kbZejnPXyLM&pp=ygUMZmlnbWEgY291cnNl\" target=\"blank\">Link to the Figma course</a></p><p>Of course, no one forbids making a prototype in Cursor App in the age of AI.</p></section><section> <h3>4. Documentation analysis</h3> <div> <p><strong>Essence:</strong> studying existing documents to identify requirements and context.</p> <p><strong>When to use:</strong> at the beginning project, when upgrading systems, to understand current processes. </p> </div> <h3>What documents to analyze</h3> <ul> <li>Business plans and strategies.</li> <li>Descriptions of current processes (BPMN, text regulations).</li> <li>Technical documentation of systems.</li> <li>Reports and analytics (KPI, metrics).</li> <li>Previous requirements and technical specifications.</li> <li>User manual and FAQ.</li> </ul> <h3>Analysis algorithm</h3> <ol> <li>Make a list of sources.</li> <li>Highlight key terms and processes.</li> <li>Find contradictions and gaps.</li> <li>Formulate questions for clarification.</li> <li>Record the identified requirements.</li> </ol> <div> <strong>Tip:</strong> create a glossary based on the terminology from the documents - this will reduce the risk of discrepancies. </div></section> <h3>Common mistakes and how to avoid them</h3> <ul> <li> <strong>Writing wishes, not needs:</strong> <p>Stakeholders often formulate solutions (\"I want a red button\"), not a problem.</p> <p><em>How to avoid:</em> ask clarifying questions: \"Why is this needed?\", \"What problem does this solve?\", \"What will happen if this is not done?\"</p> </li> <li> <strong>Lack of validation:</strong> <p>Requirements are recorded, but not checked for realism and consistency.</p> <p><em>How to avoid:</em> After collecting requirements, conduct a review with stakeholders, model use cases.</p> </li> <li> <strong>Ignoring non-functional requirements:</strong> <p>Focus only on functionality, without taking into account performance, security, and usability.</p> <p><em>How to avoid:</em> Make a list of questions about non-functional requirements (How many requests can happen per day/hour/minute? What is the maximum number of rows in a request? Does the affiliate system expect a synchronous or asynchronous response? Should there be retry logic? How many times to try to resend a failed request? How quickly should the page load? And so on).</p> </li> <li> <strong>Too general formulations:</strong> <p>“The system must work quickly”, “The interface must be user-friendly” - impossible to test.</p> <p><em>How to avoid:</em> Be more specific: “The system response time is no more than 2 seconds under a load of up to 1000 users.”</p> </li> <li> <strong>Underestimating the impact of changes:</strong> <p>New requirements are not analyzed for compatibility with existing processes and systems.</p> <p><em>How to avoid:</em> Create a process diagram taking into account the underlying systems (for example, using BPMN or a UML sequence diagram).</p> </li> <li> <strong>Lack of prioritization:</strong> <p>All requirements are considered equally important, which leads to development overload.</p> <p><em>How to avoid:</em> Ask about delivery dates, but if it turns out that all features have become urgent and a priority, and the development team is overloaded, you need to prioritize using specialized techniques - (for example, MoSCoW, Cost Of Delay).</p> </li> <li> <strong>Undocumentation of sources:</strong> <p>It is unclear who and why put forward the requirement, which makes further clarification difficult.</p> <p><em>How to avoid:</em> Record in the requirements list: stakeholder, date, context.</p> </li> <li> <strong>Omitting boundary cases:</strong> <p>Only \"ideal\" scenarios are taken into account, errors and exceptional situations are ignored.</p> <p><em>How to avoid:</em> Model negative scenarios (\"What if the user enters incorrect data?\").</p> </li> <li> <strong>Excessive detail at an early stage:</strong> <p>Trying to describe all the nuances before approving the concept leads to a waste of time.</p> <p><em>How to avoid:</em> First, capture high-level requirements, then go into detail.</p> </li> <li> <strong>Lack of feedback:</strong> <p>Requirements are handed over to the team without planning.</p> <p><em>How to avoid:</em> The development team should plan stories with you, remember that you cannot know everything, their input on the requirements is very valuable. If you don't want to distract the entire team, you can ask for a preliminary conversation with the tech lead and one of the most experienced testers.</p> </li> </ul></section><section> <h2>Conclusion</h2> <p>Requirements elicitation is not a one-time action, but an iterative process. To minimize errors:</p> <ol> <li>Combine methods (interviews + prototypes + document analysis).</li> <li>Record everything in writing.</li> <li>Regularly validate requirements with stakeholders.</li> <li>Be flexible: allow for adjustments as new information becomes available.</li> <li>Use templates and checklists to systematize your work.</li> </ol> </section>"
        },
        {
            "id": "5",
            "title": "Chapter V: Prioritizing Requirements",
            "content": "<section><p>In any project, resources are limited: time, budget, team. Prioritization helps determine which tasks will bring the greatest benefit and should be implemented first. Of course, the classic way of prioritization is setting deadlines; if a task must be released by a certain date, it is much easier to prioritize it. Bugs from production with a large potential or actual impact are always a higher priority than new tasks. The prioritization methods proposed below are more suitable for MVP development, when priorities compete with each other and the scope needs to be reduced. </p></section><section><h3>MosCoW Method</h3><p>MosCoW is a method for categorizing requirements into four groups:</p><ul><li><strong>MUST have</strong> — mandatory requirements, without which the project will not be successful</li><li><strong>SHOULD have</strong> — important requirements, but not critical</li><li><strong>COULD have</strong> — <li>WON'T have</strong> — requirements that will not be implemented in the current version</li></ul><h4>When to use?</h4><p>Ideal for projects with fixed deadlines and budgets, where you need to clearly define the minimum viable product (MVP).</p><h4>Advantages and disadvantages</h4><p><strong>Pros:</strong> simplicity, clarity, quick implementation</p><p><strong>Cons:</strong> subjectivity, lack of quantitative metrics</p></section><section><h3>Cost of Delay</h3><p>Cost of Delay estimates the financial losses from delaying the implementation of a feature.</p><p>Cost of Delay can be calculated as the revenue from a feature per unit of time multiplied by the number of units of time required for implementation. <i>For example:</i> you have a bug that breaks the sending of orders, in The company earns $10,000 a day on orders. The development team says they can fix the bug in 2 days. <b>Cost of Delay = $10,000 x 2 = $20,000</b>.</p><p>There is also another metric based on Cost of Delay - CD3. CD3 is calculated as the revenue from a feature per unit of time divided by the number of units of time required for implementation. CD3 allows you to determine which of the bugs is more priority. <i>Example:</i> There is a bug in production that breaks the sending of orders, the company earns $10,000 per day on orders. The development team says they can fix the bug in 2 days. Let's call it Bug A. There is Bug B, which prevents ads from displaying on the site, the site loses $4,000 per day because of this. The development team says they can fix this bug in a quarter of a day (2 hours). <b>Cost of delay Bug A = $20,000.</b> <b>Cost of delay for Bug B = $1,000.</b> <b>CD3 for Bug A = $10,000/ 2 = 5,000.</b> <b>CD3 for Bug B = $4,000/ 0.25 = 16,000.</b> It turns out that if you choose based on this indicator, you need to fix Bug B first, fixing it will return revenue faster.</p><h4>When to use?</h4><p>Especially useful in commercial projects where financial indicators and ROI are important, and, most importantly, where this data is available.</p><h4>Advantages and disadvantages</h4><p><strong>Pros:</strong> objective numerical data, focus on business value.</p><p><strong>Cons:</strong> complexity of calculations, requires accurate data.</p></section><section><h3>The RICE Method</h3><p>RICE is a scoring system that takes into account four factors:</p><ul><li><strong>Reach</strong> - how many users the feature will affect</li><li><strong>Impact</strong> - how much the feature will impact each user</li><li><strong>Confidence</strong> - how accurate our estimates are</li><li><strong>Effort</strong> - how much time/resources it will take</li></ul><p>Formula: <em>RICE Score = (Reach × Impact × Confidence) / Effort</em></p><h4>When to use?</h4><p>For products with a large number of users, where engagement metrics are important.</p><h4>Advantages and disadvantages</h4><p><strong>Pros:</strong> a comprehensive approach, takes into account several factors</p><p><strong>Cons:</strong> Requires data collection, can be overcomplicated</p></section><section><h3>Story Mapping</h3><p>A visual method for organizing user stories along the user journey axis.</p><img width=\"1000px\" height=\"500px\" src=\"storymap.png\"><p><i>Story Map Example in Figma</i></p></section><section><h2>How to Choose the Right Method?</h2><table border='1' cellpadding='8' cellspacing='0'><tr><th>Method</th><th>Best suited for</th><th>Difficulty of implementation</th></tr><tr><td>MosCoW</td><td>Projects with fixed deadlines, MVP</td><td>Low</td></tr><tr><td>Cost of Delay</td><td>Commercial projects where ROI is important</td><td>High</td></tr><tr><td>RICE</td><td>Products with user metrics</td><td>Medium</td></tr></table></section><section><h2>Practical tips for prioritization</h2><ol><li>Start with simple methods and move to complex ones as needed</li><li>Involve key stakeholders in the prioritization process</li><li>Review priorities regularly - they may change</li><li>Be mindful of technical debt and non-functional requirements</li></ol></section><section><p>There is no universal 'best' prioritization method. The choice depends on the project context and the available data. The key to success is a systematic approach and regular revision of priorities as new information becomes available. Experiment with different methods, adapt them to your needs.</p></section>"
        },
        {
            "id": "6",
            "title": "Chapter VI: Requirements Documentation",
            "content": "<p>Let's look at the most popular formats of requirements documentation - User Story, Use Case, BPMN and UML diagrams, as well as Entity Relation diagrams.</p><section> <h3>1. User Stories</h3> <p>Brief descriptions of functionality from the user's point of view. The main format in Agile development.</p> <h4>Structure</h4> <p>\"As a <em>[role]</em>, I want to <em>[feature]</em>, so that <em>[value]</em>.\"</p> <p><strong>Example:</strong> \"As a buyer, I want to filter products by price to quickly find suitable options.\"</p> <h4>When to use</h4> <ul> <li>In iterative development (Scrum, Kanban).</li> <li>When there is a need to quickly prioritize requirements.</li> <li>For communication with non-technical stakeholders.</li> </ul> <h4>Pros and cons</h4> <p><strong>Pros:</strong> simplicity, focus on user value, flexibility.</p> <p><strong>Cons:</strong> insufficient detail for complex scenarios, risk of ambiguity.</p></section><section> <h4>Main mistakes</h4><ul><li>Invalid role - I often see analysts write \"As a product manager, I want.\" Product manager is not a role in the application, a role in the application is some user. Even if it seems that there is no user, and the consumer is a third-party system, in the third-party system there is a user who expects something from the system. It is also worth saying that several users can be listed in a story.</li><li>Lack of value - Analysts often skip the value description part, which completely discredits the concept. Writing down the value is also an element of analysis - it makes you think again whether the user wants this feature. Value also gives the programmers' work some meaning, and also allows them to propose alternative solutions. Let's compare a story with and without value. \"As a catalog administrator, I want to be able to change the available quantity of products in stock.\" My questions immediately arise - why provide such an option, there is no integration with the warehouse system? How can the administrator know how many products are in stock? Now let's add value. \"As a catalog administrator, I want to be able to change the available quantity of products in stock to correct errors in the warehouse integration.\" Ah, everything is clear here, that is, there is integration with the warehouse, but, apparently, there are errors, miscalculations, or periodic downtimes on the warehouse system side, so it is necessary to be able to adjust the quantity manually. </li></ul> <p>I want to note that the story alone will not be enough to convey the requirements to development. I usually also include a summary of the functional requirements and acceptance criteria in the format of step-by-step test scenarios.</p> <p><i>Example of my requirements:</i></p><p>As a <b><i>catalog user</i></b>, I want to <b><i>receive notifications about the receipt of goods at the warehouse</i></b> so that I can <b><i>start ordering goods from the warehouse</i></b>.</p> <p><b><i>Requirements:</i></b></p> <p><ol><li>To get information about the receipt of goods, the catalog will use the existing API `GET api/receipt`, it is necessary to extend the response of this API so that the catalog can save information about the receipt of goods to itself.</li><li>Missing fields: <ul><li>expectedQuantity - source in the database `DatabaseName.PurchaseOrder.Quantity`</li><li>productName - source in the database `DatabaseName.Item.ProductName`</li><li>purchaseOrderNumber - source in the `DatabaseName.PurchaseOrder.OrderNumber` database</li></ul></li><li>Example response to a request with new fields: <pre><code>{<br>\"recordsFound\":10,<br>\"recordsOnPage\":10,<br>\"pageNumber\":0,<br>\"totalPages\":1,<br>\"receipts\":<br>[<div style=\"margin-left: 50px;\">{<br>\"id\":1,<br>\"receivedQuantity\":10,<br>\"expectedQuantity\":10,<br>\"productName\":\"T-Shirt\",<br>\"purchaseOrderNumber\":\"PO123456\",<br>\"purchaseOrderLine\":1<br>}</div>]}</code></pre></li></ol><p></p></p><p><b><i>Acceptance criteria</i></b><ol><li>The response to the request for new product receipts contains new fields<p><b>Prerequisite:</b> An order has been created to receive goods at the warehouse for product with productName = 'T-Shirt', for 10 pieces, order number 'PO123456', order line number 1 </p><p><b>Steps</b><ol><li>Create a receipt via the API `POST api/receipt` for order 'PO123456', line number 1, for 10 pieces</li><li>Send a GET request `api/receipt` with the dateFrom parameter filled with today's date</li></ol></p><p><b>Expected result:</b> The response contains a receipt of goods with productName = 'T-Shirt', for order 'PO123456', line 1, with expectedQuantity = 10, receivedQuantity=10</p></li><li>Receipt for an unnamed product<p><b>Prerequisite:</b> An order has been created to receive goods to the warehouse for the product with productName = null, for 12 pieces, order number 'PO123457', order line number 2 </p><p><b>Steps</b><ol><li>Create a receipt via the API `POST api/receipt` for order 'PO123457', line number 2, for 10 pieces</li><li>Send a GET request `api/receipt` with the dateFrom parameter filled with today's date</li></ol></p><p><b>Expected result:</b> The response contains a product receipt with productName = null, for order 'PO123457', line 2, with expectedQuantity = 12, receivedQuantity=10</p></li></ol></p><p>I would like to note that these requirements are an example of how an analyst works within agile methodologies, the endpoint already exists, it is described in the previous requirements, there are validations for the endpoint `POST api/receipt`, all this does not apply to this requirement, here we are expanding an existing request response, since a new client has come to us and needs new fields to integrate with us. And of course, the requirements may contain errors and inaccuracies, missed scenarios, but the analyst has a powerful tool for working with them - planning with the development team.</p> <h2>2. Use Case (use scenarios)</h2> <p>A high-level description of user interaction with the system. Includes preconditions, steps, and postconditions.</p><p><i>Example</i></p> <p><strong>ID:</strong> UC-001</p><table> <tbody> <!-- Line: Name --> <tr> <th width=\"20%\">Field</th> <td width=\"80%\">Placing an order in the online store</td> </tr> <!-- Line: Actors --> <tr> <th>Actors</th> <td> <ul> <li>User (buyer)</li> <li>System (online store)</li> </ul> </td> </tr> <!-- Line: Preconditions --> <tr> <th>Preconditions</th> <td> <ol> <li>The user is registered in the system.</li> <li>The user is authorized.</li> <li>There is at least one product in the cart.</li> </ol> </td> </tr> <!-- Line: Main Scenario --> <tr> <th>Main Scenario</th> <td> <ol> <li>The user goes to the cart.</li> <li>The system displays the list of products in the cart.</li> <li>The user clicks the \"Place an order\" button.</li> <li>The system opens a form for filling in delivery data.</li> <li>The user fills in the required fields (address, payment method).</li> <li>User confirms the order.</li> <li>The system creates the order and sends a notification by email.</li> <li>The system displays the order number and the total amount.</li> </ol> </td> </tr> <!-- Line: Alternative scenarios --> <tr> <th>Alternative scenarios</th> <td> <div> <strong>A1. The user cancels the order:</strong> <ol> <li>At any step, the user clicks \"Cancel\".</li> <li>The system returns the user to the main page.</li> </ol> </div> <div> <strong>A2. Error filling in data:</strong> <ol> <li>The user enters incorrect data (for example, an invalid email).</li> <li>The system highlights the erroneous fields and displays prompts.</li> <li>The user corrects the data and re-submits.</li> </ol> </div> </td> </tr> <!-- Line: Postconditions --> <tr> <th>Postconditions</th> <td> <ul> <li>The order has been created in the system.</li> <li>The user has received a notification about the order.</li> <li>The items have been removed from the cart (if the order was successfully placed).</li> </ul> </td> </tr> <!-- Line: Notes --> <tr> <th>Notes</th> <td> <ul> <li>The cart is stored for 30 days.</li> <li>If the items are out of stock, the system warns the user before placing the order.</li> </ul> </td> </tr> </tbody></table><h3>When to apply</h3> <ul> <li>For waterfall projects, where the business is used to seeing scenario descriptions.</li><li>At the beginning of the project, when it is necessary to record the basic behavior of the system and agree on it with stakeholders.</li><li>In projects with strict specification requirements.</li> </ul><p>This approach has a visual format - the Use Case Diagram.</p><img src=\"usecase.png\"><p><i>Example Use Case Diagram</i></p><p>These diagrams refer to the UML notation, which we will discuss later in this chapter. Actors here are designated as people; they are located outside the rectangle that represents our system. This rectangle is called the system boundaries. Actors can be either real users or external systems. Use cases themselves are represented by ovals within the system. Several types of relationships are also shown between actors and use cases. An association is represented by a solid line and is used to indicate the connection between an actor and a use case. An actor must be associated with at least one use case, but one actor can be associated with multiple use cases, and one use case can be associated with multiple actors. Generalization is a relationship in which one actor or use case inherits the characteristics of another. It is represented by a solid line with an open triangle at the end. For example, the actors \"Client\" and \"Administrator\" could be represented by the more general actor \"User.\" Include is a mandatory relationship in which one use case includes the functionality of another. This means that the base use case is incomplete without the included one. It is represented by a dotted line with an arrow and the caption \"include.\" For example, the use case \"Place an order\" might include \"Pay for the product.\" Extend is an optional relationship in which one use case extends another under certain conditions. It is denoted by a dotted line with an arrow and the caption \"extend.\" For example, the use case \"Place an order\" might extend to \"Apply a promo code\" when certain conditions are met. </p></section><section><h2>3. UML (Unified Modeling Language)</h2> <p>A standard graphical description language for system modeling. Includes dozens of diagrams.</p> <h4>Key diagrams for requirements</h4> <ul> <li><strong>Class diagram</strong> - data structure and relationships between objects.</li> <li><strong>Sequence diagram</strong> - interaction of components over time.</li> <li><strong>State diagram</strong> - possible states of an object and transitions between them.</li> <li><strong>Activity diagram</strong> - workflow or process flow.</li> </ul> <h4>When to use</h4> <ul> <li>For visualization of system architecture.</li> <li>When describing complex algorithms.</li> <li>For communication with developers and architects.</li> </ul> <p>I consider the <b>sequence diagram</b> to be the most important diagram, since it allows you to visualize communication between systems without unnecessary visual artifacts, as is the case with BPMN.</p><p><b>Main elements of a UML sequence diagram</b></p><ul><li>Objects (actors) are entities that interact with each other. These can be users, systems, microservices, classes, etc. Each object is represented by a rectangle with a name at the top.</li><li>Lifelines are vertical dotted lines that show the existence of an object over time. They extend downwards from the object and denote the period of its activity during the interaction.</li><li>Messages are the exchange of information between objects. They are displayed as arrows directed from one lifeline to another. Arrows can be of different types depending on the type of message.</li><li>Activation boxes are rectangles on the lifeline that show the period of object activity during message processing. They begin at the moment the message is received and end after processing is complete.</li><li>Notes are additional explanations for the diagram. They are placed next to the corresponding elements.</li></ul><p>I would recommend that you try to create all diagrams using text-based diagramming engines instead of traditional visual editors like Draw.io and Lucidchart. Try using Mermaid in VS Code. It is supported in Confluence, Azure DevOps, and Simple Markdown, and will also display correctly on GitHub. The reason for this tip is that text is much easier to read for LLM than images, so you'll give the network more context to help it formulate requirements.</p><p><i>Example of a sequence diagram in Mermaid: </i></p><pre><code><div>sequenceDiagram</div> <div style=\"margin-left:30px\">participant User <br>participant System <br>User->>System: Login request <br>activate System <br>System-->>User: Login success <br>deactivate System</div></code></pre><img width=\"400px\" length=\"400px\" src=\"sequence.png\"><p><i>Example of a visualization of a sequence diagram generated in Mermaid</i></p><table><thead><tr><th>Message type</th><th>Description</th><th>Example in Mermaid</th></tr></thead><tbody><tr><td>Normal Message</td><td>Arrow with a triangle at the end, shows a method call or data transfer</td><td><code>A->B: Hello</code></td></tr><tr><td>Response Message</td><td>Dotted arrow, shows a value being returned</td><td><code>B-->A: OK</code></td></tr><tr><td>Self-Message (self&nbsp;message)</td><td>U-shaped arrow, the object sends a message to itself</td><td><code>A-)A: Process data</code></td></tr><tr><td>Object Creation</td><td>Message marked <code>create</code>, creates a new object</td><td><code>A->create B: New object</code></td></tr><tr><td>Delete object</td><td>Arrow with a cross at the end, destroys the object</td><td><code>A->x B: Delete</code></td></tr></tbody></table></section><section><h2>4. BPMN (Business Process Model and Notation)</h2> <p>Notation for modeling business processes. Shows the sequence of activities, roles, and data flows.</p> <h3>Key Elements</h3> <ul> <li><strong>Events</strong> (start, end, intermediate).</li> <li><strong>Activities</strong> (tasks, subprocesses).</li> <li><strong>Gates</strong> (branching conditions).</li> <li><strong>Flows</strong> (sequence, data).</li> <li><strong>Pools and Lanes</strong> (roles/departments).</li> </ul> <h3>When to Use</h3> <ul> <li>For business process analysis and optimization.</li> <li>For workflow automation.</li> <li>For process alignment between departments.</li> </ul> <p>I suggest using Camunda for modeling.</p><a href=\"https://camunda.com/download/modeler/\"><b><i>Download link</i></b><p></a><img width=\"1000px\" height=\"400px\" src=\"bpmn.png\"></p><p><i>Example of a business process created using Camunda</i></p>This notation has quite a lot of rules, there are many specialized videos on how to correctly create processes in this notation, for example <a href=\"https://www.youtube.com/watch?v=Eutdbh03W5k\" target=\"blank\"><i>The Only BPMN Tutorial You Will Ever Need To Watch</i></a>. In addition, there is an excellent scribbler that I always use - <a href=\"https://bpm-conference.org/assets/docs/bpmn-poster/BPMN2_0_Poster_EN.pdf\" target=\"blank\"><i>BPMN Poster</i></a>.</section><section> <h2>5. ERD (Entity-Relationship Diagram)</h2> <p>Entity-Relationship Diagram for modeling data structure. Basis for database design.</p> <h3>Key Components</h3> <ul> <li><strong>Entities</strong> (domain objects, such as \"Customer\", \"Order\").</li> <li><strong>Attributes</strong> (entity properties: \"Customer ID\", \"Order Date\").</li> <li><strong>Relationships</strong> (relationships between entities: \"Customer places an Order\").</li> <li><strong>Keys</strong> (PK (Primary Key) is a unique record identifier, FK (Foreign Key) is usually a reference to the PK of another entity).</li> </ul> <p><i>Example in Mermaid</i></p><pre><div>erDiagram</div><div style=\"margin-left:30px\">CUSTOMER ||--o{ ORDER : \"places\"<br>ORDER ||--|{ LINE_ITEM : \"contains\"<br>PRODUCT ||--o{ LINE_ITEM : \"is\"<br>CUSTOMER }|..|{ DELIVERY_ADDRESS : \"has\"<br><p>%% Description of entities and their attributes</p><br>CUSTOMER {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>STRING name<br>STRING email<br>DATE created_at</div>}<br>ORDER {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER customer_id FK<br>DATE order_date<br>STRING status</div>}<br>LINE_ITEM {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER order_id FK<br>INTEGER product_id FK<br>INTEGER quantity<br>DECIMAL unit_price</div>}<br>PRODUCT {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>STRING title<br>DECIMAL price<br>BOOLEAN is_available</div>}<br>DELIVERY_ADDRESS {<div style=\"margin-left:50px\"><br>INTEGER id PK<br>INTEGER customer_id FK<br>STRING address<br>STRING city<br> STRING postal_code</div>}</div></pre> <div><p>How to read relationship notations in Mermaid</p><ul><li>||--o{ — one-to-many (1:N), left side required, right side optional;</li><li>||--|{ — one-to-many (1:N), both sides required;</li><li>}|..|{ — one-to-many (1:N), both sides optional;</li><li>||--|| — \"one to one\" (1:1);</li><li>o{--o{ — \"many to many\" (M:N).</li></ul></div><img width=\"800px\" height=\"1000px\" src=\"erd.png\"><p><i>Example of ERD generated in Mermaid</i></p> <h3>When to use</h3> <ul> <li>At the database design stage.</li> <li>To clarify data storage requirements.</li></li></ul></section>"
        },
        {
            "id": "7",
            "title": "Chapter VII: Requirements Validation",
            "content": "<p>In this chapter, we will look at two requirements validation techniques - demos and acceptance criteria.</p><section> <h3>1. Demonstrations (Demos)</h3> <p>Visual verification of requirements implementation by showing working functionality.</p> <h4>Demo Objectives</h4> <ul> <li>Confirm that the functionality meets stakeholder expectations.</li> <li>Identify discrepancies between requirements and implementation.</li> <li>Get feedback for adjustments.</li> <li>Increase transparency of the development process.</li> </ul> <h4>How to Organize an Effective Demo</h4> <ol> <li><strong>Prepare a scenario:</strong> decide in advance what functions and scenarios you will demonstrate.</li> <li><strong>Invite key stakeholders:</strong> customers, end users, business representatives.</li> <li><strong>Show real data:</strong> use examples from business processes, not abstract test values.</li> <li><strong>Include negative scenarios:</strong> demonstrate how the system reacts to errors and exceptional situations.</li> <li><strong>Record feedback:</strong> write down comments and questions for further work.</li> </ol> <p><strong><i>Example:</i></strong> When demoing the checkout module, show: selecting a product → adding to cart → entering data → payment → receiving confirmation. Then simulate a payment error and check the processing.</p><p><strong><i>Tip:</i></strong> Businesses are not very interested in how the system works, so the demo should be as lively as possible, close to their reality. If your product is a marketplace, tell a story about how you liked the mug, you decide to buy it, add it to the cart, and so on. Besides, this will make the demo not so boring.</p></section><section> <h3>2. Acceptance Criteria</h3> <p>Specific conditions that must be met for a requirement to be considered implemented.</p> <h4>Why are they needed?</h4> <ul> <li>They eliminate ambiguity in understanding requirements.</li> <li>Serve as a basis for testing.</li> <li>Help assess the readiness of functionality.</li> <li>Reduce the risk of disputes between the team and the customer.</li> <li>Help find missed scenarios.</li> </ul> <h4>Short scenario format</h4> <p>The easiest way to write acceptance criteria is as short scenarios. Below is an example of such acceptance criteria for the \"Password recovery\" feature:</p><ol><li>User on the login page. The user clicks \"Forgot your password\", sees a screen with an email field, enters a valid email, and clicks the \"Send link\" button. password recovery`. <b>Expected result: </b> The user receives an email with a reset link.</li><li>The user is on the login page. The user clicks \"Forgot your password\", sees a screen with an email field, and enters an invalid email. <b>Expected result: </b> The `Send password recovery link` button is inactive, the field borders turn red, and the user sees a validation error below the field `The email address is invalid. Use the format user@example.com`.</li></ol></section><section> <h4>Gherkin Script Format</h4> <p>A specialized language for describing acceptance criteria in a human-readable format; it is declared to be easily converted into automated tests.</p> <p>Uses English keywords (can be adapted to any other language):</p> <ul> <li><code>Feature:</code> — the name of the functionality. (Functionality)</li> <li><code>Scenario:</code> — a specific verification scenario. (Scenario)</li> <li><code>Given:</code> — initial conditions. (Given)</li> <li><code>When:</code> — action. (When)</li> <li><code>Then:</code> — result. (Then)</li> <li><code>And: (And)</code> / <code>But:</code> — additional conditions. (But)</li> </ul> <i>Example on Gherkin</i> <pre>Functionality: Placing an order<br>Scenario: Successful checkout with card payment<br>Given: the user is authorized<br>And: there are products in the cart<br>When: he selects the payment method \"Bank card\" <br>And: enters correct card details <br>Then: the order is confirmed<br>And: is written off sum<br>And: an email notification is sent</pre> <p>Advantages of Gherkin: </p> <ul> <li>Common understanding: reads the same way by business analysts, developers, and testers. </li> <li>Automation: scenarios can be turned into automated tests (Cucumber, SpecFlow). </li> <li>Documentation: serves as a living description of the functionality.</li></ul> <p>Disadvantages of Gherkin: </p><ul><li>Scripts become very verbose.</li><li>Due to an attempt to describe a scenario for automated tests, readability for business is reduced.</li><li>Scripts must be written from the user’s point of view, which reduces the detail of the system requirements within the scenario.</li></ul> </section><h4>Test Script Format</h4><p>Instead of short scenarios, each step, precondition, and expected result is described; there is no binding to users, they are easier for testers to use for writing tests, They are also suitable for automation. Below is a copied example from the previous chapter.</p> <ol><li>Response to a request for new product receipts contains new fields<p><b>Prerequisite:</b> An order has been created to receive goods at the warehouse for product with productName = 'T-Shirt', for 10 pieces, order number 'PO123456', order line number 1 </p><p><b>Steps</b><ol><li>Create a receipt via the API `POST api/receipt` for order 'PO123456', line number 1, for 10 pieces</li><li>Send a GET request `api/receipt` with the dateFrom parameter filled in with today's date</li></ol></p><p><b>Expected result:</b> The response contains the receipt of goods with productName = 'T-Shirt', for order 'PO123456', lines 1, with expectedQuantity = 10, receivedQuantity=10</p></li><li>Receipt for untitled product<p><b>Prerequisite:</b> An order has been created to receive goods at the warehouse for product with productName = null, for 12 pieces, order number 'PO123457', order line number 2 </p><p><b>Steps</b><ol><li>Create a receipt via API `POST api/receipt` for order 'PO123457', line number 2, for 10 pieces</li><li>Send a GET request `api/receipt` with the dateFrom parameter filled in with today's date</li></ol></p><p><b>Expected result:</b> The response contains the receipt of goods with productName = null, for order 'PO123457', line 2, with expectedQuantity = 12, receivedQuantity=10</p></li></ol><section><h4>Best Practices</h4> <ul> <li>Write criteria before development begins.</li><li>Include edge cases (empty fields, invalid formats).</li> <li>Agree with testers and customers.</li><li>Try to draw scenarios in the form of prototypes (you can agree on scenarios using prototypes - it is much clearer).</li> </ul></section><section> <h4>Common Mistakes</h4> <ul> <li><strong>Lack of criteria:</strong> requirements without clear acceptance conditions lead to different interpretations.</li> <li><strong>Too general formulations:</strong> \"The system works correctly.\"</li> <li><strong>Ignoring negative scenarios:</strong> test not only the \"happy path.\"</li> <li><strong>Demo without preparation:</strong> A chaotic demonstration of functionality does not provide valuable feedback.</li> <li><strong>Gherkin as a formality:</strong> writing scenarios \"for show\" without using them in testing.</li> </ul></section><section> <p>Requirements validation is not a final stage, but an ongoing process. By combining demos and acceptance criteria, you:</p> <ul> <li>reduce the risk of misunderstanding;</li> <li>save time on rework;</li> <li>improve product quality;</li> <li>make development more transparent for all participants.</li> </ul> <p>Start small: for each new feature, formulate 3-5 acceptance criteria and conduct a mini-demo for stakeholders.</p></section>"
        },
        {
            "id": "8",
            "title": "Chapter VIII: SQL for BA",
            "content": "<p>This chapter is not intended to be a complete reference on databases, but analytics needs to interact with relational databases in one way or another. At the same time, there are other data storage formats, such as NoSQL databases and FTP. We can talk about this in future chapters.</p><section> <p>Business analytics needs SQL for:</p> <ul> <li>independently extracting data from databases;</li> <li>testing hypotheses without involving developers;</li> <li>preparing reports and dashboards;</li> <li>analyzing user behavior;</li> <li>validating data requirements.</li> </ul> <p>Knowing basic operators is enough - leave complex optimizations to the DBA.</p></section><section> <h3>1. SELECT - data selection</h3> <p>The main operator for retrieving data from a table.</p> <h3>Basic Syntax</h3> <pre>SELECT column1, column2 FROM table_name;</pre> <h3>Examples</h3> <ul> <li>Select all columns: <code>SELECT * FROM client;</code></li> <li>Select specific columns: <code>SELECT name, email FROM client;</code></li> <li>With filtering: <code>SELECT * FROM order WHERE status = 'Paid';</code></li> <li>With sorting: <code>SELECT * FROM product ORDER BY price DESC;</code></li> </ul> <h3>Useful modifiers</h3> <ul> <li><code>WHERE</code> — selection condition (filtering).</li> <li><code>ORDER BY</code> — sorting (ASC/DESC).</li> <li><code>TOP</code> — limit on the number of rows.</li> </ul></section><section> <h3>2. JOIN — combining tables</h3> <p>Allows you to relate data from multiple tables using common fields.</p> <h4>Basic JOIN Types</h4> <h5>INNER JOIN</h5> <p>Returns only matching rows from both tables.</p> <pre>SELECT order.id, client.name FROM order INNER JOIN client ON order.client_id = client.id;</pre> <h5>LEFT JOIN</h5> <p>Returns all rows from the left table and matching ones from the right (if there are no matches, NULL).</p> <pre>SELECT client.name, order.sum FROM client LEFT JOIN order ON client.id = order.client_id;</pre> <h5>RIGHT JOIN</h5> <p>Similar to LEFT JOIN, but for the right table.</p></section><section> <h3>3. DISTINCT — unique values</h3> <p>Removes duplicates from the query result.</p> <h4>Syntax</h4> <pre>SELECT DISTINCT column FROM table;</pre> <h4>Examples</h4> <ul> <li>Unique order statuses: <code>SELECT DISTINCT status FROM order;</code></li> <li>Unique combinations: <code>SELECT DISTINCT city, region FROM client;</code></li></ul></section><section> <h3>4. MAX — maximum value</h3> <p>Finds the largest value in a column.</p> <h4>Syntax</h4> <pre>SELECT MAX(column) FROM table;</pre> <h4>Examples</h4> <ul> <li>Maximum product price: <code>SELECT MAX(price) FROM product;</code></li> <li>Last order date: <code>SELECT MAX(date) FROM order;</code></li> <li>With grouping: <code>SELECT category, MAX(price) FROM producy GROUP BY category;</code></li> </ul> </section><section> <h3>5. AVG — average value</h3> <p>Calculates the arithmetic mean of the values in a column.</p> <h4>Syntax</h4> <pre>SELECT AVG(column) FROM table;</pre> <h4>Examples</h4> <ul> <li>Average order value: <code>SELECT AVG(sum) FROM order;</code></li> <li>Average customer age: <code>SELECT AVG(age) FROM client;</code></li> <li>By category: <code>SELECT type, AVG(rate) FROM feedback GROUP BY type;</code></li> </ul> <p><strong>Important:</strong> AVG ignores NULL values.</p></section><section> <h3>SQL Tips</h3> <ul> <li><strong>Start simple:</strong> master SELECT and WHERE first, then move on to JOIN.</li> <li><strong>Use comments:</strong> <code>-- Your comment</code> or <code>/* comment */</code>. </li> <li><strong>Test queries:</strong> run on small samples (<code>TOP 10</code>).</li> <li><strong>Study the database structure:</strong> find out the names of tables and keys from administrator.</li> <li><strong>Save templates:</strong> create a library of frequently used queries.</li><li><strong>Dialects:</strong> different SQL dialects have minor differences in keywords and syntax; here I've given examples from TSQL.</li></ul></section>"
        },
        {
            "id": "9",
            "title": "Chapter IX: API Documentation",
            "content": "<p>API documentation is a formal and at the same time practical description of how external and internal clients can interact with the server part of the system. Essentially, it is a <strong>contract</strong> that answers the questions:</p><ul> <li>What endpoints exist</li> <li>What data and in what format should be transferred</li> <li>What responses and errors can be received</li> <li>What restrictions and rules apply</li></ul><p>Good documentation lowers the entry barrier, speeds up integrations and reduces the number of errors. Poor or absent documentation leads to guesswork, chaotic edits and conflicts between teams.</p><h3>Main Approaches to API Documentation</h3><p>In practice, two approaches are most often used:</p><ul> <li><strong>request-first</strong> - documentation is built on the basis of real requests</li> <li><strong>API-first</strong> — first the contract is described, then the code is implemented</li></ul><h3>API Documentation in Postman</h3><h4>What is Postman and when is it suitable?</h4><p>Postman was originally created as a tool for API testing, but over time it has evolved into a universal platform for working with requests, environments, automated tests, and documentation.</p><p>Postman is especially well suited when:</p><ul> <li>the API already exists</li> <li>it is important to quickly show example requests</li> <li>the documentation is used by developers and QA</li></ul><h4>Collections as the basis for documentation</h4><p>Documentation in Postman is built around <strong>collections</strong>. Each request within a collection can be provided with a description and examples.</p><p>Example of the collection structure:</p><pre>Users <br>├── GET /users <br>├── GET /users/{id} <br>├── POST /users <br>└── DELETE /users/{id}</pre><h4>Example of a documented request in Postman</h4><p>Endpoint description:</p><pre>GET /users/{id}<br>Returns information about a user by their ID. Requires authorization.</pre><p>Parameters:</p><ul> <li><strong>id</strong> (path, integer) — user ID</li></ul><p>Example response (200 OK):</p><pre>{ <br>\"id\": 42, <br>\"name\": \"Ivan Ivanov\", <br>\"email\": \"ivan@example.com\"<br>}</pre><p>Example error (404 Not Found):</p><pre>{ <br>\"error\": \"User not found\"<br>}</pre><h4>Advantages of Postman</h4><ul> <li>documentation is created \"as you go\"</li> <li>live examples of requests and responses</li> <li>easy to share with the team</li></ul><h4>Cons of Postman</h4><ul> <li>no strict formalization of the contract</li> <li>difficult to track API changes</li> <li>documentation may lag behind implementation</li></ul><h3>API Documentation in Swagger</h3><h4>Swagger and the OpenAPI Specification</h4><p>Swagger is a set of tools based on the OpenAPI specification</strong>. Here the API is described declaratively - in the form of a formal contract.</p><p>The main principle: <strong>first the description, then code</strong>.</p><h4>OpenAPI Document Structure</h4><p>A typical OpenAPI file contains:</p><ul> <li>API description and version</li> <li>endpoints and HTTP methods</li> <li>parameters</li> <li>data schemas</li> <li>response codes and errors</li></ul><h4>Example of an endpoint description in Swagger (YAML)</h4><code>paths: <div style=\"margin-left:30px\">/users/{id}:</div><div style=\"margin-left:40px\">get:</div> <div style=\"margin-left:50px\">summary: Get user</div> <div style=\"margin-left:50px\">parameters:</div> <div style=\"margin-left:60px\">- name: id</div> <div style=\"margin-left:80px\">in: path</div> <div style=\"margin-left:80px\">required: true</div> <div style=\"margin-left:80px\">schema:</div> <div style=\"margin-left:95px\">type: integer</div> <div style=\"margin-left:50px\">responses:</div> <div style=\"margin-left:80px\">'200':</div> <div style=\"margin-left:95px\">description: Successful response</div> <div style=\"margin-left:80px\">'404':</div> <div style=\"margin-left:95px\">description: User not found</div></code><p>Based on this description, an interactive Documentation where you can send requests directly from the browser.</p><h4>Pros of Swagger</h4><ul> <li>clear and verifiable contract</li> <li>convenient for external clients</li> <li>supports generation of SDKs and server-side templates</li></ul><h4>Cons of Swagger</h4><ul> <li>requires more time for initial setup</li> <li>less flexible for exploratory testing</li></ul><h3>Postman and Swagger together</h3><p>In practice, these tools are often used together:</p><ul> <li>Swagger - as a single source of truth for the API</li> <li>Postman - for testing and examples</li></ul><p>A common scenario:</p><ol> <li>describe the API in OpenAPI</li> <li>generate Swagger documentation</li> <li>import the specification into Postman</li> <li>supplement requests Tests and Examples</li></ol><h3>Typical Mistakes in API Documentation</h3><ul> <li>Only the happy path is described</li> <li>No error examples</li> <li>Documentation is not updated</li> <li>Mismatch between the documentation and the actual API</li></ul><p>Postman and Swagger solve the same problem—documenting APIs—but from different angles. Swagger sets a strict contract and is great for an API-first approach, while Postman makes the API visual and easy to test.</p><p>Using both tools together allows you to get up-to-date, understandable, and useful documentation that really helps you work with the API.</p>"
        },
        {
            "id": "10",
            "title": "Chapter X: How to Work in an Agile Team",
            "content": "<section> <p>In an Agile team, a BA is not a \"transfer link\", but an active participant in the development process.</p> <h3>1. The Role of a Business Analyst in Agile</h3> Key functions of the analyst:</p> <ul> <li>identifying and analyzing customer needs;</li> <li>formulating User Stories and acceptance criteria;</li> <li>supporting communication between business and development;</li> <li>analyzing data for task prioritization;</li> <li>participating in demonstrations and retrospectives.</li> </ul> <p><strong>Important:</strong> focus on user value, not formal documentation.</p></section><section> <h3>2. Interacting with the Product Owner</h3> <p>Collaborating on the backlog:</p> <ol> <li>Help the PO Structure requirements (break down large tasks).</li> <li>Clarify the business context for each User Story.</li> <li>Suggest metrics for assessing the value of features.</li> <li>Discuss trade-offs between business needs and technical constraints.</li> </ol> <p><strong>Example:</strong> If the PO asks to \"improve the interface\", ask questions: \"Which metrics will we improve? Which user scenarios will we address?\"</p></section><section> <h3>3. Working with the Development Team</h3> <p>How to Interact Effectively:</p> <ul> <li><strong>During Sprint Planning:</strong> Clarify requirements, discuss risks.</li> <li><strong>During the Sprint:</strong> Quickly clarify details, participate in discussions of solutions.</li> <li><strong>During Testing:</strong> Check that the result meets the business goals.</li> <li><strong>At the demo:</strong> explain the value of the implemented features to the customer.</li> </ul> <p><strong>Tip:</strong> attend daily stand-ups, even if you are not asked - it helps to be in context.</p></section><section> <h3>4. Documentation in Agile</h3> <p>Principle: \"Enough, but not excessive.\" What and how to record:</p> <ul> <li><strong>User Stories:</strong> format \"As [role], I want [feature], so that [benefit]\".</li> <li><strong>Acceptance Criteria:</strong> specific conditions for completing the task (Given-When-Then).</li> <li><strong>Diagrams/diagrams:</strong> only if they simplify understanding (e.g., C4, BPMN).</li> <li><strong>Resolutions on contentious issues:</strong> briefly record the results discussions.</li> </ul> <p><strong>Avoid:</strong> multi-page technical specifications without reference to iterations.</p></section><section> <h3>5. Requirements analysis in an iterative mode</h3> <p>Step-by-step approach:</p> <ol> <li><strong>Identification:</strong> interviews with stakeholders, data analysis, process observation.</li> <li><strong>Formulation:</strong> turn needs into User Stories with acceptance criteria and put them in the backlog.</li> <li><strong>Prioritization:</strong> together with the PO, determine the implementation order, put tickets in sprints.</li> <li><strong>Planning:</strong> before the sprint, plan tasks with the team, set estimates to understand the complexity of the implementation.</li> <li><strong>Validation:</strong> check on the demo whether it solves functionality user task.</li> </ol></section><section> <h3>6. Participation in Agile Rituals</h3> <table border='1' cellpadding='5'> <tr> <th>Ritual</th> <th>The Role of the BA</th> </tr> <tr> <td>Sprint Planning</td> <td>Clarifying requirements, estimating task complexity.</td> </tr> <tr> <td>Daily Standup</td> <td>Reporting on analysis progress and blocking.</td> </tr> <tr> <td>Sprint Review</td> <td>Demonstrating the value of implemented features, collecting feedback.</td> </tr> <tr> <td>Retrospective</td> <td>Suggesting improvements to analysis and communication processes.</td> </tr> </table></section><section> <h3>7. Handling Changes</h3> <p>In Agile, requirements change—that’s the norm. How to respond:</p> <ul> <li>Evaluate the impact of a new requirement on the current sprint.</li> <li>Record the reasons for changes (to avoid “wandering” requirements).</li> <li>Update User Stories and Acceptance Criteria as needed.</li> <li>Explain the business context of the changes to the team.</li> </ul> <p><strong>Rule:</strong> “No changes mid-sprint without team approval.”</p></section><section> <h3>8. Typical BA Mistakes in Agile</h3> <ul> <li><strong>“Shifting” responsibility:</strong> expecting the team to come up with the requirements themselves.</li> <li><strong>Excessive detail:</strong> trying to describe everything in detail before development begins.</li> <li><strong>Absence Validation:</strong> Not checking whether the developer has understood the essence of the task.</li> <li><strong>Ignoring data:</strong> Making decisions without analyzing metrics and user behavior.</li> <li><strong>Resistance to change:</strong> Protecting the “perfect” specification instead of adapting to reality.</li> </ul></section><section> <h3>9. Tips for an effective BA in Agile</h3> <ol> <li>Speak the language of business and technology: Translate requirements between stakeholders.</li> <li>Focus on value: Each feature should solve a specific problem.</li> <li>Be proactive: Suggest process improvements, not just capture requirements.</li> <li>Learn from the team: Understand technical limitations and capabilities.</li> <li>Document iteratively: Update materials as details are clarified.</li> <li>Develop facilitation skills: Conduct effective meetings.</li> <li>Use visualization: diagrams are often clearer than text.</li> <li>Start writing requirements for the new sprint immediately after planning the current sprint - writing it down a couple of sprints in advance isn't the worst idea.</li> </ol></section>"
        },
        {
            "id": "11",
            "title": "Chapter XI: Captured by Gant",
            "content": "<p>A Software Requirements Specification (SRS) is a key document in software development that formally describes <strong>what exactly the system should do</strong>. One of the most common and time-tested approaches is to use the IEEE template. It helps structure requirements, avoid ambiguities, and simplify communication between the customer, analysts, developers, and testers.</p><p>In this article, we will discuss <strong>how to write an SRS correctly, following the IEEE template</strong>, and what to pay attention to in each section.</p><h3>1. Introduction</h3><h4>1.1 Purpose</h4><p>Here you should briefly explain <strong>why this document was created</strong> and what product it describes. Indicate the system name, version, and scope of responsibility of the SRS (the entire system or just part of it).</p><h4>1.2 Document Conventions</h4><p>Describe the rules for formatting requirements: numbering, keywords, priorities, use of the abbreviation TBD (to be discussed).</p><h4>1.3 Intended Audience and Reading Suggestions</h4><p>List who the document is intended for: developers, testers, managers, customers. You can indicate which sections are most useful for each role.</p><h4>1.4 Product Scope</h4><p>A brief description of the product, its goals and business value. Here it is important to answer the question: <em>what problem does the system solve</em>.</p><h4>1.5 References</h4><p>List of related documents: vision & scope, contracts, standards, UX guides and other sources that the SRS relies on.</p><h3>2. Overall Description</h3><h4>2.1 Product Perspective</h4><p>Describe whether the system is new, part of an existing ecosystem or replacing an old solution. It is useful to provide a high-level text or logical description of the environment.</p><h4>2.2 Product Functions</h4><p>List the key features of the system at a high level. These are not detailed requirements, but an overview of the product's capabilities.</p><h4>2.3 User Classes and Characteristics</h4><p>Describe the types of users, their experience, frequency of use, and level of access. This will help us formulate requirements correctly in the future.</p><h4>2.4 Operating Environment</h4><p>Specify where the system will run: OS, devices, browsers, third-party services, and environmental constraints.</p><h4>2.5 Design and Implementation Constraints</h4><p>All constraints are recorded here: technological, regulatory, corporate standards, mandatory tools, or languages.</p><h4>2.6 User Documentation Documentation)</h4><p>List the documentation that will be included with the product: manuals, help, tutorials.</p><h4>2.7 Assumptions and Dependencies</h4><p>Record assumptions and external dependencies that may impact the project requirements and timeline.</p><h3>3. External Interface Requirements</h3><h4>3.1 User Interfaces</h4><p>Describe the UI requirements: screens, standards, navigation, common elements, and constraints.</p><h4>3.2 Hardware Interfaces</h4><p>Requirements for interaction with hardware, if used.</p><h4>3.3 Software Interfaces</h4><p>Integrations with other systems, APIs, databases, data formats, and protocols interactions.</p><h4>3.4 Communications Interfaces</h4><p>Description of network protocols, message formats, security and data transfer rate requirements.</p><h3>4. System Features</h3><p>This section is the heart of the SRS. It describes the system's functions, grouped by features or scenarios.</p><h4>4.x System Feature</h4><ul> <li><strong>Description and Priority</strong> - what the feature does and how important it is</li> <li><strong>Stimulus/Response</strong> - the sequence of user actions and system reactions</li> <li><strong>Functional Requirements</strong> - detailed, atomic, and testable requirements</li></ul><p>Each requirement should be:</p><ul> <li>unambiguous</li> <li>testable</li> <li>necessary</li> <li>unique identified</li></ul><h3>5. Other Nonfunctional Requirements (Nonfunctional Requirements)</h3><h4>5.1 Performance Requirements (Performance)</h4><p>Response times, load, scalability, and resource constraints.</p><h4>5.2 Safety Requirements (Safety)</h4><p>Requirements related to the prevention of damage and risks.</p><h4>5.3 Security Requirements (Information Security)</h4><p>Authentication, authorization, data protection, and compliance with standards.</p><h4>5.4 Software Quality Attributes (Software Quality)</h4><p>Reliability, usability, maintainability, portability, and other quality attributes.</p><h4>5.5 Business Rules (Business Rules)</h4><p>Rules that define the behavior of the system from the point of view of business and user roles.</p><h3>6. Other Requirements (Other Requirements)</h3><p>Any additional requirements not covered in the previous sections.</p><h3>Appendices</h3><h4>Appendix A: Glossary</h4><p>A dictionary of terms and abbreviations used in the document.</p><h4>Appendix B: Analysis Models</h4><p>Diagrams, data models, states, and other analytical materials.</p><h4>Appendix C: To Be Determined List</h4><p>A list of all TBDs that need to be clarified in the future.</p><p><strong>Summary:</strong> Using the IEEE template for SRS allows you to create a clear, structured, and understandable document that serves as a reliable basis for software design, development, and testing.</p>"
        },
        {
            "id": "12",
            "title": "Chapter XII: Change Management",
            "content": "<p>You know, I'd like to write about this very simply. Sooner or later, a client will come running to you, right when you're writing requirements, right in the middle of a sprint, and say that he urgently needs to implement some functionality. But the developers are already busy, the testers have started regressing the next version.</p><p>Here's my step-by-step algorithm: </p><ol><li>Determine with the stakeholders what this requirement is;</li><li>Set a deadline and priority, preferably comparing with current tasks in the current sprint;</li><li>Go to the development team or tech lead and get an estimate. It is advisable to prepare several implementation options and several estimates for them in order to provide stakeholders with an alternative. Be sure to outline what losses the next sprint or release will incur, how much the release will need to be postponed;</li><li>Agree on one of the options with the stakeholders;</li></ol><p>If you can't reach an agreement the first time, you can get together with development team and prepare new alternatives.</p><p>Change documentation is no different from documenting any other requirements. In any case, any agreements must be documented—written down in emails.</p>"
        },{
            "id": "13",
            "title": "Chapter XIII: Message Queues",
            "content": "<p>In distributed systems, message queues are used to asynchronously exchange data between services. For a business analyst and systems analyst, understanding the principles of queue operation is necessary for the correct formulation of requirements: what events are transmitted, in what format, what delivery guarantees are required, how errors and duplicates are handled.</p><p>Without these clarifications, the technical specification will be incomplete, which will lead to discrepancies in the implementation.</p><h3>Basic concepts: queue, topic, broker</h3><p>A message queue is a mechanism for transmitting messages between systems through a message broker.</p><ul><li><strong>Producer (sender)</strong> is a service that publishes a message.</li><li><strong>Consumer (recipient)</strong> is a service that reads a message.</li><li><strong>Broker</strong> is an infrastructure component that manages message delivery.</li><li><strong>Queue</strong> is a one-to-one model (one message to one consumer).</li><li><strong>Topic</strong> is a one-to-many model (the message is received multiple subscribers).</li></ul><p>Example of popular brokers: <strong>ActiveMQ</strong> and <strong>Apache Kafka</strong>.</p><h3>Business case: transferring an order from API Gateway to the order storage service</h3><p>Let's consider an example: a client sends an HTTP request to create an order. The request arrives at API Gateway. Instead of synchronously calling the order storage service, API Gateway publishes a message to the queue. The order service asynchronously receives a message and saves the data to the database.</p><h3>Architectural diagram of interaction</h3><ol><li>Client sends POST /orders</li><li>API Gateway checks authorization</li><li>API Gateway publishes a message to the broker</li><li>Order Service reads the message</li><li>Order Service saves the order to the database</li></ol><h3>Message format (example JSON)</h3><pre>{ <br>\"eventId\": <br>\"uuid-12345\", <br>\"eventType\": <br>\"OrderCreated\", <br>\"eventTime\": \"2026-02-19T10:15:30Z\", <br>\"source\": \"api-gateway\", <br>\"payload\": { <br>\"orderId\": \"ORD-10001\", <br>\"customerId\": \"CUST-777\", <br>\"orderDate\": \"2026-02-19\", <br>\"currency\": \"RUB\", <br>\"totalAmount\": 12500.50, <br>\"items\": <br>[ <br>{ <br>\"productId\": \"P-100\", <br>\"quantity\": 2, <br>\"price\": 5000 <br>}, <br>{ <br>\"productId\": \"P-200\", <br>\"quantity\": 1, <br>\"price\": 2500.50 <br>} <br>] <br>}}</pre><h3>What the analyst should record in <h3>Technical Specifications</h3><ul><li>Queue or Topic Name</li><li>Message Format (JSON / Avro / XML)</li><li>Required Fields</li><li>Delivery Guarantee (at least once / exactly once)</li><li>Idempotency Requirements</li><li>Retrace Policy</li><li>Error Scenarios</li><li>Message Storage Period</li></ul><h3>ActiveMQ Implementation</h3><p>ActiveMQ implements the classic JMS (Java Message Service) model. It has queues (Queue) and topics (Topic).</p><h3>Example Configuration for ActiveMQ</h3><ul><li>Queue name: ORDER.CREATED.QUEUE</li><li>Producer: api-gateway</li><li>Consumer: order-service</li><li>Delivery Mode: persistent</li><li>Acknowledgement Mode: client acknowledgment</li></ul><p>In the Queue model, each message will be processed by only one order-service instance. This is convenient for load balancing.</p><h3>Features that an analyst should consider with ActiveMQ</h3><ul><li>The message can be re-delivered (if the consumer has not acknowledged receipt).</li><li>Idempotency by the eventId or orderId field is required.</li><li>Dead Letter Queue can be configured (for example, ORDER.CREATED.DLQ).</li><li>Message TTL must be defined.</li></ul><h3>How it would look in Apache Kafka</h3><p>Apache Kafka uses a logging model (append-only log). Instead of queues, there are topics, which are divided into partitions.</p><h3>Example Kafka configuration</h3><ul><li>Topic name: order.created.v1</li><li>Number of partitions: 3</li><li>Replication factor: 2</li><li>Producer: api-gateway</li><li>Consumer group: order-service-group</li></ul><h3>Message key in Kafka</h3><p>In Kafka, it is important to define the key. For example:</p><pre>Key: orderIdValue: JSON with the OrderCreated event</pre><p>Using orderId as a key ensures that all events of one order fall into the same partition and the processing order is preserved.</p><h3>Differences between ActiveMQ and Kafka in terms of requirements</h3><table border=\"1\"><tr><td>Criteria</td><td>ActiveMQ</td><td>Kafka</td></tr><tr><td>Model</td><td>Queue / Topic</td><td>Distributed log</td></tr><tr><td>Storage</td><td>Until confirmation or TTL</td><td>By retention time (retention)</td></tr><tr><td>Repeatable read</td><td>Difficult</td><td>Easy (via offset)</td></tr><tr><td>Scaling</td><td>Through competing consumers</td><td>Through partitions</td></tr></table><h3>What else should be specified in the specification when using Kafka</h3><ul><li>Partitioning strategy</li><li>Retention policy (e.g.measures, 7 days)</li><li>Serialization format (JSON / Avro + Schema Registry)</li><li>Topic versioning (order.created.v1)</li><li>Consumer group</li><li>Delivery guarantees (at least once / exactly once)</li></ul><h3>Idempotency as a mandatory requirement</h3><p>Since most brokers guarantee delivery “at least once”, the order-service must be idempotent. The analyst should establish a rule: re-processing an event with the same eventId should not result in a duplicate order.</p><h3>Non-functional requirements</h3><ul><li>Performance (e.g. 1000 messages per second)</li><li>Maximum processing latency (no more than 5 seconds)</li><li>Monitoring and alerting</li><li>Logging correlationId</li><li>Fault tolerance requirements</li></ul><h3>Typical requirement wording for the specification</h3><p>When an order is created, the API Gateway must publish the OrderCreated event to the order.created.v1 topic of the message broker. The message format is JSON according to the approved schema. The order-service service must subscribe to this topic as part of the consumer group order-service-group and ensure idempotent message processing based on the eventId field.</p><p>An analyst who captures not only the business event but also the message format, queue/topic name, delivery guarantee, error handling strategy, and non-functional requirements significantly reduces the risk of integration problems.</p><p>Understanding the differences between ActiveMQ and Kafka allows you to correctly formulate architectural constraints and expectations from the development team.</p>"
        },
        {
            "id": "14",
            "title": "Chapter XIV: NoSQL and Object Storage",
            "content": "<p>In addition to classic relational DBMSs, modern information systems widely utilize non-relational databases (NoSQL) and object storage. It's important for business and systems analysts to understand the scenarios in which they are used, their limitations, and the parameters that need to be specified in the specifications.</p><p>If the specifications only state \"data is stored in the database\" or \"files are saved in storage,\" this creates uncertainty for developers and architects.</p><h3>What is a non-relational database (NoSQL)?</h3><p>NoSQL is a class of data storage systems that do not use the traditional tabular model with a rigid schema. They are designed for scalability, high load and flexible data structure.</p><p>The main types of NoSQL databases:</p><ul><li>Document-oriented (e.g. MongoDB)</li><li>Key-Value (e.g. Redis)</li><li>Column-oriented (e.g. Cassandra)</li><li>Graph (e.g. Neo4j)</li></ul><h3>When to use NoSQL: business scenarios</h3><ul><li>Event store</li><li>Product catalogs with different attribute structures</li><li>User profiles with dynamic fields</li><li>Session caching</li><li>Logs and telemetry</li></ul><p>NoSQL is suitable when the data structure changes frequently or horizontal scaling is required.</p><h3>Example 1: storing a customer profile in a document-oriented database</h3><p>In an online store, the profile The customer's profile may contain:</p><ul><li>Personal data</li><li>Address list</li><li>Order history</li><li>Notification settings</li></ul><p>In a document-oriented database, this could be stored as a single JSON document:</p><pre>{ <br>\"customerId\": \"CUST-777\", <br>\"name\": \"James James\", <br>\"email\": \"james@example.com\", <br>\"addresses\": <br>[ <br>{ <br>\"type\": \"delivery\", <br>\"city\": \"Chicago\", <br>\"street\": \"Carter street 2\" <br>} <br>], <br>\"preferences\": { <br>\"newsletter\": true, <br>\"smsNotifications\": false <br>}<br>}</pre><h3>What an analyst should specify in the specification when using NoSQL</h3><ul><li>Database type (document, key-value, etc.)</li><li>Data storage model (example of document structure)</li><li>Structure versioning rules</li><li>Indexing requirements</li><li>Data volume and expected growth</li><li>Scaling requirements</li><li>Consistency requirements (eventual / strong)</li><li>Backup requirements</li></ul><h3>Differences from relational databases that are important for the requirements</h3><ul><li>Lack of a rigid schema</li><li>Limited transaction support (in some systems)</li><li>Data denormalization</li><li>Optimization for reading or record</li></ul><p>It is important for an analyst to take into account that data can be duplicated in different documents, and it is necessary to describe business rules for synchronization.</p><h3>What is object storage</h3><p>Object storage is intended for storing files (objects): images, documents, videos, backups.</p><p>An example of a system is MinIO, compatible with the Amazon S3 API.</p><h3>Basic concepts of object storage</h3><ul><li>Bucket is a logical container (analogous to a directory)</li><li>Object is a file</li><li>Key is a unique path to an object</li><li>Metadata is an object's metadata</li></ul><h3>Example 2: storing order documents in MinIO</h3><p>The electronic document management system must store:</p><ul><li>PDF invoices</li><li>Signed contracts</li><li>Scanned copies of documents</li></ul><p>Example Storage structures:</p><ul><li>Bucket: order-documents</li><li>Object key: 2026/02/ORD-10001/invoice.pdf</li><li>Metadata: <ul> <li>orderId: ORD-10001</li> <li>documentType: invoice</li> <li>uploadedBy: order-service</li> </ul></li></ul><h3>When to use object storage</h3><ul><li>Storing large files</li><li>Media content</li><li>Archives and backups</li><li>Documents related to business entities</li></ul><h3>What an analyst should record in the specifications for object storage</h3><ul><li>Bucket name</li><li>Key structure (key naming convention)</li><li>Maximum size <li>Allowed file formats</li><li>Storage policy (retention)</li><li>Encryption requirements</li><li>Access rights (who reads, who downloads)</li><li>File storage period</li><li>Object versioning requirements</li></ul><h3>Example of a requirement statement for a specification (NoSQL)</h3><p>The client profile must be stored in a document-oriented database. The document structure is defined by an approved JSON schema. The system must support horizontal scaling and storage of at least 10 million documents.</p><h3>Example of a requirement statement for a specification (Object Storage)</h3><p>All order documents must be saved in the order-documents bucket. Key format: {year}/{month}/{orderId}/{documentType}.{ext}. The maximum file size is 20 MB. Read access is only for the billing-service and order-service services.</p><h3>Non-functional requirements</h3><ul><li>Performance<li>Availability (file load/read time)</li><li>Availability (SLA, e.g. 99.9%)</li><li>Backup</li><li>Replication</li><li>Monitoring disk space usage</li></ul><h3>Typical Mistakes in Setting Requirements</h3><ul><li>Data model not specified</li><li>No storage capacity requirements</li><li>Data deletion strategy not described</li><li>Object naming rules not specified</li><li>No security requirements</li></ul><p>Understanding the differences between relational databases, NoSQL, and object storage allows the analyst to correctly formulate architectural constraints.</p><p>A good technical specification should contain:</p><ul><li>Storage type</li><li>Example data structure</li><li>Non-functional requirements</li><li>Security and access requirements</li><li>Rules scaling and redundancy</li></ul><p>The more specifically the data storage model is described, the fewer architectural risks and modifications there will be in the future.</p>"
        }
    ]
}